/**
 * Generated by API Builder - https://www.apibuilder.io
 * Service version: 0.7.56
 * apibuilder 0.14.75 app.apibuilder.io/flow/catalog/0.7.56/play_2_x_json
 */
package io.flow.catalog.v0.models {

  /**
   * A subcatalog can be represented with just it's ID, or the entire model
   */
  sealed trait ExpandableSubcatalog extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * Defines the valid discriminator values for the type ExpandableSubcatalog
   */
  sealed trait ExpandableSubcatalogDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object ExpandableSubcatalogDiscriminator {

    case object Subcatalog extends ExpandableSubcatalogDiscriminator { override def toString = "subcatalog" }
    case object SubcatalogReference extends ExpandableSubcatalogDiscriminator { override def toString = "subcatalog_reference" }

    final case class UNDEFINED(override val toString: String) extends ExpandableSubcatalogDiscriminator

    val all: scala.List[ExpandableSubcatalogDiscriminator] = scala.List(Subcatalog, SubcatalogReference)

    private[this] val byName: Map[String, ExpandableSubcatalogDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ExpandableSubcatalogDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ExpandableSubcatalogDiscriminator] = byName.get(value.toLowerCase)

  }

  /**
   * The localized prices for an item are returned as a list - the key of each
   * element is defined here
   */
  sealed trait LocalizedPrice extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * Defines the valid key values for the type LocalizedPrice
   */
  sealed trait LocalizedPriceKey extends _root_.scala.Product with _root_.scala.Serializable

  object LocalizedPriceKey {

    case object LocalizedItemPrice extends LocalizedPriceKey { override def toString = "localized_item_price" }
    case object LocalizedItemVat extends LocalizedPriceKey { override def toString = "localized_item_vat" }
    case object LocalizedItemDuty extends LocalizedPriceKey { override def toString = "localized_item_duty" }
    case object LocalizedTotal extends LocalizedPriceKey { override def toString = "localized_total" }

    final case class UNDEFINED(override val toString: String) extends LocalizedPriceKey

    val all: scala.List[LocalizedPriceKey] = scala.List(LocalizedItemPrice, LocalizedItemVat, LocalizedItemDuty, LocalizedTotal)

    private[this] val byName: Map[String, LocalizedPriceKey] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): LocalizedPriceKey = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[LocalizedPriceKey] = byName.get(value.toLowerCase)

  }

  /**
   * @param label The label for the adjustment reason that can be displayed as a tooltip on the
   *        product detail page.
   */
  final case class AdjustmentReason(
    key: io.flow.catalog.v0.models.AdjustmentReasonKey,
    label: String
  )

  /**
   * An attribute can be configured to be used in different ways throughout Flow. A
   * common example is to identify a meaningful attribute (e.g. brand) that can then
   * be displayed throughout the Flow console.
   * 
   * @param id The unique identifier for the attribute.
   * @param key The key of the attribute that identifies it within a map of attributes.
   * @param options Defines special rules for handling this attribute.
   * @param label A human-readable label used for display purposes.
   * @param intent Optionally specify the meaning of this attribute to ensure accurate processing,
   *        such as marking a price that should be localized. Note that specifying an intent
   *        may restrict what data types are legal -- for example, a price must also be of
   *        type decimal.
   * @param `type` Optionally tag attributes with their data type so they are properly validated.
   *        If omitted, we will default to string
   */
  final case class Attribute(
    id: String,
    key: String,
    options: io.flow.catalog.v0.models.Options,
    label: _root_.scala.Option[String] = None,
    intent: _root_.scala.Option[io.flow.catalog.v0.models.AttributeIntent] = None,
    `type`: _root_.scala.Option[io.flow.common.v0.models.AttributeDataType] = None,
    position: _root_.scala.Option[Long] = None
  )

  /**
   * @param key The actual attribute key. This key should match the keys used in the
   *        item.attributes maps
   * @param options Defines the configuration for how the options are used through flow
   * @param label A human-readable label used for display purposes
   * @param intent Optionally specify the meaning of this attribute to ensure accurate processing,
   *        such as marking a price that should be localized. Note that specifying an intent
   *        may restrict what data types are legal -- for example, a price must also be of
   *        type decimal.
   * @param `type` Optionally tag attributes with their data type so they are properly validated.
   *        If omitted, we will default to string
   * @param position The position of this attribute in the set of attributes. If not specified, will
   *        default to last
   */
  final case class AttributeForm(
    key: String,
    options: io.flow.catalog.v0.models.Options,
    label: _root_.scala.Option[String] = None,
    intent: _root_.scala.Option[io.flow.catalog.v0.models.AttributeIntent] = None,
    `type`: _root_.scala.Option[io.flow.common.v0.models.AttributeDataType] = None,
    position: _root_.scala.Option[Long] = None
  )

  /**
   * Retrieve journaled history of an attribute
   */
  final case class AttributeVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    attribute: io.flow.catalog.v0.models.Attribute
  )

  final case class Catalog(
    id: String
  )

  final case class CatalogReference(
    id: String
  )

  /**
   * Statistics covering product catalog item information, including total catalog
   * item count, number of distinct categories, etc.
   * 
   * @param items Total number of catalog items available from master catalog
   * @param categories Distinct number of catalog item categories
   */
  final case class CatalogStatistics(
    items: Long,
    categories: Long
  )

  final case class CatalogVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    catalog: io.flow.catalog.v0.models.Catalog
  )

  final case class FlowItemIndexMetadata(
    status: io.flow.catalog.v0.models.SubcatalogItemStatus
  )

  /**
   * The URL to an image, with optional tags. Flow Commerce primarily uses images to
   * enhance the administrative tools (e.g. showing an item image in console)
   * 
   * @param url The full URL to the image
   * @param tags Tags can be used to identify the type of image being sent
   */
  final case class Image(
    url: String,
    tags: Seq[io.flow.catalog.v0.models.ImageTag] = Nil
  )

  /**
   * Image form defines the data needed to create an image
   * 
   * @param url The full URL to the image
   * @param tags Optional tags that can keep track of the primary purpose of this image
   *        throughout the Flow platform.
   */
  final case class ImageForm(
    url: String,
    tags: _root_.scala.Option[Seq[io.flow.catalog.v0.models.ImageTag]] = None
  )

  /**
   * The Flow item defines a specific item that can be purchased by a consumer. For
   * many clients, this will map to a Sku.
   * 
   * @param locale Locale id. See https://api.flow.io/reference/locales
   * @param attributes Attributes of the items. An attribute of type intent must be given as a string
   *        representation of a decimal to be correctly localized.
   */
  final case class Item(
    id: String,
    number: String,
    locale: String,
    name: String,
    price: io.flow.common.v0.models.Price,
    categories: Seq[String] = Nil,
    description: _root_.scala.Option[String] = None,
    attributes: Map[String, String] = Map.empty,
    dimensions: io.flow.common.v0.models.Dimensions,
    images: Seq[io.flow.catalog.v0.models.Image] = Nil,
    local: _root_.scala.Option[io.flow.catalog.v0.models.Local] = None
  )

  /**
   * @param attributes Attributes of the item.
   */
  final case class ItemAttributesPatchForm(
    attributes: Map[String, String] = Map.empty
  )

  /**
   * The item form defines the data required to create an item.
   * 
   * @param locale The locale in which the content of this item is written.
   * @param name The customer friendly name of the actual item in the catalog.
   * @param currency ISO 4217 3 currency code as defined in https://api.flow.io/reference/currencies
   * @param price The actual price of the item as offered to a customer. This price must be in the
   *        currency specified for this item.
   * @param categories A list of categories associated with this item.
   * @param description If provided, the item description is used to improve classification.
   * @param attributes Attributes represent all other product data that you have regarding this item.
   *        Common attributes include 'country_of_origin', 'color', 'size', 'material', etc.
   *        We recommend including as many attributes as possible, even if you are not
   *        currently planning to use them.
   * @param dimensions If provided, dimensions are used to drive more accurate shipping estimates.
   * @param images If provided, the item images will be used to enhance the user experience in
   *        Flow's online tools.
   */
  final case class ItemForm(
    number: String,
    locale: String,
    name: String,
    currency: String,
    price: Double,
    categories: _root_.scala.Option[Seq[String]] = None,
    description: _root_.scala.Option[String] = None,
    attributes: _root_.scala.Option[Map[String, String]] = None,
    dimensions: _root_.scala.Option[io.flow.common.v0.models.Dimensions] = None,
    images: _root_.scala.Option[Seq[io.flow.catalog.v0.models.ImageForm]] = None
  )

  /**
   * The item form overlay defines data to merge into an item form.
   * 
   * @param categories A list of categories associated with this item.
   * @param description If provided, the item description is used to improve classification.
   * @param attributes Attributes represent all other product data that you have regarding this item.
   *        Common attributes include 'country_of_origin', 'color', 'size', 'material', etc.
   *        We recommend including as many attributes as possible, even if you are not
   *        currently planning to use them.
   * @param dimensions If provided, dimensions are used to drive more accurate shipping estimates.
   * @param images If provided, the item images will be used to enhance the user experience in
   *        Flow's online tools.
   */
  final case class ItemFormOverlay(
    id: String,
    number: String,
    position: Long,
    price: _root_.scala.Option[io.flow.common.v0.models.Price] = None,
    categories: _root_.scala.Option[Seq[String]] = None,
    description: _root_.scala.Option[String] = None,
    attributes: _root_.scala.Option[Map[String, String]] = None,
    dimensions: _root_.scala.Option[io.flow.common.v0.models.Dimensions] = None,
    images: _root_.scala.Option[Seq[io.flow.catalog.v0.models.ImageForm]] = None
  )

  /**
   * @param price The actual price of the item as offered to a customer. This price must be in the
   *        currency specified for this item.
   * @param position Position determines the order in which item form overlays are merged.  If not
   *        provided, will be treated as the last overlay to be merged.
   * @param categories A list of categories associated with this item.
   * @param description If provided, the item description is used to improve classification.
   * @param attributes Attributes represent all other product data that you have regarding this item.
   *        Common attributes include 'country_of_origin', 'color', 'size', 'material', etc.
   *        We recommend including as many attributes as possible, even if you are not
   *        currently planning to use them.
   * @param dimensions If provided, dimensions are used to drive more accurate shipping estimates.
   * @param images If provided, the item images will be used to enhance the user experience in
   *        Flow's online tools.
   */
  final case class ItemFormOverlayForm(
    number: String,
    price: _root_.scala.Option[Double] = None,
    currency: _root_.scala.Option[String] = None,
    position: _root_.scala.Option[Long] = None,
    categories: _root_.scala.Option[Seq[String]] = None,
    description: _root_.scala.Option[String] = None,
    attributes: _root_.scala.Option[Map[String, String]] = None,
    dimensions: _root_.scala.Option[io.flow.common.v0.models.Dimensions] = None,
    images: _root_.scala.Option[Seq[io.flow.catalog.v0.models.ImageForm]] = None
  )

  /**
   * @param currency ISO 4217 3 currency code as defined in https://api.flow.io/reference/currencies
   * @param price The actual price of the item as offered to a customer. This price must be in the
   *        currency specified for this item.
   * @param attributes Attributes of the items. An attribute of type intent must be given as a string
   *        representation of a decimal to be correctly localized.
   */
  final case class ItemPriceUpdatePutForm(
    currency: String,
    price: BigDecimal,
    attributes: Map[String, String] = Map.empty
  )

  /**
   * Statistics covering product catalog item information, including total catalog
   * item count, number of distinct categories, etc.
   * 
   * @param items Total number of catalog items available from master catalog
   * @param categories Distinct number of catalog item categories
   */
  final case class ItemStatistics(
    items: Long,
    categories: Long
  )

  final case class ItemVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    item: io.flow.catalog.v0.models.Item
  )

  /**
   * @param attributes This field contains the localized attributes. For instance a base attribute of
   *        intent price will be converted in the target currency.
   * @param priceAttributes This field contains the localized prices attributes.
   */
  final case class Local(
    experience: io.flow.common.v0.models.ExperienceSummary,
    prices: Seq[io.flow.catalog.v0.models.LocalizedPrice],
    rates: Seq[io.flow.currency.v0.models.Rate],
    @deprecated("This field is deprecated - you will see an empty array in the response") spotRates: Seq[_root_.play.api.libs.json.JsObject],
    status: io.flow.catalog.v0.models.SubcatalogItemStatus = io.flow.catalog.v0.models.SubcatalogItemStatus.Included,
    attributes: _root_.scala.Option[Map[String, String]] = None,
    priceAttributes: _root_.scala.Option[Map[String, io.flow.common.v0.models.PriceWithBase]] = None
  )

  final case class LocalizedAdjustment(
    currency: String,
    amount: Double,
    label: String,
    base: io.flow.common.v0.models.Price,
    reason: io.flow.catalog.v0.models.AdjustmentReason
  )

  /**
   * @param adjustment An adjustment may need to be applied to VAT at the order level if the de minimis
   *        value is met; if so, its value is stored here.
   */
  final case class LocalizedItemDuty(
    currency: String,
    amount: Double,
    label: String,
    base: io.flow.common.v0.models.Price,
    adjustment: _root_.scala.Option[io.flow.catalog.v0.models.LocalizedAdjustment] = None
  ) extends LocalizedPrice

  /**
   * @param includes Describes which levies are included in the price, if any.
   */
  final case class LocalizedItemPrice(
    currency: String,
    amount: Double,
    label: String,
    base: io.flow.common.v0.models.Price,
    includes: _root_.scala.Option[io.flow.common.v0.models.IncludedLevies] = None
  ) extends LocalizedPrice

  /**
   * @param name The specific name of the tax in the local region.
   * @param adjustment An adjustment may need to be applied to VAT at the order level if the de minimis
   *        value is met; if so, its value is stored here.
   */
  final case class LocalizedItemVat(
    currency: String,
    amount: Double,
    label: String,
    base: io.flow.common.v0.models.Price,
    name: String,
    adjustment: _root_.scala.Option[io.flow.catalog.v0.models.LocalizedAdjustment] = None
  ) extends LocalizedPrice

  final case class LocalizedTotal(
    currency: String,
    amount: Double,
    label: String,
    base: io.flow.common.v0.models.Price
  ) extends LocalizedPrice

  /**
   * Flags to indicate whether a feature is enabled/disabled on a particular model
   * (e.g. show/do not show attribute as a column in harmonization table view of
   * items)
   * 
   * @param required If true, when you create or update items in Flow, we will validate that data
   *        presented contains an attribute with this key.
   * @param showInCatalog Flag indicating that a feature is applicable to catalog and can be used in
   *        Console
   * @param showInHarmonization Flag indicating that a feature is applicable to harmoniztion and can be used in
   *        Console
   */
  final case class Options(
    required: Boolean = false,
    showInCatalog: Boolean = false,
    showInHarmonization: Boolean = false
  )

  /**
   * A configuration with custom query to select a subset of master catalog items for
   * a localized experience
   */
  final case class Subcatalog(
    id: String,
    catalog: io.flow.catalog.v0.models.Catalog,
    settings: io.flow.catalog.v0.models.SubcatalogSettings
  ) extends ExpandableSubcatalog

  final case class SubcatalogForm(
    settings: _root_.scala.Option[io.flow.catalog.v0.models.SubcatalogSettingsForm] = None
  )

  /**
   * Represents information specific to an item in a given subcatalog
   */
  final case class SubcatalogItem(
    id: String,
    item: io.flow.catalog.v0.models.Item,
    status: io.flow.catalog.v0.models.SubcatalogItemStatus
  )

  final case class SubcatalogItemVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    subcatalogItem: io.flow.catalog.v0.models.SubcatalogItem
  )

  /**
   * Represents a typed query to indicate which items to include or exclude in a
   * subcatalog
   */
  final case class SubcatalogQuery(
    id: String,
    q: String,
    `type`: io.flow.catalog.v0.models.QueryType
  )

  /**
   * Defines a query specifying items to be included or excluded in a subcatalog
   * 
   * @param q Query string used to search for items
   */
  final case class SubcatalogQueryForm(
    q: String,
    `type`: io.flow.catalog.v0.models.QueryType
  )

  /**
   * Indicates valid and invalid queries
   */
  final case class SubcatalogQueryValidation(
    valid: Seq[String],
    invalid: Seq[String]
  )

  final case class SubcatalogReference(
    id: String
  ) extends ExpandableSubcatalog

  final case class SubcatalogSettings(
    updatePolicy: io.flow.catalog.v0.models.UpdatePolicy = io.flow.catalog.v0.models.UpdatePolicy.Auto
  )

  final case class SubcatalogSettingsForm(
    updatePolicy: _root_.scala.Option[io.flow.catalog.v0.models.UpdatePolicy] = None
  )

  /**
   * Statistics related to the items in this subcatalog, including item count, number
   * of distinct categories, etc.
   * 
   * @param excluded Number of items that are currently excluded in this subcatalog
   * @param included Total number of catalog items available from master catalog
   * @param restricted Number of items that are currently restricted in this subcatalog
   * @param queue Number of items that are currently queued to be added or updated to this
   *        subcatalog
   * @param catalog The parent catalog's statistics. Provided here to make summary data easy to
   *        compute (e.g. what % of items are in this subcatalog)
   */
  final case class SubcatalogStatistics(
    excluded: io.flow.catalog.v0.models.ItemStatistics,
    included: io.flow.catalog.v0.models.ItemStatistics,
    restricted: io.flow.catalog.v0.models.ItemStatistics,
    queue: io.flow.catalog.v0.models.ItemStatistics,
    catalog: io.flow.catalog.v0.models.CatalogStatistics
  )

  final case class SubcatalogVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    subcatalog: io.flow.catalog.v0.models.Subcatalog
  )

  /**
   * @param key Unique client-provided identifier indicating uniqueness of the targeting
   *        request. Follows the convention: [service]-[model]-[id]. For example:
   *        ratecard-dimension-estimate-dst-8eec70ab1f2740e0b46c7c8867cd8e07
   * @param queries Tuples of valid queries on a catalog and their corresponding output object in
   *        the client service
   */
  final case class Targeting(
    id: String,
    key: String,
    queries: Seq[io.flow.catalog.v0.models.TargetingQuery],
    catalog: io.flow.catalog.v0.models.CatalogReference,
    subcatalog: _root_.scala.Option[io.flow.catalog.v0.models.SubcatalogReference] = None
  )

  /**
   * @param key Unique client-provided identifier indicating uniqueness of the targeting
   *        request. Follows the convention: [service]-[model]-[id]. For example:
   *        ratecard-dimension-estimate-dst-8eec70ab1f2740e0b46c7c8867cd8e07
   * @param queries Tuples of valid queries on a catalog and their corresponding output object in
   *        the client service
   * @param subcatalogId If a targeting is only for a specific subcatalog, then this needs to be provided
   */
  final case class TargetingForm(
    key: String,
    queries: Seq[io.flow.catalog.v0.models.TargetingQueryForm],
    subcatalogId: _root_.scala.Option[String] = None
  )

  /**
   * Represents catalog items where a targeting query is applicable
   */
  final case class TargetingItem(
    id: String,
    targeting: io.flow.catalog.v0.models.TargetingSummary,
    itemNumber: String,
    query: io.flow.catalog.v0.models.TargetingQuery
  )

  /**
   * @param q Valid query on the organization's catalog items
   * @param outcomeId ID of corresponding outcome object in client service (e.g. item margin,
   *        dimension estimate, etc)
   */
  final case class TargetingQuery(
    id: String,
    q: String,
    outcomeId: String,
    position: Long
  )

  /**
   * @param q Valid query on the organization's catalog items
   * @param outcomeId ID of corresponding outcome object in client service (e.g. item margin,
   *        dimension estimate, etc)
   */
  final case class TargetingQueryForm(
    q: String,
    outcomeId: String
  )

  final case class TargetingSummary(
    id: String,
    key: String,
    catalog: io.flow.catalog.v0.models.CatalogReference,
    subcatalog: _root_.scala.Option[io.flow.catalog.v0.models.SubcatalogReference] = None
  )

  final case class TargetingVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    targeting: io.flow.catalog.v0.models.Targeting
  )

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union ExpandableSubcatalog, it will need to be handled in the client
   * code. This implementation will deserialize these future types as an instance of
   * this class.
   * 
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  final case class ExpandableSubcatalogUndefinedType(
    description: String
  ) extends ExpandableSubcatalog

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union LocalizedPrice, it will need to be handled in the client code. This
   * implementation will deserialize these future types as an instance of this class.
   * 
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  final case class LocalizedPriceUndefinedType(
    description: String
  ) extends LocalizedPrice

  /**
   * The key of each possible adjustment is defined here.
   */
  sealed trait AdjustmentReasonKey extends _root_.scala.Product with _root_.scala.Serializable

  object AdjustmentReasonKey {

    /**
     * If the duty de minimis value has not been met, an adjustment may be made to
     * offset any previously calculated duty.
     */
    case object DutyDeminimis extends AdjustmentReasonKey { override def toString = "duty_deminimis" }
    /**
     * If the VAT de minimis value has not been met, an adjustment may be made to
     * offset any previously calculated VAT.
     */
    case object VatDeminimis extends AdjustmentReasonKey { override def toString = "vat_deminimis" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends AdjustmentReasonKey

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[AdjustmentReasonKey] = scala.List(DutyDeminimis, VatDeminimis)

    private[this]
    val byName: Map[String, AdjustmentReasonKey] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): AdjustmentReasonKey = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[AdjustmentReasonKey] = byName.get(value.toLowerCase)

  }

  /**
   * Used to tag attributes as having a specific meaning that can affect processing.
   * For example, if you have an attribute called "brandname", and assign it the
   * "brand" intent, the value of the "brandname" attribute will be used where a
   * brand name is needed. Note that an intent can be assigned to any amount of
   * attributes of an item.
   */
  sealed trait AttributeIntent extends _root_.scala.Product with _root_.scala.Serializable

  object AttributeIntent {

    /**
     * A brand name of the item (for retailers that sell multiple brands)
     */
    case object Brand extends AttributeIntent { override def toString = "brand" }
    /**
     * The color of the item
     */
    case object Color extends AttributeIntent { override def toString = "color" }
    /**
     * A space separated list of the countries of origin for this item
     */
    case object CountriesOfOrigin extends AttributeIntent { override def toString = "countries_of_origin" }
    /**
     * An identifier used to group items that are variations of the same product, such
     * as different sizes or colors of the same shirt
     */
    case object ProductId extends AttributeIntent { override def toString = "product_id" }
    /**
     * Identifies whether the item is a physical or digital good
     */
    case object FulfillmentMethod extends AttributeIntent { override def toString = "fulfillment_method" }
    /**
     * Identifies whether this item may contain hazardous materials
     */
    case object Hazardous extends AttributeIntent { override def toString = "hazardous" }
    /**
     * A price for the item in the organization's base currency (will be localized
     * based on each Experience's pricing policy)
     */
    case object Price extends AttributeIntent { override def toString = "price" }
    /**
     * A size label of the item
     */
    case object Size extends AttributeIntent { override def toString = "size" }
    /**
     * An SKU for the item
     */
    case object Sku extends AttributeIntent { override def toString = "sku" }
    /**
     * Identifies whether taxes are applicable to an item
     */
    case object Taxability extends AttributeIntent { override def toString = "taxability" }
    /**
     * A URL of the product detail page of the item
     */
    case object ConsumerUrl extends AttributeIntent { override def toString = "consumer_url" }
    /**
     * The Global Trade Item Number of this item.
     */
    case object Gtin extends AttributeIntent { override def toString = "gtin" }
    /**
     * The Manufacturer Part Number of this item.
     */
    case object Mpn extends AttributeIntent { override def toString = "mpn" }
    /**
     * A space separated list of the regions (as defined in
     * https://api.flow.io/reference/regions) where the item must be excluded.
     */
    case object ExcludedRegions extends AttributeIntent { override def toString = "excluded_regions" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends AttributeIntent

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[AttributeIntent] = scala.List(Brand, Color, CountriesOfOrigin, ProductId, FulfillmentMethod, Hazardous, Price, Size, Sku, Taxability, ConsumerUrl, Gtin, Mpn, ExcludedRegions)

    private[this]
    val byName: Map[String, AttributeIntent] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): AttributeIntent = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[AttributeIntent] = byName.get(value.toLowerCase)

  }

  /**
   * Used to indicate an item's fulfillment method type.
   */
  sealed trait FulfillmentMethodType extends _root_.scala.Product with _root_.scala.Serializable

  object FulfillmentMethodType {

    /**
     * Indicates how an item will be shipped or fulfilled.  Acceptable values are
     * defined by the 'fulfillment_method_value' enum.
     */
    case object FulfillmentMethod extends FulfillmentMethodType { override def toString = "fulfillment_method" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends FulfillmentMethodType

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[FulfillmentMethodType] = scala.List(FulfillmentMethod)

    private[this]
    val byName: Map[String, FulfillmentMethodType] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): FulfillmentMethodType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[FulfillmentMethodType] = byName.get(value.toLowerCase)

  }

  /**
   * Used to indicate an item's fulfillment method values.
   */
  sealed trait FulfillmentMethodValue extends _root_.scala.Product with _root_.scala.Serializable

  object FulfillmentMethodValue {

    /**
     * Indicates item will be fulfilled digitally and no shipment is required (e.g.
     * Gift Card).
     */
    case object Digital extends FulfillmentMethodValue { override def toString = "digital" }
    /**
     * Indicates item will be shipped in a physical package.
     */
    case object Physical extends FulfillmentMethodValue { override def toString = "physical" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends FulfillmentMethodValue

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[FulfillmentMethodValue] = scala.List(Digital, Physical)

    private[this]
    val byName: Map[String, FulfillmentMethodValue] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): FulfillmentMethodValue = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[FulfillmentMethodValue] = byName.get(value.toLowerCase)

  }

  sealed trait ImageTag extends _root_.scala.Product with _root_.scala.Serializable

  object ImageTag {

    /**
     * Thumbnail images identify the image to use when displaying products in the Flow
     * Console.
     */
    case object Thumbnail extends ImageTag { override def toString = "thumbnail" }
    /**
     * Checkout images identify the item image to use when displaying the item in the
     * context of a consumer checkout (e.g. cart, checkout page).
     */
    case object Checkout extends ImageTag { override def toString = "checkout" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends ImageTag

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[ImageTag] = scala.List(Thumbnail, Checkout)

    private[this]
    val byName: Map[String, ImageTag] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ImageTag = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ImageTag] = byName.get(value.toLowerCase)

  }

  /**
   * Type to indicate whether query is an inclusion or exclusion
   */
  sealed trait QueryType extends _root_.scala.Product with _root_.scala.Serializable

  object QueryType {

    /**
     * Exclude items satisfied by the associated query
     */
    case object Exclusion extends QueryType { override def toString = "exclusion" }
    /**
     * Include items satisfied by the associated query
     */
    case object Inclusion extends QueryType { override def toString = "inclusion" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends QueryType

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[QueryType] = scala.List(Exclusion, Inclusion)

    private[this]
    val byName: Map[String, QueryType] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): QueryType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[QueryType] = byName.get(value.toLowerCase)

  }

  /**
   * Status indicating availability of a subcatalog item in an experience.
   */
  sealed trait SubcatalogItemStatus extends _root_.scala.Product with _root_.scala.Serializable

  object SubcatalogItemStatus {

    /**
     * The user has chosen to exclude the item from the associated subcatalog.
     */
    case object Excluded extends SubcatalogItemStatus { override def toString = "excluded" }
    /**
     * The item is included in the associated subcatalog.
     */
    case object Included extends SubcatalogItemStatus { override def toString = "included" }
    /**
     * Item is not allowed to be sold in the market associated with the given
     * subcatalog.
     */
    case object Restricted extends SubcatalogItemStatus { override def toString = "restricted" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends SubcatalogItemStatus

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[SubcatalogItemStatus] = scala.List(Excluded, Included, Restricted)

    private[this]
    val byName: Map[String, SubcatalogItemStatus] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): SubcatalogItemStatus = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[SubcatalogItemStatus] = byName.get(value.toLowerCase)

  }

  sealed trait TaxabilityType extends _root_.scala.Product with _root_.scala.Serializable

  object TaxabilityType {

    /**
     * Rule indicating how taxes should be applied.  Acceptable values are defined by
     * the 'taxability_value' enum.
     */
    case object TaxRule extends TaxabilityType { override def toString = "tax_rule" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends TaxabilityType

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[TaxabilityType] = scala.List(TaxRule)

    private[this]
    val byName: Map[String, TaxabilityType] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): TaxabilityType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[TaxabilityType] = byName.get(value.toLowerCase)

  }

  /**
   * Used to indicate an item's taxability.
   */
  sealed trait TaxabilityValue extends _root_.scala.Product with _root_.scala.Serializable

  object TaxabilityValue {

    /**
     * An item with this value is exempt from being taxed.
     */
    case object Exempt extends TaxabilityValue { override def toString = "exempt" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends TaxabilityValue

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[TaxabilityValue] = scala.List(Exempt)

    private[this]
    val byName: Map[String, TaxabilityValue] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): TaxabilityValue = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[TaxabilityValue] = byName.get(value.toLowerCase)

  }

  sealed trait UpdatePolicy extends _root_.scala.Product with _root_.scala.Serializable

  object UpdatePolicy {

    case object Auto extends UpdatePolicy { override def toString = "auto" }
    /**
     * Queue item update for approval.
     */
    case object Queue extends UpdatePolicy { override def toString = "queue" }
    case object Discard extends UpdatePolicy { override def toString = "discard" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends UpdatePolicy

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[UpdatePolicy] = scala.List(Auto, Queue, Discard)

    private[this]
    val byName: Map[String, UpdatePolicy] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): UpdatePolicy = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[UpdatePolicy] = byName.get(value.toLowerCase)

  }

}

package io.flow.catalog.v0.models {

  package object json {
    import play.api.libs.json.__
    import play.api.libs.json.JsString
    import play.api.libs.json.Writes
    import play.api.libs.functional.syntax._
    import io.flow.catalog.v0.models.json._
    import io.flow.common.v0.models.json._
    import io.flow.currency.v0.models.json._
    import io.flow.error.v0.models.json._
    import io.flow.organization.v0.models.json._
    import io.flow.permission.v0.models.json._
    import io.flow.price.v0.models.json._

    private[v0] implicit val jsonReadsUUID = __.read[String].map { str =>
      _root_.java.util.UUID.fromString(str)
    }

    private[v0] implicit val jsonWritesUUID = new Writes[_root_.java.util.UUID] {
      def writes(x: _root_.java.util.UUID) = JsString(x.toString)
    }

    private[v0] implicit val jsonReadsJodaDateTime = __.read[String].map { str =>
      _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseDateTime(str)
    }

    private[v0] implicit val jsonWritesJodaDateTime = new Writes[_root_.org.joda.time.DateTime] {
      def writes(x: _root_.org.joda.time.DateTime) = {
        JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(x))
      }
    }

    private[v0] implicit val jsonReadsJodaLocalDate = __.read[String].map { str =>
      _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseLocalDate(str)
    }

    private[v0] implicit val jsonWritesJodaLocalDate = new Writes[_root_.org.joda.time.LocalDate] {
      def writes(x: _root_.org.joda.time.LocalDate) = {
        JsString(_root_.org.joda.time.format.ISODateTimeFormat.date.print(x))
      }
    }

    implicit val jsonReadsCatalogAdjustmentReasonKey = new play.api.libs.json.Reads[io.flow.catalog.v0.models.AdjustmentReasonKey] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.catalog.v0.models.AdjustmentReasonKey] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.catalog.v0.models.AdjustmentReasonKey(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.catalog.v0.models.AdjustmentReasonKey(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesCatalogAdjustmentReasonKey(obj: io.flow.catalog.v0.models.AdjustmentReasonKey) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectAdjustmentReasonKey(obj: io.flow.catalog.v0.models.AdjustmentReasonKey) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesCatalogAdjustmentReasonKey: play.api.libs.json.Writes[AdjustmentReasonKey] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.AdjustmentReasonKey] {
        def writes(obj: io.flow.catalog.v0.models.AdjustmentReasonKey) = {
          jsonWritesCatalogAdjustmentReasonKey(obj)
        }
      }
    }

    implicit val jsonReadsCatalogAttributeIntent = new play.api.libs.json.Reads[io.flow.catalog.v0.models.AttributeIntent] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.catalog.v0.models.AttributeIntent] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.catalog.v0.models.AttributeIntent(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.catalog.v0.models.AttributeIntent(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesCatalogAttributeIntent(obj: io.flow.catalog.v0.models.AttributeIntent) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectAttributeIntent(obj: io.flow.catalog.v0.models.AttributeIntent) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesCatalogAttributeIntent: play.api.libs.json.Writes[AttributeIntent] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.AttributeIntent] {
        def writes(obj: io.flow.catalog.v0.models.AttributeIntent) = {
          jsonWritesCatalogAttributeIntent(obj)
        }
      }
    }

    implicit val jsonReadsCatalogFulfillmentMethodType = new play.api.libs.json.Reads[io.flow.catalog.v0.models.FulfillmentMethodType] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.catalog.v0.models.FulfillmentMethodType] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.catalog.v0.models.FulfillmentMethodType(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.catalog.v0.models.FulfillmentMethodType(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesCatalogFulfillmentMethodType(obj: io.flow.catalog.v0.models.FulfillmentMethodType) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectFulfillmentMethodType(obj: io.flow.catalog.v0.models.FulfillmentMethodType) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesCatalogFulfillmentMethodType: play.api.libs.json.Writes[FulfillmentMethodType] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.FulfillmentMethodType] {
        def writes(obj: io.flow.catalog.v0.models.FulfillmentMethodType) = {
          jsonWritesCatalogFulfillmentMethodType(obj)
        }
      }
    }

    implicit val jsonReadsCatalogFulfillmentMethodValue = new play.api.libs.json.Reads[io.flow.catalog.v0.models.FulfillmentMethodValue] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.catalog.v0.models.FulfillmentMethodValue] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.catalog.v0.models.FulfillmentMethodValue(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.catalog.v0.models.FulfillmentMethodValue(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesCatalogFulfillmentMethodValue(obj: io.flow.catalog.v0.models.FulfillmentMethodValue) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectFulfillmentMethodValue(obj: io.flow.catalog.v0.models.FulfillmentMethodValue) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesCatalogFulfillmentMethodValue: play.api.libs.json.Writes[FulfillmentMethodValue] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.FulfillmentMethodValue] {
        def writes(obj: io.flow.catalog.v0.models.FulfillmentMethodValue) = {
          jsonWritesCatalogFulfillmentMethodValue(obj)
        }
      }
    }

    implicit val jsonReadsCatalogImageTag = new play.api.libs.json.Reads[io.flow.catalog.v0.models.ImageTag] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.catalog.v0.models.ImageTag] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.catalog.v0.models.ImageTag(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.catalog.v0.models.ImageTag(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesCatalogImageTag(obj: io.flow.catalog.v0.models.ImageTag) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectImageTag(obj: io.flow.catalog.v0.models.ImageTag) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesCatalogImageTag: play.api.libs.json.Writes[ImageTag] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.ImageTag] {
        def writes(obj: io.flow.catalog.v0.models.ImageTag) = {
          jsonWritesCatalogImageTag(obj)
        }
      }
    }

    implicit val jsonReadsCatalogQueryType = new play.api.libs.json.Reads[io.flow.catalog.v0.models.QueryType] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.catalog.v0.models.QueryType] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.catalog.v0.models.QueryType(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.catalog.v0.models.QueryType(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesCatalogQueryType(obj: io.flow.catalog.v0.models.QueryType) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectQueryType(obj: io.flow.catalog.v0.models.QueryType) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesCatalogQueryType: play.api.libs.json.Writes[QueryType] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.QueryType] {
        def writes(obj: io.flow.catalog.v0.models.QueryType) = {
          jsonWritesCatalogQueryType(obj)
        }
      }
    }

    implicit val jsonReadsCatalogSubcatalogItemStatus = new play.api.libs.json.Reads[io.flow.catalog.v0.models.SubcatalogItemStatus] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.catalog.v0.models.SubcatalogItemStatus] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.catalog.v0.models.SubcatalogItemStatus(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.catalog.v0.models.SubcatalogItemStatus(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesCatalogSubcatalogItemStatus(obj: io.flow.catalog.v0.models.SubcatalogItemStatus) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectSubcatalogItemStatus(obj: io.flow.catalog.v0.models.SubcatalogItemStatus) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesCatalogSubcatalogItemStatus: play.api.libs.json.Writes[SubcatalogItemStatus] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.SubcatalogItemStatus] {
        def writes(obj: io.flow.catalog.v0.models.SubcatalogItemStatus) = {
          jsonWritesCatalogSubcatalogItemStatus(obj)
        }
      }
    }

    implicit val jsonReadsCatalogTaxabilityType = new play.api.libs.json.Reads[io.flow.catalog.v0.models.TaxabilityType] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.catalog.v0.models.TaxabilityType] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.catalog.v0.models.TaxabilityType(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.catalog.v0.models.TaxabilityType(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesCatalogTaxabilityType(obj: io.flow.catalog.v0.models.TaxabilityType) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectTaxabilityType(obj: io.flow.catalog.v0.models.TaxabilityType) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesCatalogTaxabilityType: play.api.libs.json.Writes[TaxabilityType] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.TaxabilityType] {
        def writes(obj: io.flow.catalog.v0.models.TaxabilityType) = {
          jsonWritesCatalogTaxabilityType(obj)
        }
      }
    }

    implicit val jsonReadsCatalogTaxabilityValue = new play.api.libs.json.Reads[io.flow.catalog.v0.models.TaxabilityValue] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.catalog.v0.models.TaxabilityValue] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.catalog.v0.models.TaxabilityValue(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.catalog.v0.models.TaxabilityValue(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesCatalogTaxabilityValue(obj: io.flow.catalog.v0.models.TaxabilityValue) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectTaxabilityValue(obj: io.flow.catalog.v0.models.TaxabilityValue) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesCatalogTaxabilityValue: play.api.libs.json.Writes[TaxabilityValue] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.TaxabilityValue] {
        def writes(obj: io.flow.catalog.v0.models.TaxabilityValue) = {
          jsonWritesCatalogTaxabilityValue(obj)
        }
      }
    }

    implicit val jsonReadsCatalogUpdatePolicy = new play.api.libs.json.Reads[io.flow.catalog.v0.models.UpdatePolicy] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.catalog.v0.models.UpdatePolicy] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.catalog.v0.models.UpdatePolicy(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.catalog.v0.models.UpdatePolicy(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesCatalogUpdatePolicy(obj: io.flow.catalog.v0.models.UpdatePolicy) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectUpdatePolicy(obj: io.flow.catalog.v0.models.UpdatePolicy) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesCatalogUpdatePolicy: play.api.libs.json.Writes[UpdatePolicy] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.UpdatePolicy] {
        def writes(obj: io.flow.catalog.v0.models.UpdatePolicy) = {
          jsonWritesCatalogUpdatePolicy(obj)
        }
      }
    }

    implicit def jsonReadsCatalogAdjustmentReason: play.api.libs.json.Reads[AdjustmentReason] = {
      for {
        key <- (__ \ "key").read[io.flow.catalog.v0.models.AdjustmentReasonKey]
        label <- (__ \ "label").read[String]
      } yield AdjustmentReason(key, label)
    }

    def jsObjectAdjustmentReason(obj: io.flow.catalog.v0.models.AdjustmentReason): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key.toString),
        "label" -> play.api.libs.json.JsString(obj.label)
      )
    }

    implicit def jsonWritesCatalogAdjustmentReason: play.api.libs.json.Writes[AdjustmentReason] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.AdjustmentReason] {
        def writes(obj: io.flow.catalog.v0.models.AdjustmentReason) = {
          jsObjectAdjustmentReason(obj)
        }
      }
    }

    implicit def jsonReadsCatalogAttribute: play.api.libs.json.Reads[Attribute] = {
      for {
        id <- (__ \ "id").read[String]
        key <- (__ \ "key").read[String]
        options <- (__ \ "options").read[io.flow.catalog.v0.models.Options]
        label <- (__ \ "label").readNullable[String]
        intent <- (__ \ "intent").readNullable[io.flow.catalog.v0.models.AttributeIntent]
        `type` <- (__ \ "type").readNullable[io.flow.common.v0.models.AttributeDataType]
        position <- (__ \ "position").readNullable[Long]
      } yield Attribute(id, key, options, label, intent, `type`, position)
    }

    def jsObjectAttribute(obj: io.flow.catalog.v0.models.Attribute): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "key" -> play.api.libs.json.JsString(obj.key),
        "options" -> jsObjectOptions(obj.options)
      ) ++ (obj.label match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("label" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.intent match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("intent" -> play.api.libs.json.JsString(x.toString))
      }) ++
      (obj.`type` match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("type" -> play.api.libs.json.JsString(x.toString))
      }) ++
      (obj.position match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("position" -> play.api.libs.json.JsNumber(x))
      })
    }

    implicit def jsonWritesCatalogAttribute: play.api.libs.json.Writes[Attribute] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.Attribute] {
        def writes(obj: io.flow.catalog.v0.models.Attribute) = {
          jsObjectAttribute(obj)
        }
      }
    }

    implicit def jsonReadsCatalogAttributeForm: play.api.libs.json.Reads[AttributeForm] = {
      for {
        key <- (__ \ "key").read[String]
        options <- (__ \ "options").read[io.flow.catalog.v0.models.Options]
        label <- (__ \ "label").readNullable[String]
        intent <- (__ \ "intent").readNullable[io.flow.catalog.v0.models.AttributeIntent]
        `type` <- (__ \ "type").readNullable[io.flow.common.v0.models.AttributeDataType]
        position <- (__ \ "position").readNullable[Long]
      } yield AttributeForm(key, options, label, intent, `type`, position)
    }

    def jsObjectAttributeForm(obj: io.flow.catalog.v0.models.AttributeForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key),
        "options" -> jsObjectOptions(obj.options)
      ) ++ (obj.label match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("label" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.intent match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("intent" -> play.api.libs.json.JsString(x.toString))
      }) ++
      (obj.`type` match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("type" -> play.api.libs.json.JsString(x.toString))
      }) ++
      (obj.position match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("position" -> play.api.libs.json.JsNumber(x))
      })
    }

    implicit def jsonWritesCatalogAttributeForm: play.api.libs.json.Writes[AttributeForm] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.AttributeForm] {
        def writes(obj: io.flow.catalog.v0.models.AttributeForm) = {
          jsObjectAttributeForm(obj)
        }
      }
    }

    implicit def jsonReadsCatalogAttributeVersion: play.api.libs.json.Reads[AttributeVersion] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        attribute <- (__ \ "attribute").read[io.flow.catalog.v0.models.Attribute]
      } yield AttributeVersion(id, timestamp, `type`, attribute)
    }

    def jsObjectAttributeVersion(obj: io.flow.catalog.v0.models.AttributeVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "attribute" -> jsObjectAttribute(obj.attribute)
      )
    }

    implicit def jsonWritesCatalogAttributeVersion: play.api.libs.json.Writes[AttributeVersion] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.AttributeVersion] {
        def writes(obj: io.flow.catalog.v0.models.AttributeVersion) = {
          jsObjectAttributeVersion(obj)
        }
      }
    }

    implicit def jsonReadsCatalogCatalog: play.api.libs.json.Reads[Catalog] = {
      (__ \ "id").read[String].map { x => new Catalog(id = x) }
    }

    def jsObjectCatalog(obj: io.flow.catalog.v0.models.Catalog): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id)
      )
    }

    implicit def jsonWritesCatalogCatalog: play.api.libs.json.Writes[Catalog] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.Catalog] {
        def writes(obj: io.flow.catalog.v0.models.Catalog) = {
          jsObjectCatalog(obj)
        }
      }
    }

    implicit def jsonReadsCatalogCatalogReference: play.api.libs.json.Reads[CatalogReference] = {
      (__ \ "id").read[String].map { x => new CatalogReference(id = x) }
    }

    def jsObjectCatalogReference(obj: io.flow.catalog.v0.models.CatalogReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id)
      )
    }

    implicit def jsonWritesCatalogCatalogReference: play.api.libs.json.Writes[CatalogReference] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.CatalogReference] {
        def writes(obj: io.flow.catalog.v0.models.CatalogReference) = {
          jsObjectCatalogReference(obj)
        }
      }
    }

    implicit def jsonReadsCatalogCatalogStatistics: play.api.libs.json.Reads[CatalogStatistics] = {
      for {
        items <- (__ \ "items").read[Long]
        categories <- (__ \ "categories").read[Long]
      } yield CatalogStatistics(items, categories)
    }

    def jsObjectCatalogStatistics(obj: io.flow.catalog.v0.models.CatalogStatistics): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "items" -> play.api.libs.json.JsNumber(obj.items),
        "categories" -> play.api.libs.json.JsNumber(obj.categories)
      )
    }

    implicit def jsonWritesCatalogCatalogStatistics: play.api.libs.json.Writes[CatalogStatistics] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.CatalogStatistics] {
        def writes(obj: io.flow.catalog.v0.models.CatalogStatistics) = {
          jsObjectCatalogStatistics(obj)
        }
      }
    }

    implicit def jsonReadsCatalogCatalogVersion: play.api.libs.json.Reads[CatalogVersion] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        catalog <- (__ \ "catalog").read[io.flow.catalog.v0.models.Catalog]
      } yield CatalogVersion(id, timestamp, `type`, catalog)
    }

    def jsObjectCatalogVersion(obj: io.flow.catalog.v0.models.CatalogVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "catalog" -> jsObjectCatalog(obj.catalog)
      )
    }

    implicit def jsonWritesCatalogCatalogVersion: play.api.libs.json.Writes[CatalogVersion] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.CatalogVersion] {
        def writes(obj: io.flow.catalog.v0.models.CatalogVersion) = {
          jsObjectCatalogVersion(obj)
        }
      }
    }

    implicit def jsonReadsCatalogFlowItemIndexMetadata: play.api.libs.json.Reads[FlowItemIndexMetadata] = {
      (__ \ "status").read[io.flow.catalog.v0.models.SubcatalogItemStatus].map { x => new FlowItemIndexMetadata(status = x) }
    }

    def jsObjectFlowItemIndexMetadata(obj: io.flow.catalog.v0.models.FlowItemIndexMetadata): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "status" -> play.api.libs.json.JsString(obj.status.toString)
      )
    }

    implicit def jsonWritesCatalogFlowItemIndexMetadata: play.api.libs.json.Writes[FlowItemIndexMetadata] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.FlowItemIndexMetadata] {
        def writes(obj: io.flow.catalog.v0.models.FlowItemIndexMetadata) = {
          jsObjectFlowItemIndexMetadata(obj)
        }
      }
    }

    implicit def jsonReadsCatalogImage: play.api.libs.json.Reads[Image] = {
      for {
        url <- (__ \ "url").read[String]
        tags <- (__ \ "tags").read[Seq[io.flow.catalog.v0.models.ImageTag]]
      } yield Image(url, tags)
    }

    def jsObjectImage(obj: io.flow.catalog.v0.models.Image): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "url" -> play.api.libs.json.JsString(obj.url),
        "tags" -> play.api.libs.json.Json.toJson(obj.tags)
      )
    }

    implicit def jsonWritesCatalogImage: play.api.libs.json.Writes[Image] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.Image] {
        def writes(obj: io.flow.catalog.v0.models.Image) = {
          jsObjectImage(obj)
        }
      }
    }

    implicit def jsonReadsCatalogImageForm: play.api.libs.json.Reads[ImageForm] = {
      for {
        url <- (__ \ "url").read[String]
        tags <- (__ \ "tags").readNullable[Seq[io.flow.catalog.v0.models.ImageTag]]
      } yield ImageForm(url, tags)
    }

    def jsObjectImageForm(obj: io.flow.catalog.v0.models.ImageForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "url" -> play.api.libs.json.JsString(obj.url)
      ) ++ (obj.tags match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("tags" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesCatalogImageForm: play.api.libs.json.Writes[ImageForm] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.ImageForm] {
        def writes(obj: io.flow.catalog.v0.models.ImageForm) = {
          jsObjectImageForm(obj)
        }
      }
    }

    implicit def jsonReadsCatalogItem: play.api.libs.json.Reads[Item] = {
      for {
        id <- (__ \ "id").read[String]
        number <- (__ \ "number").read[String]
        locale <- (__ \ "locale").read[String]
        name <- (__ \ "name").read[String]
        price <- (__ \ "price").read[io.flow.common.v0.models.Price]
        categories <- (__ \ "categories").read[Seq[String]]
        description <- (__ \ "description").readNullable[String]
        attributes <- (__ \ "attributes").read[Map[String, String]]
        dimensions <- (__ \ "dimensions").read[io.flow.common.v0.models.Dimensions]
        images <- (__ \ "images").read[Seq[io.flow.catalog.v0.models.Image]]
        local <- (__ \ "local").readNullable[io.flow.catalog.v0.models.Local]
      } yield Item(id, number, locale, name, price, categories, description, attributes, dimensions, images, local)
    }

    def jsObjectItem(obj: io.flow.catalog.v0.models.Item): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "number" -> play.api.libs.json.JsString(obj.number),
        "locale" -> play.api.libs.json.JsString(obj.locale),
        "name" -> play.api.libs.json.JsString(obj.name),
        "price" -> io.flow.common.v0.models.json.jsObjectPrice(obj.price),
        "categories" -> play.api.libs.json.Json.toJson(obj.categories),
        "attributes" -> play.api.libs.json.Json.toJson(obj.attributes),
        "dimensions" -> io.flow.common.v0.models.json.jsObjectDimensions(obj.dimensions),
        "images" -> play.api.libs.json.Json.toJson(obj.images)
      ) ++ (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.local match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("local" -> jsObjectLocal(x))
      })
    }

    implicit def jsonWritesCatalogItem: play.api.libs.json.Writes[Item] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.Item] {
        def writes(obj: io.flow.catalog.v0.models.Item) = {
          jsObjectItem(obj)
        }
      }
    }

    implicit def jsonReadsCatalogItemAttributesPatchForm: play.api.libs.json.Reads[ItemAttributesPatchForm] = {
      (__ \ "attributes").read[Map[String, String]].map { x => new ItemAttributesPatchForm(attributes = x) }
    }

    def jsObjectItemAttributesPatchForm(obj: io.flow.catalog.v0.models.ItemAttributesPatchForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "attributes" -> play.api.libs.json.Json.toJson(obj.attributes)
      )
    }

    implicit def jsonWritesCatalogItemAttributesPatchForm: play.api.libs.json.Writes[ItemAttributesPatchForm] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.ItemAttributesPatchForm] {
        def writes(obj: io.flow.catalog.v0.models.ItemAttributesPatchForm) = {
          jsObjectItemAttributesPatchForm(obj)
        }
      }
    }

    implicit def jsonReadsCatalogItemForm: play.api.libs.json.Reads[ItemForm] = {
      for {
        number <- (__ \ "number").read[String]
        locale <- (__ \ "locale").read[String]
        name <- (__ \ "name").read[String]
        currency <- (__ \ "currency").read[String]
        price <- (__ \ "price").read[Double]
        categories <- (__ \ "categories").readNullable[Seq[String]]
        description <- (__ \ "description").readNullable[String]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
        dimensions <- (__ \ "dimensions").readNullable[io.flow.common.v0.models.Dimensions]
        images <- (__ \ "images").readNullable[Seq[io.flow.catalog.v0.models.ImageForm]]
      } yield ItemForm(number, locale, name, currency, price, categories, description, attributes, dimensions, images)
    }

    def jsObjectItemForm(obj: io.flow.catalog.v0.models.ItemForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "number" -> play.api.libs.json.JsString(obj.number),
        "locale" -> play.api.libs.json.JsString(obj.locale),
        "name" -> play.api.libs.json.JsString(obj.name),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "price" -> play.api.libs.json.JsNumber(obj.price)
      ) ++ (obj.categories match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("categories" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.dimensions match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("dimensions" -> io.flow.common.v0.models.json.jsObjectDimensions(x))
      }) ++
      (obj.images match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("images" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesCatalogItemForm: play.api.libs.json.Writes[ItemForm] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.ItemForm] {
        def writes(obj: io.flow.catalog.v0.models.ItemForm) = {
          jsObjectItemForm(obj)
        }
      }
    }

    implicit def jsonReadsCatalogItemFormOverlay: play.api.libs.json.Reads[ItemFormOverlay] = {
      for {
        id <- (__ \ "id").read[String]
        number <- (__ \ "number").read[String]
        position <- (__ \ "position").read[Long]
        price <- (__ \ "price").readNullable[io.flow.common.v0.models.Price]
        categories <- (__ \ "categories").readNullable[Seq[String]]
        description <- (__ \ "description").readNullable[String]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
        dimensions <- (__ \ "dimensions").readNullable[io.flow.common.v0.models.Dimensions]
        images <- (__ \ "images").readNullable[Seq[io.flow.catalog.v0.models.ImageForm]]
      } yield ItemFormOverlay(id, number, position, price, categories, description, attributes, dimensions, images)
    }

    def jsObjectItemFormOverlay(obj: io.flow.catalog.v0.models.ItemFormOverlay): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "number" -> play.api.libs.json.JsString(obj.number),
        "position" -> play.api.libs.json.JsNumber(obj.position)
      ) ++ (obj.price match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("price" -> io.flow.common.v0.models.json.jsObjectPrice(x))
      }) ++
      (obj.categories match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("categories" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.dimensions match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("dimensions" -> io.flow.common.v0.models.json.jsObjectDimensions(x))
      }) ++
      (obj.images match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("images" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesCatalogItemFormOverlay: play.api.libs.json.Writes[ItemFormOverlay] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.ItemFormOverlay] {
        def writes(obj: io.flow.catalog.v0.models.ItemFormOverlay) = {
          jsObjectItemFormOverlay(obj)
        }
      }
    }

    implicit def jsonReadsCatalogItemFormOverlayForm: play.api.libs.json.Reads[ItemFormOverlayForm] = {
      for {
        number <- (__ \ "number").read[String]
        price <- (__ \ "price").readNullable[Double]
        currency <- (__ \ "currency").readNullable[String]
        position <- (__ \ "position").readNullable[Long]
        categories <- (__ \ "categories").readNullable[Seq[String]]
        description <- (__ \ "description").readNullable[String]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
        dimensions <- (__ \ "dimensions").readNullable[io.flow.common.v0.models.Dimensions]
        images <- (__ \ "images").readNullable[Seq[io.flow.catalog.v0.models.ImageForm]]
      } yield ItemFormOverlayForm(number, price, currency, position, categories, description, attributes, dimensions, images)
    }

    def jsObjectItemFormOverlayForm(obj: io.flow.catalog.v0.models.ItemFormOverlayForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "number" -> play.api.libs.json.JsString(obj.number)
      ) ++ (obj.price match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("price" -> play.api.libs.json.JsNumber(x))
      }) ++
      (obj.currency match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("currency" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.position match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("position" -> play.api.libs.json.JsNumber(x))
      }) ++
      (obj.categories match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("categories" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.dimensions match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("dimensions" -> io.flow.common.v0.models.json.jsObjectDimensions(x))
      }) ++
      (obj.images match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("images" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesCatalogItemFormOverlayForm: play.api.libs.json.Writes[ItemFormOverlayForm] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.ItemFormOverlayForm] {
        def writes(obj: io.flow.catalog.v0.models.ItemFormOverlayForm) = {
          jsObjectItemFormOverlayForm(obj)
        }
      }
    }

    implicit def jsonReadsCatalogItemPriceUpdatePutForm: play.api.libs.json.Reads[ItemPriceUpdatePutForm] = {
      for {
        currency <- (__ \ "currency").read[String]
        price <- (__ \ "price").read[BigDecimal]
        attributes <- (__ \ "attributes").read[Map[String, String]]
      } yield ItemPriceUpdatePutForm(currency, price, attributes)
    }

    def jsObjectItemPriceUpdatePutForm(obj: io.flow.catalog.v0.models.ItemPriceUpdatePutForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "price" -> play.api.libs.json.JsNumber(obj.price),
        "attributes" -> play.api.libs.json.Json.toJson(obj.attributes)
      )
    }

    implicit def jsonWritesCatalogItemPriceUpdatePutForm: play.api.libs.json.Writes[ItemPriceUpdatePutForm] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.ItemPriceUpdatePutForm] {
        def writes(obj: io.flow.catalog.v0.models.ItemPriceUpdatePutForm) = {
          jsObjectItemPriceUpdatePutForm(obj)
        }
      }
    }

    implicit def jsonReadsCatalogItemStatistics: play.api.libs.json.Reads[ItemStatistics] = {
      for {
        items <- (__ \ "items").read[Long]
        categories <- (__ \ "categories").read[Long]
      } yield ItemStatistics(items, categories)
    }

    def jsObjectItemStatistics(obj: io.flow.catalog.v0.models.ItemStatistics): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "items" -> play.api.libs.json.JsNumber(obj.items),
        "categories" -> play.api.libs.json.JsNumber(obj.categories)
      )
    }

    implicit def jsonWritesCatalogItemStatistics: play.api.libs.json.Writes[ItemStatistics] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.ItemStatistics] {
        def writes(obj: io.flow.catalog.v0.models.ItemStatistics) = {
          jsObjectItemStatistics(obj)
        }
      }
    }

    implicit def jsonReadsCatalogItemVersion: play.api.libs.json.Reads[ItemVersion] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        item <- (__ \ "item").read[io.flow.catalog.v0.models.Item]
      } yield ItemVersion(id, timestamp, `type`, item)
    }

    def jsObjectItemVersion(obj: io.flow.catalog.v0.models.ItemVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "item" -> jsObjectItem(obj.item)
      )
    }

    implicit def jsonWritesCatalogItemVersion: play.api.libs.json.Writes[ItemVersion] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.ItemVersion] {
        def writes(obj: io.flow.catalog.v0.models.ItemVersion) = {
          jsObjectItemVersion(obj)
        }
      }
    }

    implicit def jsonReadsCatalogLocal: play.api.libs.json.Reads[Local] = {
      for {
        experience <- (__ \ "experience").read[io.flow.common.v0.models.ExperienceSummary]
        prices <- (__ \ "prices").read[Seq[io.flow.catalog.v0.models.LocalizedPrice]]
        rates <- (__ \ "rates").read[Seq[io.flow.currency.v0.models.Rate]]
        spotRates <- (__ \ "spot_rates").read[Seq[_root_.play.api.libs.json.JsObject]]
        status <- (__ \ "status").read[io.flow.catalog.v0.models.SubcatalogItemStatus]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
        priceAttributes <- (__ \ "price_attributes").readNullable[Map[String, io.flow.common.v0.models.PriceWithBase]]
      } yield Local(experience, prices, rates, spotRates, status, attributes, priceAttributes)
    }

    def jsObjectLocal(obj: io.flow.catalog.v0.models.Local): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "experience" -> io.flow.common.v0.models.json.jsObjectExperienceSummary(obj.experience),
        "prices" -> play.api.libs.json.Json.toJson(obj.prices),
        "rates" -> play.api.libs.json.Json.toJson(obj.rates),
        "spot_rates" -> play.api.libs.json.Json.toJson(obj.spotRates),
        "status" -> play.api.libs.json.JsString(obj.status.toString)
      ) ++ (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.priceAttributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("price_attributes" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesCatalogLocal: play.api.libs.json.Writes[Local] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.Local] {
        def writes(obj: io.flow.catalog.v0.models.Local) = {
          jsObjectLocal(obj)
        }
      }
    }

    implicit def jsonReadsCatalogLocalizedAdjustment: play.api.libs.json.Reads[LocalizedAdjustment] = {
      for {
        currency <- (__ \ "currency").read[String]
        amount <- (__ \ "amount").read[Double]
        label <- (__ \ "label").read[String]
        base <- (__ \ "base").read[io.flow.common.v0.models.Price]
        reason <- (__ \ "reason").read[io.flow.catalog.v0.models.AdjustmentReason]
      } yield LocalizedAdjustment(currency, amount, label, base, reason)
    }

    def jsObjectLocalizedAdjustment(obj: io.flow.catalog.v0.models.LocalizedAdjustment): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "label" -> play.api.libs.json.JsString(obj.label),
        "base" -> io.flow.common.v0.models.json.jsObjectPrice(obj.base),
        "reason" -> jsObjectAdjustmentReason(obj.reason)
      )
    }

    implicit def jsonWritesCatalogLocalizedAdjustment: play.api.libs.json.Writes[LocalizedAdjustment] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.LocalizedAdjustment] {
        def writes(obj: io.flow.catalog.v0.models.LocalizedAdjustment) = {
          jsObjectLocalizedAdjustment(obj)
        }
      }
    }

    implicit def jsonReadsCatalogLocalizedItemDuty: play.api.libs.json.Reads[LocalizedItemDuty] = {
      for {
        currency <- (__ \ "currency").read[String]
        amount <- (__ \ "amount").read[Double]
        label <- (__ \ "label").read[String]
        base <- (__ \ "base").read[io.flow.common.v0.models.Price]
        adjustment <- (__ \ "adjustment").readNullable[io.flow.catalog.v0.models.LocalizedAdjustment]
      } yield LocalizedItemDuty(currency, amount, label, base, adjustment)
    }

    def jsObjectLocalizedItemDuty(obj: io.flow.catalog.v0.models.LocalizedItemDuty): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "label" -> play.api.libs.json.JsString(obj.label),
        "base" -> io.flow.common.v0.models.json.jsObjectPrice(obj.base)
      ) ++ (obj.adjustment match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("adjustment" -> jsObjectLocalizedAdjustment(x))
      })
    }

    implicit def jsonReadsCatalogLocalizedItemPrice: play.api.libs.json.Reads[LocalizedItemPrice] = {
      for {
        currency <- (__ \ "currency").read[String]
        amount <- (__ \ "amount").read[Double]
        label <- (__ \ "label").read[String]
        base <- (__ \ "base").read[io.flow.common.v0.models.Price]
        includes <- (__ \ "includes").readNullable[io.flow.common.v0.models.IncludedLevies]
      } yield LocalizedItemPrice(currency, amount, label, base, includes)
    }

    def jsObjectLocalizedItemPrice(obj: io.flow.catalog.v0.models.LocalizedItemPrice): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "label" -> play.api.libs.json.JsString(obj.label),
        "base" -> io.flow.common.v0.models.json.jsObjectPrice(obj.base)
      ) ++ (obj.includes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("includes" -> io.flow.common.v0.models.json.jsObjectIncludedLevies(x))
      })
    }

    implicit def jsonReadsCatalogLocalizedItemVat: play.api.libs.json.Reads[LocalizedItemVat] = {
      for {
        currency <- (__ \ "currency").read[String]
        amount <- (__ \ "amount").read[Double]
        label <- (__ \ "label").read[String]
        base <- (__ \ "base").read[io.flow.common.v0.models.Price]
        name <- (__ \ "name").read[String]
        adjustment <- (__ \ "adjustment").readNullable[io.flow.catalog.v0.models.LocalizedAdjustment]
      } yield LocalizedItemVat(currency, amount, label, base, name, adjustment)
    }

    def jsObjectLocalizedItemVat(obj: io.flow.catalog.v0.models.LocalizedItemVat): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "label" -> play.api.libs.json.JsString(obj.label),
        "base" -> io.flow.common.v0.models.json.jsObjectPrice(obj.base),
        "name" -> play.api.libs.json.JsString(obj.name)
      ) ++ (obj.adjustment match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("adjustment" -> jsObjectLocalizedAdjustment(x))
      })
    }

    implicit def jsonReadsCatalogLocalizedTotal: play.api.libs.json.Reads[LocalizedTotal] = {
      for {
        currency <- (__ \ "currency").read[String]
        amount <- (__ \ "amount").read[Double]
        label <- (__ \ "label").read[String]
        base <- (__ \ "base").read[io.flow.common.v0.models.Price]
      } yield LocalizedTotal(currency, amount, label, base)
    }

    def jsObjectLocalizedTotal(obj: io.flow.catalog.v0.models.LocalizedTotal): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "label" -> play.api.libs.json.JsString(obj.label),
        "base" -> io.flow.common.v0.models.json.jsObjectPrice(obj.base)
      )
    }

    implicit def jsonReadsCatalogOptions: play.api.libs.json.Reads[Options] = {
      for {
        required <- (__ \ "required").read[Boolean]
        showInCatalog <- (__ \ "show_in_catalog").read[Boolean]
        showInHarmonization <- (__ \ "show_in_harmonization").read[Boolean]
      } yield Options(required, showInCatalog, showInHarmonization)
    }

    def jsObjectOptions(obj: io.flow.catalog.v0.models.Options): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "required" -> play.api.libs.json.JsBoolean(obj.required),
        "show_in_catalog" -> play.api.libs.json.JsBoolean(obj.showInCatalog),
        "show_in_harmonization" -> play.api.libs.json.JsBoolean(obj.showInHarmonization)
      )
    }

    implicit def jsonWritesCatalogOptions: play.api.libs.json.Writes[Options] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.Options] {
        def writes(obj: io.flow.catalog.v0.models.Options) = {
          jsObjectOptions(obj)
        }
      }
    }

    implicit def jsonReadsCatalogSubcatalog: play.api.libs.json.Reads[Subcatalog] = {
      for {
        id <- (__ \ "id").read[String]
        catalog <- (__ \ "catalog").read[io.flow.catalog.v0.models.Catalog]
        settings <- (__ \ "settings").read[io.flow.catalog.v0.models.SubcatalogSettings]
      } yield Subcatalog(id, catalog, settings)
    }

    def jsObjectSubcatalog(obj: io.flow.catalog.v0.models.Subcatalog): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "catalog" -> jsObjectCatalog(obj.catalog),
        "settings" -> jsObjectSubcatalogSettings(obj.settings)
      )
    }

    implicit def jsonReadsCatalogSubcatalogForm: play.api.libs.json.Reads[SubcatalogForm] = {
      (__ \ "settings").readNullable[io.flow.catalog.v0.models.SubcatalogSettingsForm].map { x => new SubcatalogForm(settings = x) }
    }

    def jsObjectSubcatalogForm(obj: io.flow.catalog.v0.models.SubcatalogForm): play.api.libs.json.JsObject = {
      (obj.settings match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("settings" -> jsObjectSubcatalogSettingsForm(x))
      })
    }

    implicit def jsonWritesCatalogSubcatalogForm: play.api.libs.json.Writes[SubcatalogForm] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.SubcatalogForm] {
        def writes(obj: io.flow.catalog.v0.models.SubcatalogForm) = {
          jsObjectSubcatalogForm(obj)
        }
      }
    }

    implicit def jsonReadsCatalogSubcatalogItem: play.api.libs.json.Reads[SubcatalogItem] = {
      for {
        id <- (__ \ "id").read[String]
        item <- (__ \ "item").read[io.flow.catalog.v0.models.Item]
        status <- (__ \ "status").read[io.flow.catalog.v0.models.SubcatalogItemStatus]
      } yield SubcatalogItem(id, item, status)
    }

    def jsObjectSubcatalogItem(obj: io.flow.catalog.v0.models.SubcatalogItem): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "item" -> jsObjectItem(obj.item),
        "status" -> play.api.libs.json.JsString(obj.status.toString)
      )
    }

    implicit def jsonWritesCatalogSubcatalogItem: play.api.libs.json.Writes[SubcatalogItem] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.SubcatalogItem] {
        def writes(obj: io.flow.catalog.v0.models.SubcatalogItem) = {
          jsObjectSubcatalogItem(obj)
        }
      }
    }

    implicit def jsonReadsCatalogSubcatalogItemVersion: play.api.libs.json.Reads[SubcatalogItemVersion] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        subcatalogItem <- (__ \ "subcatalog_item").read[io.flow.catalog.v0.models.SubcatalogItem]
      } yield SubcatalogItemVersion(id, timestamp, `type`, subcatalogItem)
    }

    def jsObjectSubcatalogItemVersion(obj: io.flow.catalog.v0.models.SubcatalogItemVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "subcatalog_item" -> jsObjectSubcatalogItem(obj.subcatalogItem)
      )
    }

    implicit def jsonWritesCatalogSubcatalogItemVersion: play.api.libs.json.Writes[SubcatalogItemVersion] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.SubcatalogItemVersion] {
        def writes(obj: io.flow.catalog.v0.models.SubcatalogItemVersion) = {
          jsObjectSubcatalogItemVersion(obj)
        }
      }
    }

    implicit def jsonReadsCatalogSubcatalogQuery: play.api.libs.json.Reads[SubcatalogQuery] = {
      for {
        id <- (__ \ "id").read[String]
        q <- (__ \ "q").read[String]
        `type` <- (__ \ "type").read[io.flow.catalog.v0.models.QueryType]
      } yield SubcatalogQuery(id, q, `type`)
    }

    def jsObjectSubcatalogQuery(obj: io.flow.catalog.v0.models.SubcatalogQuery): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "q" -> play.api.libs.json.JsString(obj.q),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString)
      )
    }

    implicit def jsonWritesCatalogSubcatalogQuery: play.api.libs.json.Writes[SubcatalogQuery] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.SubcatalogQuery] {
        def writes(obj: io.flow.catalog.v0.models.SubcatalogQuery) = {
          jsObjectSubcatalogQuery(obj)
        }
      }
    }

    implicit def jsonReadsCatalogSubcatalogQueryForm: play.api.libs.json.Reads[SubcatalogQueryForm] = {
      for {
        q <- (__ \ "q").read[String]
        `type` <- (__ \ "type").read[io.flow.catalog.v0.models.QueryType]
      } yield SubcatalogQueryForm(q, `type`)
    }

    def jsObjectSubcatalogQueryForm(obj: io.flow.catalog.v0.models.SubcatalogQueryForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "q" -> play.api.libs.json.JsString(obj.q),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString)
      )
    }

    implicit def jsonWritesCatalogSubcatalogQueryForm: play.api.libs.json.Writes[SubcatalogQueryForm] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.SubcatalogQueryForm] {
        def writes(obj: io.flow.catalog.v0.models.SubcatalogQueryForm) = {
          jsObjectSubcatalogQueryForm(obj)
        }
      }
    }

    implicit def jsonReadsCatalogSubcatalogQueryValidation: play.api.libs.json.Reads[SubcatalogQueryValidation] = {
      for {
        valid <- (__ \ "valid").read[Seq[String]]
        invalid <- (__ \ "invalid").read[Seq[String]]
      } yield SubcatalogQueryValidation(valid, invalid)
    }

    def jsObjectSubcatalogQueryValidation(obj: io.flow.catalog.v0.models.SubcatalogQueryValidation): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "valid" -> play.api.libs.json.Json.toJson(obj.valid),
        "invalid" -> play.api.libs.json.Json.toJson(obj.invalid)
      )
    }

    implicit def jsonWritesCatalogSubcatalogQueryValidation: play.api.libs.json.Writes[SubcatalogQueryValidation] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.SubcatalogQueryValidation] {
        def writes(obj: io.flow.catalog.v0.models.SubcatalogQueryValidation) = {
          jsObjectSubcatalogQueryValidation(obj)
        }
      }
    }

    implicit def jsonReadsCatalogSubcatalogReference: play.api.libs.json.Reads[SubcatalogReference] = {
      (__ \ "id").read[String].map { x => new SubcatalogReference(id = x) }
    }

    def jsObjectSubcatalogReference(obj: io.flow.catalog.v0.models.SubcatalogReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id)
      )
    }

    implicit def jsonReadsCatalogSubcatalogSettings: play.api.libs.json.Reads[SubcatalogSettings] = {
      (__ \ "update_policy").read[io.flow.catalog.v0.models.UpdatePolicy].map { x => new SubcatalogSettings(updatePolicy = x) }
    }

    def jsObjectSubcatalogSettings(obj: io.flow.catalog.v0.models.SubcatalogSettings): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "update_policy" -> play.api.libs.json.JsString(obj.updatePolicy.toString)
      )
    }

    implicit def jsonWritesCatalogSubcatalogSettings: play.api.libs.json.Writes[SubcatalogSettings] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.SubcatalogSettings] {
        def writes(obj: io.flow.catalog.v0.models.SubcatalogSettings) = {
          jsObjectSubcatalogSettings(obj)
        }
      }
    }

    implicit def jsonReadsCatalogSubcatalogSettingsForm: play.api.libs.json.Reads[SubcatalogSettingsForm] = {
      (__ \ "update_policy").readNullable[io.flow.catalog.v0.models.UpdatePolicy].map { x => new SubcatalogSettingsForm(updatePolicy = x) }
    }

    def jsObjectSubcatalogSettingsForm(obj: io.flow.catalog.v0.models.SubcatalogSettingsForm): play.api.libs.json.JsObject = {
      (obj.updatePolicy match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("update_policy" -> play.api.libs.json.JsString(x.toString))
      })
    }

    implicit def jsonWritesCatalogSubcatalogSettingsForm: play.api.libs.json.Writes[SubcatalogSettingsForm] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.SubcatalogSettingsForm] {
        def writes(obj: io.flow.catalog.v0.models.SubcatalogSettingsForm) = {
          jsObjectSubcatalogSettingsForm(obj)
        }
      }
    }

    implicit def jsonReadsCatalogSubcatalogStatistics: play.api.libs.json.Reads[SubcatalogStatistics] = {
      for {
        excluded <- (__ \ "excluded").read[io.flow.catalog.v0.models.ItemStatistics]
        included <- (__ \ "included").read[io.flow.catalog.v0.models.ItemStatistics]
        restricted <- (__ \ "restricted").read[io.flow.catalog.v0.models.ItemStatistics]
        queue <- (__ \ "queue").read[io.flow.catalog.v0.models.ItemStatistics]
        catalog <- (__ \ "catalog").read[io.flow.catalog.v0.models.CatalogStatistics]
      } yield SubcatalogStatistics(excluded, included, restricted, queue, catalog)
    }

    def jsObjectSubcatalogStatistics(obj: io.flow.catalog.v0.models.SubcatalogStatistics): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "excluded" -> jsObjectItemStatistics(obj.excluded),
        "included" -> jsObjectItemStatistics(obj.included),
        "restricted" -> jsObjectItemStatistics(obj.restricted),
        "queue" -> jsObjectItemStatistics(obj.queue),
        "catalog" -> jsObjectCatalogStatistics(obj.catalog)
      )
    }

    implicit def jsonWritesCatalogSubcatalogStatistics: play.api.libs.json.Writes[SubcatalogStatistics] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.SubcatalogStatistics] {
        def writes(obj: io.flow.catalog.v0.models.SubcatalogStatistics) = {
          jsObjectSubcatalogStatistics(obj)
        }
      }
    }

    implicit def jsonReadsCatalogSubcatalogVersion: play.api.libs.json.Reads[SubcatalogVersion] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        subcatalog <- (__ \ "subcatalog").read[io.flow.catalog.v0.models.Subcatalog]
      } yield SubcatalogVersion(id, timestamp, `type`, subcatalog)
    }

    def jsObjectSubcatalogVersion(obj: io.flow.catalog.v0.models.SubcatalogVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "subcatalog" -> jsObjectSubcatalog(obj.subcatalog)
      )
    }

    implicit def jsonWritesCatalogSubcatalogVersion: play.api.libs.json.Writes[SubcatalogVersion] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.SubcatalogVersion] {
        def writes(obj: io.flow.catalog.v0.models.SubcatalogVersion) = {
          jsObjectSubcatalogVersion(obj)
        }
      }
    }

    implicit def jsonReadsCatalogTargeting: play.api.libs.json.Reads[Targeting] = {
      for {
        id <- (__ \ "id").read[String]
        key <- (__ \ "key").read[String]
        queries <- (__ \ "queries").read[Seq[io.flow.catalog.v0.models.TargetingQuery]]
        catalog <- (__ \ "catalog").read[io.flow.catalog.v0.models.CatalogReference]
        subcatalog <- (__ \ "subcatalog").readNullable[io.flow.catalog.v0.models.SubcatalogReference]
      } yield Targeting(id, key, queries, catalog, subcatalog)
    }

    def jsObjectTargeting(obj: io.flow.catalog.v0.models.Targeting): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "key" -> play.api.libs.json.JsString(obj.key),
        "queries" -> play.api.libs.json.Json.toJson(obj.queries),
        "catalog" -> jsObjectCatalogReference(obj.catalog)
      ) ++ (obj.subcatalog match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("subcatalog" -> jsObjectSubcatalogReference(x))
      })
    }

    implicit def jsonWritesCatalogTargeting: play.api.libs.json.Writes[Targeting] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.Targeting] {
        def writes(obj: io.flow.catalog.v0.models.Targeting) = {
          jsObjectTargeting(obj)
        }
      }
    }

    implicit def jsonReadsCatalogTargetingForm: play.api.libs.json.Reads[TargetingForm] = {
      for {
        key <- (__ \ "key").read[String]
        queries <- (__ \ "queries").read[Seq[io.flow.catalog.v0.models.TargetingQueryForm]]
        subcatalogId <- (__ \ "subcatalog_id").readNullable[String]
      } yield TargetingForm(key, queries, subcatalogId)
    }

    def jsObjectTargetingForm(obj: io.flow.catalog.v0.models.TargetingForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key),
        "queries" -> play.api.libs.json.Json.toJson(obj.queries)
      ) ++ (obj.subcatalogId match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("subcatalog_id" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesCatalogTargetingForm: play.api.libs.json.Writes[TargetingForm] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.TargetingForm] {
        def writes(obj: io.flow.catalog.v0.models.TargetingForm) = {
          jsObjectTargetingForm(obj)
        }
      }
    }

    implicit def jsonReadsCatalogTargetingItem: play.api.libs.json.Reads[TargetingItem] = {
      for {
        id <- (__ \ "id").read[String]
        targeting <- (__ \ "targeting").read[io.flow.catalog.v0.models.TargetingSummary]
        itemNumber <- (__ \ "item_number").read[String]
        query <- (__ \ "query").read[io.flow.catalog.v0.models.TargetingQuery]
      } yield TargetingItem(id, targeting, itemNumber, query)
    }

    def jsObjectTargetingItem(obj: io.flow.catalog.v0.models.TargetingItem): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "targeting" -> jsObjectTargetingSummary(obj.targeting),
        "item_number" -> play.api.libs.json.JsString(obj.itemNumber),
        "query" -> jsObjectTargetingQuery(obj.query)
      )
    }

    implicit def jsonWritesCatalogTargetingItem: play.api.libs.json.Writes[TargetingItem] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.TargetingItem] {
        def writes(obj: io.flow.catalog.v0.models.TargetingItem) = {
          jsObjectTargetingItem(obj)
        }
      }
    }

    implicit def jsonReadsCatalogTargetingQuery: play.api.libs.json.Reads[TargetingQuery] = {
      for {
        id <- (__ \ "id").read[String]
        q <- (__ \ "q").read[String]
        outcomeId <- (__ \ "outcome_id").read[String]
        position <- (__ \ "position").read[Long]
      } yield TargetingQuery(id, q, outcomeId, position)
    }

    def jsObjectTargetingQuery(obj: io.flow.catalog.v0.models.TargetingQuery): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "q" -> play.api.libs.json.JsString(obj.q),
        "outcome_id" -> play.api.libs.json.JsString(obj.outcomeId),
        "position" -> play.api.libs.json.JsNumber(obj.position)
      )
    }

    implicit def jsonWritesCatalogTargetingQuery: play.api.libs.json.Writes[TargetingQuery] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.TargetingQuery] {
        def writes(obj: io.flow.catalog.v0.models.TargetingQuery) = {
          jsObjectTargetingQuery(obj)
        }
      }
    }

    implicit def jsonReadsCatalogTargetingQueryForm: play.api.libs.json.Reads[TargetingQueryForm] = {
      for {
        q <- (__ \ "q").read[String]
        outcomeId <- (__ \ "outcome_id").read[String]
      } yield TargetingQueryForm(q, outcomeId)
    }

    def jsObjectTargetingQueryForm(obj: io.flow.catalog.v0.models.TargetingQueryForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "q" -> play.api.libs.json.JsString(obj.q),
        "outcome_id" -> play.api.libs.json.JsString(obj.outcomeId)
      )
    }

    implicit def jsonWritesCatalogTargetingQueryForm: play.api.libs.json.Writes[TargetingQueryForm] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.TargetingQueryForm] {
        def writes(obj: io.flow.catalog.v0.models.TargetingQueryForm) = {
          jsObjectTargetingQueryForm(obj)
        }
      }
    }

    implicit def jsonReadsCatalogTargetingSummary: play.api.libs.json.Reads[TargetingSummary] = {
      for {
        id <- (__ \ "id").read[String]
        key <- (__ \ "key").read[String]
        catalog <- (__ \ "catalog").read[io.flow.catalog.v0.models.CatalogReference]
        subcatalog <- (__ \ "subcatalog").readNullable[io.flow.catalog.v0.models.SubcatalogReference]
      } yield TargetingSummary(id, key, catalog, subcatalog)
    }

    def jsObjectTargetingSummary(obj: io.flow.catalog.v0.models.TargetingSummary): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "key" -> play.api.libs.json.JsString(obj.key),
        "catalog" -> jsObjectCatalogReference(obj.catalog)
      ) ++ (obj.subcatalog match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("subcatalog" -> jsObjectSubcatalogReference(x))
      })
    }

    implicit def jsonWritesCatalogTargetingSummary: play.api.libs.json.Writes[TargetingSummary] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.TargetingSummary] {
        def writes(obj: io.flow.catalog.v0.models.TargetingSummary) = {
          jsObjectTargetingSummary(obj)
        }
      }
    }

    implicit def jsonReadsCatalogTargetingVersion: play.api.libs.json.Reads[TargetingVersion] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        targeting <- (__ \ "targeting").read[io.flow.catalog.v0.models.Targeting]
      } yield TargetingVersion(id, timestamp, `type`, targeting)
    }

    def jsObjectTargetingVersion(obj: io.flow.catalog.v0.models.TargetingVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "targeting" -> jsObjectTargeting(obj.targeting)
      )
    }

    implicit def jsonWritesCatalogTargetingVersion: play.api.libs.json.Writes[TargetingVersion] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.TargetingVersion] {
        def writes(obj: io.flow.catalog.v0.models.TargetingVersion) = {
          jsObjectTargetingVersion(obj)
        }
      }
    }

    implicit def jsonReadsCatalogExpandableSubcatalog: play.api.libs.json.Reads[ExpandableSubcatalog] = new play.api.libs.json.Reads[ExpandableSubcatalog] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[ExpandableSubcatalog] = {
        (js \ "discriminator").asOpt[String].getOrElse { sys.error("Union[ExpandableSubcatalog] requires a discriminator named 'discriminator' - this field was not found in the Json Value") } match {
          case "subcatalog" => js.validate[io.flow.catalog.v0.models.Subcatalog]
          case "subcatalog_reference" => js.validate[io.flow.catalog.v0.models.SubcatalogReference]
          case other => play.api.libs.json.JsSuccess(io.flow.catalog.v0.models.ExpandableSubcatalogUndefinedType(other))
        }
      }
    }

    def jsObjectExpandableSubcatalog(obj: io.flow.catalog.v0.models.ExpandableSubcatalog): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.catalog.v0.models.Subcatalog => jsObjectSubcatalog(x) ++ play.api.libs.json.Json.obj("discriminator" -> "subcatalog")
        case x: io.flow.catalog.v0.models.SubcatalogReference => jsObjectSubcatalogReference(x) ++ play.api.libs.json.Json.obj("discriminator" -> "subcatalog_reference")
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesCatalogExpandableSubcatalog: play.api.libs.json.Writes[ExpandableSubcatalog] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.ExpandableSubcatalog] {
        def writes(obj: io.flow.catalog.v0.models.ExpandableSubcatalog) = {
          jsObjectExpandableSubcatalog(obj)
        }
      }
    }

    implicit def jsonReadsCatalogLocalizedPrice: play.api.libs.json.Reads[LocalizedPrice] = new play.api.libs.json.Reads[LocalizedPrice] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[LocalizedPrice] = {
        (js \ "key").asOpt[String].getOrElse { sys.error("Union[LocalizedPrice] requires a discriminator named 'key' - this field was not found in the Json Value") } match {
          case "localized_item_price" => js.validate[io.flow.catalog.v0.models.LocalizedItemPrice]
          case "localized_item_vat" => js.validate[io.flow.catalog.v0.models.LocalizedItemVat]
          case "localized_item_duty" => js.validate[io.flow.catalog.v0.models.LocalizedItemDuty]
          case "localized_total" => js.validate[io.flow.catalog.v0.models.LocalizedTotal]
          case other => play.api.libs.json.JsSuccess(io.flow.catalog.v0.models.LocalizedPriceUndefinedType(other))
        }
      }
    }

    def jsObjectLocalizedPrice(obj: io.flow.catalog.v0.models.LocalizedPrice): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.catalog.v0.models.LocalizedItemPrice => jsObjectLocalizedItemPrice(x) ++ play.api.libs.json.Json.obj("key" -> "localized_item_price")
        case x: io.flow.catalog.v0.models.LocalizedItemVat => jsObjectLocalizedItemVat(x) ++ play.api.libs.json.Json.obj("key" -> "localized_item_vat")
        case x: io.flow.catalog.v0.models.LocalizedItemDuty => jsObjectLocalizedItemDuty(x) ++ play.api.libs.json.Json.obj("key" -> "localized_item_duty")
        case x: io.flow.catalog.v0.models.LocalizedTotal => jsObjectLocalizedTotal(x) ++ play.api.libs.json.Json.obj("key" -> "localized_total")
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesCatalogLocalizedPrice: play.api.libs.json.Writes[LocalizedPrice] = {
      new play.api.libs.json.Writes[io.flow.catalog.v0.models.LocalizedPrice] {
        def writes(obj: io.flow.catalog.v0.models.LocalizedPrice) = {
          jsObjectLocalizedPrice(obj)
        }
      }
    }
  }
}

package io.flow.catalog.v0 {

  object Bindables {

    import play.api.mvc.{PathBindable, QueryStringBindable}

    // import models directly for backwards compatibility with prior versions of the generator
    import Core._
    import Models._

    object Core {
      implicit def pathBindableDateTimeIso8601(implicit stringBinder: QueryStringBindable[String]): PathBindable[_root_.org.joda.time.DateTime] = ApibuilderPathBindable(ApibuilderTypes.dateTimeIso8601)
      implicit def queryStringBindableDateTimeIso8601(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[_root_.org.joda.time.DateTime] = ApibuilderQueryStringBindable(ApibuilderTypes.dateTimeIso8601)

      implicit def pathBindableDateIso8601(implicit stringBinder: QueryStringBindable[String]): PathBindable[_root_.org.joda.time.LocalDate] = ApibuilderPathBindable(ApibuilderTypes.dateIso8601)
      implicit def queryStringBindableDateIso8601(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[_root_.org.joda.time.LocalDate] = ApibuilderQueryStringBindable(ApibuilderTypes.dateIso8601)
    }

    object Models {
      import io.flow.catalog.v0.models._

      val adjustmentReasonKeyConverter: ApibuilderTypeConverter[io.flow.catalog.v0.models.AdjustmentReasonKey] = new ApibuilderTypeConverter[io.flow.catalog.v0.models.AdjustmentReasonKey] {
        override def convert(value: String): io.flow.catalog.v0.models.AdjustmentReasonKey = io.flow.catalog.v0.models.AdjustmentReasonKey(value)
        override def convert(value: io.flow.catalog.v0.models.AdjustmentReasonKey): String = value.toString
        override def example: io.flow.catalog.v0.models.AdjustmentReasonKey = io.flow.catalog.v0.models.AdjustmentReasonKey.DutyDeminimis
        override def validValues: Seq[io.flow.catalog.v0.models.AdjustmentReasonKey] = io.flow.catalog.v0.models.AdjustmentReasonKey.all
      }
      implicit def pathBindableAdjustmentReasonKey(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.catalog.v0.models.AdjustmentReasonKey] = ApibuilderPathBindable(adjustmentReasonKeyConverter)
      implicit def queryStringBindableAdjustmentReasonKey(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.catalog.v0.models.AdjustmentReasonKey] = ApibuilderQueryStringBindable(adjustmentReasonKeyConverter)

      val attributeIntentConverter: ApibuilderTypeConverter[io.flow.catalog.v0.models.AttributeIntent] = new ApibuilderTypeConverter[io.flow.catalog.v0.models.AttributeIntent] {
        override def convert(value: String): io.flow.catalog.v0.models.AttributeIntent = io.flow.catalog.v0.models.AttributeIntent(value)
        override def convert(value: io.flow.catalog.v0.models.AttributeIntent): String = value.toString
        override def example: io.flow.catalog.v0.models.AttributeIntent = io.flow.catalog.v0.models.AttributeIntent.Brand
        override def validValues: Seq[io.flow.catalog.v0.models.AttributeIntent] = io.flow.catalog.v0.models.AttributeIntent.all
      }
      implicit def pathBindableAttributeIntent(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.catalog.v0.models.AttributeIntent] = ApibuilderPathBindable(attributeIntentConverter)
      implicit def queryStringBindableAttributeIntent(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.catalog.v0.models.AttributeIntent] = ApibuilderQueryStringBindable(attributeIntentConverter)

      val fulfillmentMethodTypeConverter: ApibuilderTypeConverter[io.flow.catalog.v0.models.FulfillmentMethodType] = new ApibuilderTypeConverter[io.flow.catalog.v0.models.FulfillmentMethodType] {
        override def convert(value: String): io.flow.catalog.v0.models.FulfillmentMethodType = io.flow.catalog.v0.models.FulfillmentMethodType(value)
        override def convert(value: io.flow.catalog.v0.models.FulfillmentMethodType): String = value.toString
        override def example: io.flow.catalog.v0.models.FulfillmentMethodType = io.flow.catalog.v0.models.FulfillmentMethodType.FulfillmentMethod
        override def validValues: Seq[io.flow.catalog.v0.models.FulfillmentMethodType] = io.flow.catalog.v0.models.FulfillmentMethodType.all
      }
      implicit def pathBindableFulfillmentMethodType(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.catalog.v0.models.FulfillmentMethodType] = ApibuilderPathBindable(fulfillmentMethodTypeConverter)
      implicit def queryStringBindableFulfillmentMethodType(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.catalog.v0.models.FulfillmentMethodType] = ApibuilderQueryStringBindable(fulfillmentMethodTypeConverter)

      val fulfillmentMethodValueConverter: ApibuilderTypeConverter[io.flow.catalog.v0.models.FulfillmentMethodValue] = new ApibuilderTypeConverter[io.flow.catalog.v0.models.FulfillmentMethodValue] {
        override def convert(value: String): io.flow.catalog.v0.models.FulfillmentMethodValue = io.flow.catalog.v0.models.FulfillmentMethodValue(value)
        override def convert(value: io.flow.catalog.v0.models.FulfillmentMethodValue): String = value.toString
        override def example: io.flow.catalog.v0.models.FulfillmentMethodValue = io.flow.catalog.v0.models.FulfillmentMethodValue.Digital
        override def validValues: Seq[io.flow.catalog.v0.models.FulfillmentMethodValue] = io.flow.catalog.v0.models.FulfillmentMethodValue.all
      }
      implicit def pathBindableFulfillmentMethodValue(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.catalog.v0.models.FulfillmentMethodValue] = ApibuilderPathBindable(fulfillmentMethodValueConverter)
      implicit def queryStringBindableFulfillmentMethodValue(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.catalog.v0.models.FulfillmentMethodValue] = ApibuilderQueryStringBindable(fulfillmentMethodValueConverter)

      val imageTagConverter: ApibuilderTypeConverter[io.flow.catalog.v0.models.ImageTag] = new ApibuilderTypeConverter[io.flow.catalog.v0.models.ImageTag] {
        override def convert(value: String): io.flow.catalog.v0.models.ImageTag = io.flow.catalog.v0.models.ImageTag(value)
        override def convert(value: io.flow.catalog.v0.models.ImageTag): String = value.toString
        override def example: io.flow.catalog.v0.models.ImageTag = io.flow.catalog.v0.models.ImageTag.Thumbnail
        override def validValues: Seq[io.flow.catalog.v0.models.ImageTag] = io.flow.catalog.v0.models.ImageTag.all
      }
      implicit def pathBindableImageTag(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.catalog.v0.models.ImageTag] = ApibuilderPathBindable(imageTagConverter)
      implicit def queryStringBindableImageTag(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.catalog.v0.models.ImageTag] = ApibuilderQueryStringBindable(imageTagConverter)

      val queryTypeConverter: ApibuilderTypeConverter[io.flow.catalog.v0.models.QueryType] = new ApibuilderTypeConverter[io.flow.catalog.v0.models.QueryType] {
        override def convert(value: String): io.flow.catalog.v0.models.QueryType = io.flow.catalog.v0.models.QueryType(value)
        override def convert(value: io.flow.catalog.v0.models.QueryType): String = value.toString
        override def example: io.flow.catalog.v0.models.QueryType = io.flow.catalog.v0.models.QueryType.Exclusion
        override def validValues: Seq[io.flow.catalog.v0.models.QueryType] = io.flow.catalog.v0.models.QueryType.all
      }
      implicit def pathBindableQueryType(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.catalog.v0.models.QueryType] = ApibuilderPathBindable(queryTypeConverter)
      implicit def queryStringBindableQueryType(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.catalog.v0.models.QueryType] = ApibuilderQueryStringBindable(queryTypeConverter)

      val subcatalogItemStatusConverter: ApibuilderTypeConverter[io.flow.catalog.v0.models.SubcatalogItemStatus] = new ApibuilderTypeConverter[io.flow.catalog.v0.models.SubcatalogItemStatus] {
        override def convert(value: String): io.flow.catalog.v0.models.SubcatalogItemStatus = io.flow.catalog.v0.models.SubcatalogItemStatus(value)
        override def convert(value: io.flow.catalog.v0.models.SubcatalogItemStatus): String = value.toString
        override def example: io.flow.catalog.v0.models.SubcatalogItemStatus = io.flow.catalog.v0.models.SubcatalogItemStatus.Excluded
        override def validValues: Seq[io.flow.catalog.v0.models.SubcatalogItemStatus] = io.flow.catalog.v0.models.SubcatalogItemStatus.all
      }
      implicit def pathBindableSubcatalogItemStatus(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.catalog.v0.models.SubcatalogItemStatus] = ApibuilderPathBindable(subcatalogItemStatusConverter)
      implicit def queryStringBindableSubcatalogItemStatus(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.catalog.v0.models.SubcatalogItemStatus] = ApibuilderQueryStringBindable(subcatalogItemStatusConverter)

      val taxabilityTypeConverter: ApibuilderTypeConverter[io.flow.catalog.v0.models.TaxabilityType] = new ApibuilderTypeConverter[io.flow.catalog.v0.models.TaxabilityType] {
        override def convert(value: String): io.flow.catalog.v0.models.TaxabilityType = io.flow.catalog.v0.models.TaxabilityType(value)
        override def convert(value: io.flow.catalog.v0.models.TaxabilityType): String = value.toString
        override def example: io.flow.catalog.v0.models.TaxabilityType = io.flow.catalog.v0.models.TaxabilityType.TaxRule
        override def validValues: Seq[io.flow.catalog.v0.models.TaxabilityType] = io.flow.catalog.v0.models.TaxabilityType.all
      }
      implicit def pathBindableTaxabilityType(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.catalog.v0.models.TaxabilityType] = ApibuilderPathBindable(taxabilityTypeConverter)
      implicit def queryStringBindableTaxabilityType(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.catalog.v0.models.TaxabilityType] = ApibuilderQueryStringBindable(taxabilityTypeConverter)

      val taxabilityValueConverter: ApibuilderTypeConverter[io.flow.catalog.v0.models.TaxabilityValue] = new ApibuilderTypeConverter[io.flow.catalog.v0.models.TaxabilityValue] {
        override def convert(value: String): io.flow.catalog.v0.models.TaxabilityValue = io.flow.catalog.v0.models.TaxabilityValue(value)
        override def convert(value: io.flow.catalog.v0.models.TaxabilityValue): String = value.toString
        override def example: io.flow.catalog.v0.models.TaxabilityValue = io.flow.catalog.v0.models.TaxabilityValue.Exempt
        override def validValues: Seq[io.flow.catalog.v0.models.TaxabilityValue] = io.flow.catalog.v0.models.TaxabilityValue.all
      }
      implicit def pathBindableTaxabilityValue(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.catalog.v0.models.TaxabilityValue] = ApibuilderPathBindable(taxabilityValueConverter)
      implicit def queryStringBindableTaxabilityValue(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.catalog.v0.models.TaxabilityValue] = ApibuilderQueryStringBindable(taxabilityValueConverter)

      val updatePolicyConverter: ApibuilderTypeConverter[io.flow.catalog.v0.models.UpdatePolicy] = new ApibuilderTypeConverter[io.flow.catalog.v0.models.UpdatePolicy] {
        override def convert(value: String): io.flow.catalog.v0.models.UpdatePolicy = io.flow.catalog.v0.models.UpdatePolicy(value)
        override def convert(value: io.flow.catalog.v0.models.UpdatePolicy): String = value.toString
        override def example: io.flow.catalog.v0.models.UpdatePolicy = io.flow.catalog.v0.models.UpdatePolicy.Auto
        override def validValues: Seq[io.flow.catalog.v0.models.UpdatePolicy] = io.flow.catalog.v0.models.UpdatePolicy.all
      }
      implicit def pathBindableUpdatePolicy(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.catalog.v0.models.UpdatePolicy] = ApibuilderPathBindable(updatePolicyConverter)
      implicit def queryStringBindableUpdatePolicy(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.catalog.v0.models.UpdatePolicy] = ApibuilderQueryStringBindable(updatePolicyConverter)
    }

    trait ApibuilderTypeConverter[T] {

      def convert(value: String): T

      def convert(value: T): String

      def example: T

      def validValues: Seq[T] = Nil

      def errorMessage(key: String, value: String, ex: java.lang.Exception): String = {
        val base = s"Invalid value '$value' for parameter '$key'. "
        validValues.toList match {
          case Nil => base + "Ex: " + convert(example)
          case values => base + ". Valid values are: " + values.mkString("'", "', '", "'")
        }
      }
    }

    object ApibuilderTypes {
      val dateTimeIso8601: ApibuilderTypeConverter[_root_.org.joda.time.DateTime] = new ApibuilderTypeConverter[_root_.org.joda.time.DateTime] {
        override def convert(value: String): _root_.org.joda.time.DateTime = _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseDateTime(value)
        override def convert(value: _root_.org.joda.time.DateTime): String = _root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(value)
        override def example: _root_.org.joda.time.DateTime = _root_.org.joda.time.DateTime.now
      }

      val dateIso8601: ApibuilderTypeConverter[_root_.org.joda.time.LocalDate] = new ApibuilderTypeConverter[_root_.org.joda.time.LocalDate] {
        override def convert(value: String): _root_.org.joda.time.LocalDate = _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseLocalDate(value)
        override def convert(value: _root_.org.joda.time.LocalDate): String = _root_.org.joda.time.format.ISODateTimeFormat.date.print(value)
        override def example: _root_.org.joda.time.LocalDate = _root_.org.joda.time.LocalDate.now
      }
    }

    final case class ApibuilderQueryStringBindable[T](
      converters: ApibuilderTypeConverter[T]
    ) extends QueryStringBindable[T] {

      override def bind(key: String, params: Map[String, Seq[String]]): _root_.scala.Option[_root_.scala.Either[String, T]] = {
        params.getOrElse(key, Nil).headOption.map { v =>
          try {
            Right(
              converters.convert(v)
            )
          } catch {
            case ex: java.lang.Exception => Left(
              converters.errorMessage(key, v, ex)
            )
          }
        }
      }

      override def unbind(key: String, value: T): String = {
        s"$key=${converters.convert(value)}"
      }
    }

    final case class ApibuilderPathBindable[T](
      converters: ApibuilderTypeConverter[T]
    ) extends PathBindable[T] {

      override def bind(key: String, value: String): _root_.scala.Either[String, T] = {
        try {
          Right(
            converters.convert(value)
          )
        } catch {
          case ex: java.lang.Exception => Left(
            converters.errorMessage(key, value, ex)
          )
        }
      }

      override def unbind(key: String, value: T): String = {
        converters.convert(value)
      }
    }

  }

}
