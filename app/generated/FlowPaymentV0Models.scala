/**
 * Generated by API Builder - https://www.apibuilder.io
 * Service version: 0.7.56
 * apibuilder 0.14.75 app.apibuilder.io/flow/payment/0.7.56/play_2_x_json
 */
package io.flow.payment.v0.models {

  sealed trait Authorization extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * Defines the valid discriminator values for the type Authorization
   */
  sealed trait AuthorizationDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object AuthorizationDiscriminator {

    case object CardAuthorization extends AuthorizationDiscriminator { override def toString = "card_authorization" }
    case object OnlineAuthorization extends AuthorizationDiscriminator { override def toString = "online_authorization" }

    final case class UNDEFINED(override val toString: String) extends AuthorizationDiscriminator

    val all: scala.List[AuthorizationDiscriminator] = scala.List(CardAuthorization, OnlineAuthorization)

    private[this] val byName: Map[String, AuthorizationDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): AuthorizationDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[AuthorizationDiscriminator] = byName.get(value.toLowerCase)

  }

  /**
   * Flow provides several different options for creating an authorization
   */
  sealed trait AuthorizationForm extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * Defines the valid discriminator values for the type AuthorizationForm
   */
  sealed trait AuthorizationFormDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object AuthorizationFormDiscriminator {

    /**
     * Creates a new authorization by copying an existing one.
     */
    case object AuthorizationCopyForm extends AuthorizationFormDiscriminator { override def toString = "authorization_copy_form" }
    /**
     * Enables card payments
     */
    case object DirectAuthorizationForm extends AuthorizationFormDiscriminator { override def toString = "direct_authorization_form" }
    /**
     * Enables card payments with Flow as Merchant of Record
     */
    case object MerchantOfRecordAuthorizationForm extends AuthorizationFormDiscriminator { override def toString = "merchant_of_record_authorization_form" }
    /**
     * Enables authorization via PayPal
     */
    case object PaypalAuthorizationForm extends AuthorizationFormDiscriminator { override def toString = "paypal_authorization_form" }
    /**
     * Enables authorizations via redirect-based alternative payment methods, such as
     * AliPay.
     */
    case object RedirectAuthorizationForm extends AuthorizationFormDiscriminator { override def toString = "redirect_authorization_form" }
    /**
     * Enables authorizations via inline widget alternative payment methods, such as
     * Klarna.
     */
    case object InlineAuthorizationForm extends AuthorizationFormDiscriminator { override def toString = "inline_authorization_form" }
    /**
     * Enables authorizations via ACH (Automated Clearing House) bank transfer.
     */
    case object AchAuthorizationForm extends AuthorizationFormDiscriminator { override def toString = "ach_authorization_form" }

    final case class UNDEFINED(override val toString: String) extends AuthorizationFormDiscriminator

    val all: scala.List[AuthorizationFormDiscriminator] = scala.List(AuthorizationCopyForm, DirectAuthorizationForm, MerchantOfRecordAuthorizationForm, PaypalAuthorizationForm, RedirectAuthorizationForm, InlineAuthorizationForm, AchAuthorizationForm)

    private[this] val byName: Map[String, AuthorizationFormDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): AuthorizationFormDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[AuthorizationFormDiscriminator] = byName.get(value.toLowerCase)

  }

  sealed trait AuthorizationPayloadParameters extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * Defines the valid discriminator values for the type
   * AuthorizationPayloadParameters
   */
  sealed trait AuthorizationPayloadParametersDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object AuthorizationPayloadParametersDiscriminator {

    case object GooglePayAuthorizationPayload extends AuthorizationPayloadParametersDiscriminator { override def toString = "google_pay_authorization_payload" }
    case object ApplePayMerchantValidationPayload extends AuthorizationPayloadParametersDiscriminator { override def toString = "apple_pay_merchant_validation_payload" }

    final case class UNDEFINED(override val toString: String) extends AuthorizationPayloadParametersDiscriminator

    val all: scala.List[AuthorizationPayloadParametersDiscriminator] = scala.List(GooglePayAuthorizationPayload, ApplePayMerchantValidationPayload)

    private[this] val byName: Map[String, AuthorizationPayloadParametersDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): AuthorizationPayloadParametersDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[AuthorizationPayloadParametersDiscriminator] = byName.get(value.toLowerCase)

  }

  sealed trait AuthorizationResultAction extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * Defines the valid discriminator values for the type AuthorizationResultAction
   */
  sealed trait AuthorizationResultActionDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object AuthorizationResultActionDiscriminator {

    case object AuthorizationResultActionGet extends AuthorizationResultActionDiscriminator { override def toString = "authorization_result_action_get" }
    case object AuthorizationResultActionPost extends AuthorizationResultActionDiscriminator { override def toString = "authorization_result_action_post" }
    case object AuthorizationResultActionWait extends AuthorizationResultActionDiscriminator { override def toString = "authorization_result_action_wait" }

    final case class UNDEFINED(override val toString: String) extends AuthorizationResultActionDiscriminator

    val all: scala.List[AuthorizationResultActionDiscriminator] = scala.List(AuthorizationResultActionGet, AuthorizationResultActionPost, AuthorizationResultActionWait)

    private[this] val byName: Map[String, AuthorizationResultActionDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): AuthorizationResultActionDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[AuthorizationResultActionDiscriminator] = byName.get(value.toLowerCase)

  }

  sealed trait ConfirmationDetails extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * Defines the valid discriminator values for the type ConfirmationDetails
   */
  sealed trait ConfirmationDetailsDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object ConfirmationDetailsDiscriminator {

    case object DirectDebit extends ConfirmationDetailsDiscriminator { override def toString = "direct_debit" }

    final case class UNDEFINED(override val toString: String) extends ConfirmationDetailsDiscriminator

    val all: scala.List[ConfirmationDetailsDiscriminator] = scala.List(DirectDebit)

    private[this] val byName: Map[String, ConfirmationDetailsDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ConfirmationDetailsDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ConfirmationDetailsDiscriminator] = byName.get(value.toLowerCase)

  }

  sealed trait ExpandableCard extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * Defines the valid discriminator values for the type ExpandableCard
   */
  sealed trait ExpandableCardDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object ExpandableCardDiscriminator {

    case object Card extends ExpandableCardDiscriminator { override def toString = "card" }
    case object CardReference extends ExpandableCardDiscriminator { override def toString = "card_reference" }
    case object CardSummary extends ExpandableCardDiscriminator { override def toString = "card_summary" }

    final case class UNDEFINED(override val toString: String) extends ExpandableCardDiscriminator

    val all: scala.List[ExpandableCardDiscriminator] = scala.List(Card, CardReference, CardSummary)

    private[this] val byName: Map[String, ExpandableCardDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ExpandableCardDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ExpandableCardDiscriminator] = byName.get(value.toLowerCase)

  }

  sealed trait GatewayAuthenticationData extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * Defines the valid discriminator values for the type GatewayAuthenticationData
   */
  sealed trait GatewayAuthenticationDataDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object GatewayAuthenticationDataDiscriminator {

    case object StripeAuthenticationData extends GatewayAuthenticationDataDiscriminator { override def toString = "stripe_authentication_data" }

    final case class UNDEFINED(override val toString: String) extends GatewayAuthenticationDataDiscriminator

    val all: scala.List[GatewayAuthenticationDataDiscriminator] = scala.List(StripeAuthenticationData)

    private[this] val byName: Map[String, GatewayAuthenticationDataDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): GatewayAuthenticationDataDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[GatewayAuthenticationDataDiscriminator] = byName.get(value.toLowerCase)

  }

  sealed trait GatewayAuthenticationDataForm extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * Defines the valid discriminator values for the type
   * GatewayAuthenticationDataForm
   */
  sealed trait GatewayAuthenticationDataFormDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object GatewayAuthenticationDataFormDiscriminator {

    case object StripeAuthenticationDataForm extends GatewayAuthenticationDataFormDiscriminator { override def toString = "stripe_authentication_data_form" }

    final case class UNDEFINED(override val toString: String) extends GatewayAuthenticationDataFormDiscriminator

    val all: scala.List[GatewayAuthenticationDataFormDiscriminator] = scala.List(StripeAuthenticationDataForm)

    private[this] val byName: Map[String, GatewayAuthenticationDataFormDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): GatewayAuthenticationDataFormDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[GatewayAuthenticationDataFormDiscriminator] = byName.get(value.toLowerCase)

  }

  sealed trait OnlineAuthorizationDetails extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * Defines the valid discriminator values for the type OnlineAuthorizationDetails
   */
  sealed trait OnlineAuthorizationDetailsDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object OnlineAuthorizationDetailsDiscriminator {

    case object PaypalAuthorizationDetails extends OnlineAuthorizationDetailsDiscriminator { override def toString = "paypal_authorization_details" }
    case object RedirectAuthorizationDetails extends OnlineAuthorizationDetailsDiscriminator { override def toString = "redirect_authorization_details" }
    case object InlineAuthorizationDetails extends OnlineAuthorizationDetailsDiscriminator { override def toString = "inline_authorization_details" }

    final case class UNDEFINED(override val toString: String) extends OnlineAuthorizationDetailsDiscriminator

    val all: scala.List[OnlineAuthorizationDetailsDiscriminator] = scala.List(PaypalAuthorizationDetails, RedirectAuthorizationDetails, InlineAuthorizationDetails)

    private[this] val byName: Map[String, OnlineAuthorizationDetailsDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): OnlineAuthorizationDetailsDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[OnlineAuthorizationDetailsDiscriminator] = byName.get(value.toLowerCase)

  }

  /**
   * Represents data for a specific online payment method
   */
  @deprecated("Remove after paypal_authorization_details goes live.")
  sealed trait Payment extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * Defines the valid discriminator values for the type Payment
   */
  sealed trait PaymentDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  @deprecated("Remove after paypal_authorization_details goes live.")
  object PaymentDiscriminator {

    case object PaymentPaypal extends PaymentDiscriminator { override def toString = "payment_paypal" }

    final case class UNDEFINED(override val toString: String) extends PaymentDiscriminator

    val all: scala.List[PaymentDiscriminator] = scala.List(PaymentPaypal)

    private[this] val byName: Map[String, PaymentDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): PaymentDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[PaymentDiscriminator] = byName.get(value.toLowerCase)

  }

  /**
   * Represents the data needed to initiate an online payment
   */
  sealed trait PaymentForm extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * Defines the valid discriminator values for the type PaymentForm
   */
  sealed trait PaymentFormDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object PaymentFormDiscriminator {

    case object MerchantOfRecordPaymentForm extends PaymentFormDiscriminator { override def toString = "merchant_of_record_payment_form" }

    final case class UNDEFINED(override val toString: String) extends PaymentFormDiscriminator

    val all: scala.List[PaymentFormDiscriminator] = scala.List(MerchantOfRecordPaymentForm)

    private[this] val byName: Map[String, PaymentFormDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): PaymentFormDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[PaymentFormDiscriminator] = byName.get(value.toLowerCase)

  }

  /**
   * Used for initiating an ACH (Automated Clearing House) bank transfer.
   * 
   * @param accountOwnerName The bank account holder name.
   * @param accountNumber The US bank account number from which the payment will be debited. The bank
   *        account number must be between 4 and 17 digits.
   * @param routingNumber The ABA routing transit number.
   * @param billingAddress Billing address
   * @param orderNumber Client order number for which to authorize payment.
   * @param amount The amount to authorize. If an order number is provided, it cannot exceed the
   *        order total.
   * @param currency The ISO 4217-3 code for the currency. Case insensitive. See
   *        https://api.flow.io/reference/currencies
   * @param key Your unique identifier for this transaction, which if provided is used to
   *        implement idempotency. If not provided, we will assign.
   * @param attributes A set of key/value pairs that you can attach to an authorization object
   * @param ip The IP address of the consumer
   */
  final case class AchAuthorizationForm(
    accountOwnerName: String,
    accountNumber: String,
    routingNumber: String,
    billingAddress: io.flow.common.v0.models.BillingAddress,
    orderNumber: _root_.scala.Option[String] = None,
    amount: BigDecimal,
    currency: String,
    key: _root_.scala.Option[String] = None,
    attributes: _root_.scala.Option[Map[String, String]] = None,
    ip: _root_.scala.Option[String] = None
  ) extends AuthorizationForm

  /**
   * @param validationUrl Apple's server URL to validate the merchant and obtain a merchant session
   *        object, which will be sent back to frontend.
   * @param displayName The display name will appear in e.g. Touch Bar. A string of 64 or fewer UTF-8
   *        characters containing the canonical name for your store, suitable for display.
   *        Do not localize the name. Default value will be provided from database
   */
  final case class ApplePayMerchantValidationPayload(
    validationUrl: String,
    displayName: _root_.scala.Option[String] = None
  ) extends AuthorizationPayloadParameters

  /**
   * Creates a new authorization based on the underlying information in an existing
   * authorization. A common use case here is to create a new auth when the existing
   * one has expired.
   * 
   * @param sourceAuthorizationKey The key of the source authorization that we are copying
   * @param amount The amount to authorize
   * @param currency The ISO 4217-3 code for the currency. Case insensitive. See
   *        https://api.flow.io/reference/currencies
   * @param attributes A set of key/value pairs that you can attach to an authorization object
   */
  final case class AuthorizationCopyForm(
    sourceAuthorizationKey: String,
    amount: BigDecimal,
    currency: String,
    attributes: _root_.scala.Option[Map[String, String]] = None
  ) extends AuthorizationForm

  /**
   * Details for why an authorization was not created
   * 
   * @param code Specific reason for the error
   * @param avs Specific AVS information if applicable
   * @param cvv Specific CVV information if applicable
   */
  final case class AuthorizationError(
    code: io.flow.payment.v0.models.AuthorizationDeclineCode,
    messages: Seq[String],
    avs: _root_.scala.Option[io.flow.payment.v0.models.Avs] = None,
    cvv: _root_.scala.Option[io.flow.payment.v0.models.Cvv] = None
  )

  final case class AuthorizationOrderReference(
    number: String
  )

  /**
   * Used to complete an inline authorization like Google Pay or Apple Pay.
   */
  final case class AuthorizationPayload(
    parameters: io.flow.payment.v0.models.AuthorizationPayloadParameters
  )

  final case class AuthorizationReference(
    id: String,
    key: String,
    order: _root_.scala.Option[io.flow.payment.v0.models.AuthorizationOrderReference] = None
  )

  /**
   * Contains the result of the authorization. If an immediate response is not
   * available, the state will be 'pending' - this usually indicates fraud review
   * requires additional time / verification (or a potential network issue with the
   * issuing bank).
   * 
   * @param declineCode If status is declined, will contain the details behind the decline
   */
  final case class AuthorizationResult(
    status: io.flow.payment.v0.models.AuthorizationStatus,
    action: _root_.scala.Option[io.flow.payment.v0.models.AuthorizationResultAction] = None,
    declineCode: _root_.scala.Option[io.flow.payment.v0.models.AuthorizationDeclineCode] = None,
    avs: _root_.scala.Option[io.flow.payment.v0.models.Avs] = None,
    cvv: _root_.scala.Option[io.flow.payment.v0.models.Cvv] = None,
    threeDSecure: _root_.scala.Option[io.flow.payment.v0.models.ThreeDSecure] = None,
    description: _root_.scala.Option[io.flow.payment.v0.models.AuthorizationResultDescription] = None
  )

  /**
   * Provides details for how to acquire additional information from the customer
   * using GET (e.g. redirecting to the issuer for online payment method or 3D
   * Secure).
   */
  final case class AuthorizationResultActionGet(
    `type`: io.flow.payment.v0.models.AuthorizationResultActionType,
    url: _root_.scala.Option[String] = None
  ) extends AuthorizationResultAction

  /**
   * Provides details for how to acquire additional information from the customer
   * using POST (e.g. redirecting to the issuer for online payment method or 3D
   * Secure).
   * 
   * @param url The URL to use for the POST request.
   * @param parameters Contains parameters that are required to be included as part of the request.
   */
  final case class AuthorizationResultActionPost(
    `type`: io.flow.payment.v0.models.AuthorizationResultActionType,
    url: String,
    parameters: _root_.play.api.libs.json.JsObject
  ) extends AuthorizationResultAction

  /**
   * Indicates that a response is not ready and that the consumer should poll (or
   * wait) for a response.
   */
  final case class AuthorizationResultActionWait(
    `type`: io.flow.payment.v0.models.AuthorizationResultActionType
  ) extends AuthorizationResultAction

  /**
   * @param display The default display text, e.g. 'VISA ending in 4700' or 'Payment with PayPal'.
   */
  final case class AuthorizationResultDescription(
    display: String
  )

  final case class AuthorizationVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    authorization: io.flow.payment.v0.models.Authorization
  )

  /**
   * Represents the address verification results
   * 
   * @param name If available, indicates whether the cardholder's name matches.
   * @param address If available, indicates whether the cardholder's address matches.
   * @param postal If available, indicates whether the cardholder's postal code matches.
   */
  final case class Avs(
    code: io.flow.payment.v0.models.AvsCode,
    name: _root_.scala.Option[Boolean] = None,
    address: _root_.scala.Option[Boolean] = None,
    postal: _root_.scala.Option[Boolean] = None,
    description: _root_.scala.Option[String] = None
  )

  /**
   * Capture actually transfers funds. You can capture as many times as you'd like up
   * until the total amount of the authorization has been captured or the
   * authorization otherwise becomes unavailable (e.g. expires).
   * 
   * @param amount The amount to capture in the currency of the associated authorization. If not
   *        specified, defaults to the full amount of the authorization (minus any prior
   *        captures).
   * @param currency Required if amount is specified. The ISO 4217-3 code for the currency. Case
   *        insensitive. See https://api.flow.io/reference/currencies
   * @param requested The requested amount/currency of the capture when created. We record this value
   *        as it will be converted to the currency of the authorization automatically if it
   *        does not match.
   * @param attributes A set of key/value pairs that you can attach to a capture object
   * @param status Indicates the status of the capture.
   * @param base The amount/currency of the capture in base currency. Added in Summer 2018 and
   *        always present since then.
   */
  final case class Capture(
    id: String,
    key: String,
    authorization: io.flow.payment.v0.models.AuthorizationReference,
    amount: BigDecimal,
    currency: String,
    requested: _root_.scala.Option[io.flow.common.v0.models.Money] = None,
    createdAt: _root_.org.joda.time.DateTime,
    attributes: _root_.scala.Option[Map[String, String]] = None,
    status: io.flow.payment.v0.models.CaptureStatus = io.flow.payment.v0.models.CaptureStatus.Succeeded,
    base: _root_.scala.Option[io.flow.common.v0.models.Money] = None
  )

  /**
   * @param code To maintain compatibility with generic_error
   * @param messages To maintain compatibility with generic_error
   * @param declineCode Contains details related to the reason for which a capture failed.
   */
  final case class CaptureError(
    code: io.flow.error.v0.models.GenericErrorCode = io.flow.error.v0.models.GenericErrorCode.GenericError,
    messages: Seq[String],
    declineCode: io.flow.payment.v0.models.CaptureDeclineCode
  )

  /**
   * Capture actually transfers funds. You can capture as many times as you'd like up
   * until the total amount of the authorization has been captured or the
   * authorization otherwise becomes unavailable (e.g. expires).
   * 
   * @param key Your unique identifier for this transaction, which if provided is used to
   *        implement idempotency. If not provided, we will assign.
   * @param amount The amount to capture in the currency of the associated authorization. If not
   *        specified, defaults to the full amount of the authorization (minus any prior
   *        captures).
   * @param currency Required if amount is specified. The ISO 4217-3 code for the currency. Case
   *        insensitive. See https://api.flow.io/reference/currencies
   * @param attributes A set of key/value pairs that you can attach to a capture object
   */
  final case class CaptureForm(
    authorizationId: String,
    key: _root_.scala.Option[String] = None,
    amount: _root_.scala.Option[BigDecimal] = None,
    currency: _root_.scala.Option[String] = None,
    attributes: _root_.scala.Option[Map[String, String]] = None
  )

  final case class CaptureIdentifier(
    id: String,
    capture: io.flow.payment.v0.models.CaptureReference,
    identifier: String,
    primary: Boolean
  )

  final case class CaptureReference(
    id: String,
    key: String
  )

  final case class CaptureVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    capture: io.flow.payment.v0.models.Capture
  )

  /**
   * Card represents the metadata about a secure, tokenized card. The card 'token' is
   * a unique, cryptographically secure token by which this card can be identified in
   * the future. The card token itself will either be a permanent card token (denoted
   * by a prefix of F96) or a one time nonce (denoted by a prefix of F17). Nonces
   * represent cards that were encrypted from public channels (like the user's
   * browser via JavaScript) and can be used once only. If you have a nonce you can
   * exchange it for a permanent card token via the operation POST
   * /:organization/cards/nonces
   * 
   * @param token Unique, cryptographically secure token by which this card can be identified in
   *        the future. This value should be kept secure in your system's as payment
   *        authorizations are created against this token.
   * @param iin The issuer identification number (IIN) (formerly known as the Bank
   *        Identification Number) which are the leading digits of the card number.
   * @param issuer Added in october 2018
   * @param last4 Cleartext last 4 numbers of the card
   * @param name Cardholder name
   * @param address Cardholder billing address
   */
  final case class Card(
    id: String,
    token: String,
    `type`: io.flow.payment.v0.models.CardType,
    expiration: io.flow.payment.v0.models.Expiration,
    iin: String,
    issuer: _root_.scala.Option[io.flow.payment.v0.models.IssuerSummary] = None,
    last4: String,
    name: String,
    address: _root_.scala.Option[io.flow.common.v0.models.BillingAddress] = None
  ) extends ExpandableCard

  /**
   * An authorization is used to check and reserve funds w/ a given payment method.
   * No funds are actually transferred; once you have you an authorization, you can
   * capture up to the amount of the authorization.
   * 
   * @param card If this authorization was made for a card payment method, this field will
   *        contain the details of the card used on the transaction
   * @param amount The amount to authorize
   * @param currency The ISO 4217-3 code for the currency. Case insensitive. See
   *        https://api.flow.io/reference/currencies
   * @param requested The amount/currency of the order when created.
   * @param customer The customer who is actually receiving the goods. Providing name and email at a
   *        minimum will significantly increase the acceptance rate and are recommended.
   * @param attributes A set of key/value pairs that you can attach to an authorization object
   * @param destination Destination address, if relevant
   * @param billingAddress Destination address, if relevant
   * @param order If this authorization was made for a specific order number, that order will be
   *        referenced here
   * @param ip The IP address of the consumer
   * @param expiresAt The time at which this authorization expires, if any.
   * @param base The amount/currency of the authorization in base currency. Added in Summer 2018
   *        and always present since then.
   */
  final case class CardAuthorization(
    id: String,
    key: String,
    merchantOfRecord: io.flow.common.v0.models.MerchantOfRecord = io.flow.common.v0.models.MerchantOfRecord.Flow,
    method: _root_.scala.Option[io.flow.reference.v0.models.PaymentMethod] = None,
    card: io.flow.payment.v0.models.ExpandableCard,
    amount: BigDecimal,
    currency: String,
    requested: _root_.scala.Option[io.flow.common.v0.models.Money] = None,
    customer: io.flow.common.v0.models.OrderCustomer,
    attributes: Map[String, String],
    destination: _root_.scala.Option[io.flow.common.v0.models.Address] = None,
    billingAddress: _root_.scala.Option[io.flow.common.v0.models.BillingAddress] = None,
    order: _root_.scala.Option[io.flow.payment.v0.models.AuthorizationOrderReference] = None,
    ip: _root_.scala.Option[String] = None,
    result: io.flow.payment.v0.models.AuthorizationResult,
    createdAt: _root_.org.joda.time.DateTime,
    expiresAt: _root_.scala.Option[_root_.org.joda.time.DateTime] = None,
    base: _root_.scala.Option[io.flow.common.v0.models.Money] = None
  ) extends Authorization

  /**
   * Details for why a card was not created
   * 
   * @param code Specific reason for the error
   * @param avs Specific AVS information if applicable
   * @param cvv Specific CVV information if applicable
   */
  final case class CardError(
    code: io.flow.payment.v0.models.CardErrorCode,
    messages: Seq[String],
    avs: _root_.scala.Option[io.flow.payment.v0.models.Avs] = None,
    cvv: _root_.scala.Option[io.flow.payment.v0.models.Cvv] = None
  )

  /**
   * @param number Cleartext card number. You must provide either this field or 'cipher', but not
   *        both. May contain integers only or integers with dashes. If dashes are provided,
   *        we will remove them, storing only the raw number.
   * @param cipher Card number encrypted using your assigned public key. You must provide either
   *        this field or 'number', but not both. Card number itself may contain integers
   *        only or integers with dashes. If dashes are provided, we will remove them,
   *        storing only the raw number.
   * @param expirationMonth The month of expiration expressed as a number. 1 = January, 12 = December
   * @param expirationYear The 4 digit expiration year
   * @param name Cardholder name.
   * @param cvv The card verification number for the card that is used to verify the card
   *        details at creation time, making cvv optional for future payment authorizations.
   * @param address Cardholder billing address
   * @param ip The IP address of the consumer
   * @param challengeText When providing a cipher, you can optionally provide a challenge text and
   *        challenge cipher that will allow us to verify that client side encryption worked
   *        properly, returning better error messages in some cases. The Flow JavaScript API
   *        uses the challenge to verify that the asymmetric encryption is working properly
   *        in the client.
   * @param challengeCipher When providing a cipher, you can optionally provide a challenge text and
   *        challenge cipher that will allow us to verify that client side encryption worked
   *        properly, returning better error messages in some cases. The Flow JavaScript API
   *        uses the challenge to verify that the asymmetric encryption is working properly
   *        in the client.
   * @param tokenType Determines whether or not you want to create a permanent, tokenized card or a
   *        one time use token. By default, authenticated API requests create permanent
   *        tokens. Unauthenticated requests will create one-time tokens - and you will get
   *        an error if you try to create a permanent token via an unauthorized request.
   */
  final case class CardForm(
    number: _root_.scala.Option[String] = None,
    cipher: _root_.scala.Option[String] = None,
    expirationMonth: Int,
    expirationYear: Int,
    name: String,
    cvv: String,
    address: _root_.scala.Option[io.flow.common.v0.models.BillingAddress] = None,
    ip: _root_.scala.Option[String] = None,
    challengeText: _root_.scala.Option[String] = None,
    challengeCipher: _root_.scala.Option[String] = None,
    tokenType: _root_.scala.Option[io.flow.payment.v0.models.TokenType] = None
  )

  /**
   * The card nonce form presents a one time token to exchange server side for a
   * permanent, secure tokenized card
   * 
   * @param token The one time card nonce to exchange for a permanent card token. This value will
   *        start with F17
   */
  final case class CardNonceForm(
    token: String
  )

  final case class CardReference(
    id: String,
    token: String
  ) extends ExpandableCard

  /**
   * Card Summary is the card without the token
   * 
   * @param iin The issuer identification number (IIN) (formerly known as the Bank
   *        Identification Number) which are the leading digits of the card number.
   * @param issuer Added in october 2018
   * @param last4 Cleartext last 4 numbers of the card
   * @param name Cardholder name
   * @param address Cardholder billing address
   */
  final case class CardSummary(
    id: String,
    `type`: io.flow.payment.v0.models.CardType,
    expiration: io.flow.payment.v0.models.Expiration,
    iin: String,
    issuer: _root_.scala.Option[io.flow.payment.v0.models.IssuerSummary] = None,
    last4: String,
    name: String,
    address: _root_.scala.Option[io.flow.common.v0.models.BillingAddress] = None
  ) extends ExpandableCard

  /**
   * @param token The token referring to a previously tokenized card.
   */
  final case class CardTokenForm(
    token: String
  )

  final case class CardVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    card: io.flow.payment.v0.models.Card
  )

  /**
   * Represents the card verification results
   */
  final case class Cvv(
    code: io.flow.payment.v0.models.CvvCode,
    description: _root_.scala.Option[String] = None
  )

  /**
   * Creates an authorization for a transaction in which you remain the merchant of
   * record. An authorization is used to check and reserve funds w/ a given payment
   * method. No funds are actually transferred; once you have you an authorization,
   * you can capture up to the amount of the authorization.
   * 
   * @param token The token of the payment method to use when authorizing this transaction
   * @param amount The amount to authorize
   * @param currency The ISO 4217-3 code for the currency. Case insensitive. See
   *        https://api.flow.io/reference/currencies
   * @param customer The customer who is actually making the purchase. While optional, providing name
   *        and email at a minimum will significantly increase the acceptance rate.
   * @param key Your unique identifier for this transaction, which if provided is used to
   *        implement idempotency. If not provided, we will assign.
   * @param cvv The card verification number. Note this number is never stored and thus is
   *        presented on each auth. Presenting the CVV may increase acceptance rates
   * @param attributes A set of key/value pairs that you can attach to an authorization object
   * @param destination Destination address, if relevant
   * @param billingAddress Destination address, if relevant
   * @param ip The IP address of the consumer
   * @param options Optional behaviors to enable for this authorization
   * @param redirectUrls When using 3D Secure, this field specifies the success and optional failure URLs
   *        to which the user will be redirected after completing (or failing to complete)
   *        payment.
   */
  final case class DirectAuthorizationForm(
    token: String,
    amount: BigDecimal,
    currency: String,
    customer: _root_.scala.Option[io.flow.common.v0.models.OrderCustomer] = None,
    key: _root_.scala.Option[String] = None,
    cvv: _root_.scala.Option[String] = None,
    attributes: _root_.scala.Option[Map[String, String]] = None,
    destination: _root_.scala.Option[io.flow.common.v0.models.Address] = None,
    billingAddress: _root_.scala.Option[io.flow.common.v0.models.BillingAddress] = None,
    ip: _root_.scala.Option[String] = None,
    options: _root_.scala.Option[Seq[io.flow.payment.v0.models.AuthorizationOption]] = None,
    redirectUrls: _root_.scala.Option[io.flow.payment.v0.models.PostPaymentRedirectUrls] = None
  ) extends AuthorizationForm

  /**
   * Represents an online direct debit payment.
   * 
   * @param routingNumber Routing information for the customers bank
   * @param last4 The last 4 digits of the customers account number in cleartext
   */
  final case class DirectDebit(
    routingNumber: String,
    last4: String
  ) extends ConfirmationDetails

  /**
   * The month and year at which a card expires
   * 
   * @param month The month of expiration expressed as a number. 1 = January, 12 = December
   * @param year The 4 digit expiration year
   */
  final case class Expiration(
    month: Int,
    year: Int
  )

  /**
   * @param payload See io.flow.google.pay.v0.models.payment_data
   */
  final case class GooglePayAuthorizationPayload(
    payload: _root_.play.api.libs.json.JsObject
  ) extends AuthorizationPayloadParameters

  /**
   * @param primary A payment transaction can optionally have a single additional primary identifier
   *        - this identifier will be made available in billing to assist in reconciliation.
   *        If not specified, the first identifer created will automatically be marked the
   *        default
   */
  final case class IdentifierForm(
    primary: _root_.scala.Option[Boolean] = None
  )

  /**
   * Represents an online payment that requires the client token from underlying
   * payment processor before entering their payment information.
   * 
   * @param id The id of the record containing expanded authorization details for this
   *        authorization.
   * @param clientToken The client token provided by underlying payment processor.
   */
  final case class InlineAuthorizationDetails(
    id: String,
    clientToken: _root_.scala.Option[String] = None,
    parameters: _root_.scala.Option[_root_.play.api.libs.json.JsObject] = None
  ) extends OnlineAuthorizationDetails

  /**
   * Executes a widget-based payment based on the provided payment method.
   * 
   * @param method The name (or brand code) of the redirect-based payment method for which to
   *        create an authorization, e.g. 'unionpay'.
   * @param issuer The id of the issuing bank, if required by the selected payment method. For
   *        payment methods such as iDEAL, the customer must select an issuer before being
   *        redirected to provide payment details.
   * @param orderNumber Client order number for which to authorize payment.
   * @param amount The amount to authorize.
   * @param currency The ISO 4217-3 code for the currency. Case insensitive. See
   *        https://api.flow.io/reference/currencies
   * @param billingAddress Billing address
   * @param key Your unique identifier for this transaction, which if provided is used to
   *        implement idempotency. If not provided, we will assign.
   * @param attributes A set of key/value pairs that you can attach to an authorization object
   * @param ip The IP address of the consumer
   * @param payload If required, contains the payload used to complete the authorization (e.g. the
   *        token from Google Pay)
   */
  final case class InlineAuthorizationForm(
    method: String,
    issuer: _root_.scala.Option[io.flow.payment.v0.models.IssuerReference] = None,
    orderNumber: String,
    amount: BigDecimal,
    currency: String,
    billingAddress: _root_.scala.Option[io.flow.common.v0.models.BillingAddress] = None,
    key: _root_.scala.Option[String] = None,
    attributes: _root_.scala.Option[Map[String, String]] = None,
    ip: _root_.scala.Option[String] = None,
    payload: _root_.scala.Option[io.flow.payment.v0.models.AuthorizationPayload] = None
  ) extends AuthorizationForm

  final case class IssuerReference(
    id: String
  )

  /**
   * @param name The name of the organization that issued this card
   * @param country The country of the issuing bank. The ISO 3166-3 country code. Case insensitive.
   *        See https://api.flow.io/reference/countries
   */
  final case class IssuerSummary(
    iin: String,
    name: _root_.scala.Option[String] = None,
    country: _root_.scala.Option[String] = None
  )

  /**
   * @param name The name of the organization that issued this card
   * @param country The country of the issuing bank. The ISO 3166-3 country code. Case insensitive.
   *        See https://api.flow.io/reference/countries
   */
  @deprecated("Use issuer_summary")
  final case class IssuerV1(
    iin: String,
    cardBrand: String,
    cardType: _root_.scala.Option[String] = None,
    name: _root_.scala.Option[String] = None,
    country: _root_.scala.Option[String] = None
  )

  /**
   * Creates an authorization for a transaction for which Flow is the merchant of
   * record. In this case, you must provide your order number for a valid Flow order.
   * An authorization is used to check and reserve funds w/ a given payment method.
   * No funds are actually transferred; once you have you an authorization, you can
   * capture up to the amount of the authorization
   * 
   * @param token The token of the payment method to use when authorizing this transaction
   * @param orderNumber Client order number for which to authorize payment. We will automatically verify
   *        that this order exists and will authorize the total amount of the order in the
   *        currency of the order.
   * @param amount The amount to authorize - if specified, will be used to confirm that the amount
   *        exactly matches the order total
   * @param currency Required if amount is specified. The ISO 4217-3 code for the currency. Case
   *        insensitive. See https://api.flow.io/reference/currencies
   * @param key Your unique identifier for this transaction, which if provided is used to
   *        implement idempotency. If not provided, we will assign.
   * @param cvv The card verification number. Note this number is never stored and thus is
   *        presented on each auth. Presenting the CVV may increase acceptance rates
   * @param attributes A set of key/value pairs that you can attach to an authorization object
   * @param ip The IP address of the consumer
   * @param options Optional behaviors to enable for this authorization
   * @param redirectUrls When using 3D Secure, this field specifies the success and optional failure URLs
   *        to which the user will be redirected after completing (or failing to complete)
   *        payment.
   * @param installmentProgramId If this authorization is made in context of an installment program, this field
   *        can be provided and this authorization will reflect only the first installment
   *        amount.
   */
  final case class MerchantOfRecordAuthorizationForm(
    token: String,
    orderNumber: String,
    amount: _root_.scala.Option[BigDecimal] = None,
    currency: _root_.scala.Option[String] = None,
    key: _root_.scala.Option[String] = None,
    cvv: _root_.scala.Option[String] = None,
    attributes: _root_.scala.Option[Map[String, String]] = None,
    ip: _root_.scala.Option[String] = None,
    options: _root_.scala.Option[Seq[io.flow.payment.v0.models.AuthorizationOption]] = None,
    redirectUrls: _root_.scala.Option[io.flow.payment.v0.models.PostPaymentRedirectUrls] = None,
    installmentProgramId: _root_.scala.Option[String] = None
  ) extends AuthorizationForm

  /**
   * Creates an online payment
   * 
   * @param orderNumber Client order number for which to authorize payment. We will automatically verify
   *        that this order exists and will authorize the total amount of the order in the
   *        currency of the order.
   * @param amount The amount to authorize - will be used to confirm that the amount exactly
   *        matches the order total
   * @param currency The ISO 4217-3 code for the currency. Case insensitive. See
   *        https://api.flow.io/reference/currencies
   */
  final case class MerchantOfRecordPaymentForm(
    method: String,
    orderNumber: String,
    amount: BigDecimal,
    currency: String
  ) extends PaymentForm

  /**
   * @param details The associated online authorization details, if any.
   * @param payment The associated online payment
   * @param amount The amount to authorize
   * @param currency The ISO 4217-3 code for the currency. Case insensitive. See
   *        https://api.flow.io/reference/currencies
   * @param requested The amount/currency of the order when created.
   * @param customer The customer who is actually receiving the goods. Providing name and email at a
   *        minimum will significantly increase the acceptance rate and are recommended.
   * @param attributes A set of key/value pairs that you can attach to an authorization object
   * @param destination Destination address, if relevant
   * @param billingAddress Billing address, if relevant
   * @param order If this authorization was made for a specific order number, that order will be
   *        referenced here
   * @param ip The IP address of the consumer
   * @param expiresAt The time at which this authorization expires, if any.
   * @param base The amount/currency of the authorization in base currency. Added in Summer 2018
   *        and always present since then.
   */
  final case class OnlineAuthorization(
    id: String,
    key: String,
    method: _root_.scala.Option[io.flow.reference.v0.models.PaymentMethod] = None,
    merchantOfRecord: io.flow.common.v0.models.MerchantOfRecord = io.flow.common.v0.models.MerchantOfRecord.Flow,
    details: _root_.scala.Option[io.flow.payment.v0.models.OnlineAuthorizationDetails] = None,
    @deprecated("Remove after `method` and `details` fields are added to the authorization model.") payment: _root_.scala.Option[_root_.play.api.libs.json.JsObject] = None,
    amount: BigDecimal,
    currency: String,
    requested: _root_.scala.Option[io.flow.common.v0.models.Money] = None,
    customer: io.flow.common.v0.models.OrderCustomer,
    attributes: Map[String, String],
    destination: _root_.scala.Option[io.flow.common.v0.models.Address] = None,
    billingAddress: _root_.scala.Option[io.flow.common.v0.models.BillingAddress] = None,
    order: _root_.scala.Option[io.flow.payment.v0.models.AuthorizationOrderReference] = None,
    ip: _root_.scala.Option[String] = None,
    result: io.flow.payment.v0.models.AuthorizationResult,
    createdAt: _root_.org.joda.time.DateTime,
    expiresAt: _root_.scala.Option[_root_.org.joda.time.DateTime] = None,
    base: _root_.scala.Option[io.flow.common.v0.models.Money] = None
  ) extends Authorization

  /**
   * Details for why a payment failed
   */
  final case class PaymentError(
    code: String = "payment_error",
    messages: Seq[String],
    codes: Seq[io.flow.payment.v0.models.PaymentErrorCode]
  )

  /**
   * Represents an online payment processed through PayPal.
   * 
   * @param order If this authorization was made for a specific order number, that order will be
   *        referenced here.
   * @param amount The amount to authorize
   * @param currency The ISO 4217-3 code for the currency. Case insensitive. See
   *        https://api.flow.io/reference/currencies
   * @param paypal Specific data from PayPal.
   */
  @deprecated("Remove after paypal_authorization_details goes live.")
  final case class PaymentPaypal(
    id: String,
    order: _root_.scala.Option[io.flow.payment.v0.models.AuthorizationOrderReference] = None,
    amount: BigDecimal,
    currency: String,
    paypal: io.flow.payment.v0.models.PaymentPaypalData
  ) extends Payment

  /**
   * Represents on line payment
   * 
   * @param paymentId The payment ID in PayPal.
   */
  @deprecated("Remove after paypal_authorization_details goes live.")
  final case class PaymentPaypalData(
    paymentId: String
  )

  final case class PaymentReference(
    id: String
  )

  final case class PaymentVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    payment: io.flow.payment.v0.models.Payment
  )

  /**
   * Represents on line payment
   * 
   * @param paymentId The payment ID in paypal
   */
  final case class PaypalAuthorizationDetails(
    paymentId: String
  ) extends OnlineAuthorizationDetails

  /**
   * Executes the PayPal payment
   * 
   * @param paypalPaymentId The PayPal payment id
   * @param paypalPayerId The PayPal id of the person who is paying
   * @param key Your unique identifier for this transaction, which if provided is used to
   *        implement idempotency. If not provided, we will assign.
   * @param attributes A set of key/value pairs that you can attach to an authorization object
   * @param ip The IP address of the consumer
   */
  final case class PaypalAuthorizationForm(
    paypalPaymentId: String,
    paypalPayerId: String,
    key: _root_.scala.Option[String] = None,
    attributes: _root_.scala.Option[Map[String, String]] = None,
    ip: _root_.scala.Option[String] = None
  ) extends AuthorizationForm

  /**
   * The URLs to which the customer will be redirected based on the authorization
   * status.
   */
  final case class PostPaymentRedirectUrls(
    success: String,
    failure: _root_.scala.Option[String] = None
  )

  /**
   * A public key is used to encrypt cards client side prior to submitting to the
   * Flow vault.
   * 
   * @param id RSA Public Key, base 64 encoded
   */
  final case class PublicKey(
    id: String
  )

  /**
   * Represents an online payment that requires the user to redirect to another site
   * before entering their payment information.
   * 
   * @param id The id of the record containing expanded authorization details for this
   *        authorization.
   * @param paymentRedirectUrl The URL to which the customer should be redirected to complete payment.
   * @param confirmationDetails Confirmation details received from the redirect response
   */
  final case class RedirectAuthorizationDetails(
    id: String,
    paymentRedirectUrl: String,
    confirmationDetails: _root_.scala.Option[io.flow.payment.v0.models.ConfirmationDetails] = None
  ) extends OnlineAuthorizationDetails

  /**
   * Executes a redirect-based payment based on the provided payment method.
   * 
   * @param method The name (or brand code) of the redirect-based payment method for which to
   *        create an authorization, e.g. 'unionpay'.
   * @param issuer The id of the issuing bank, if required by the selected payment method. For
   *        payment methods such as iDEAL, the customer must select an issuer before being
   *        redirected to provide payment details.
   * @param orderNumber Client order number for which to authorize payment.
   * @param amount The amount to authorize.
   * @param currency The ISO 4217-3 code for the currency. Case insensitive. See
   *        https://api.flow.io/reference/currencies
   * @param redirectUrls The success and optional failure URLs to which the user will be redirected after
   *        completing (or failing to complete) payment.
   * @param key Your unique identifier for this transaction, which if provided is used to
   *        implement idempotency. If not provided, we will assign.
   * @param attributes A set of key/value pairs that you can attach to an authorization object
   * @param ip The IP address of the consumer
   */
  final case class RedirectAuthorizationForm(
    method: String,
    issuer: _root_.scala.Option[io.flow.payment.v0.models.IssuerReference] = None,
    orderNumber: String,
    amount: BigDecimal,
    currency: String,
    redirectUrls: io.flow.payment.v0.models.PostPaymentRedirectUrls,
    key: _root_.scala.Option[String] = None,
    attributes: _root_.scala.Option[Map[String, String]] = None,
    ip: _root_.scala.Option[String] = None
  ) extends AuthorizationForm

  /**
   * Refunds can be created against either a specific capture or an authorization (in
   * which case we will select 1 or more specific captures against which to execute
   * the refund).
   * 
   * @param amount The amount to refund in the currency of the associated capture
   * @param currency The ISO 4217-3 code for the currency. Case insensitive. See
   *        https://api.flow.io/reference/currencies
   * @param requested The amount/currency of the request to refund.
   * @param captures The specific captures and the amounts refunded against each to match the total
   *        refund amount.
   * @param attributes A set of key/value pairs that you can attach to a refund object
   * @param status Indicates the status of the refund.
   * @param base The amount/currency of the refund in base currency. Added in Summer 2018 and
   *        always present since then.
   */
  final case class Refund(
    id: String,
    key: String,
    authorization: io.flow.payment.v0.models.AuthorizationReference,
    amount: BigDecimal,
    currency: String,
    requested: _root_.scala.Option[io.flow.common.v0.models.Money] = None,
    captures: Seq[io.flow.payment.v0.models.RefundCaptureSummary],
    createdAt: _root_.org.joda.time.DateTime,
    attributes: _root_.scala.Option[Map[String, String]] = None,
    status: io.flow.payment.v0.models.RefundStatus = io.flow.payment.v0.models.RefundStatus.Succeeded,
    base: _root_.scala.Option[io.flow.common.v0.models.Money] = None
  )

  /**
   * Refund captures provide the detailed information on the amount refunded against
   * a specific capture
   * 
   * @param amount The amount refunded against this capture, in the currency of the refund
   * @param currency The ISO 4217-3 code for the currency. Case insensitive. See
   *        https://api.flow.io/reference/currencies
   * @param status Indicates the status of the refund capture.
   */
  final case class RefundCapture(
    id: String,
    refund: io.flow.payment.v0.models.Refund,
    capture: io.flow.payment.v0.models.Capture,
    amount: BigDecimal,
    currency: String,
    base: io.flow.common.v0.models.Money,
    status: io.flow.payment.v0.models.RefundStatus = io.flow.payment.v0.models.RefundStatus.Succeeded
  )

  /**
   * Refund captures provide the detailed information on the amount refunded against
   * a specific capture
   * 
   * @param amount The amount refunded against this capture, in the currency of the refund
   */
  final case class RefundCaptureSummary(
    capture: io.flow.payment.v0.models.Capture,
    amount: BigDecimal
  )

  /**
   * @param code To maintain compatibility with generic_error
   * @param messages To maintain compatibility with generic_error
   * @param declineCode Contains details related to the reason for which a refund failed.
   */
  final case class RefundError(
    code: io.flow.error.v0.models.GenericErrorCode = io.flow.error.v0.models.GenericErrorCode.GenericError,
    messages: Seq[String],
    declineCode: io.flow.payment.v0.models.RefundDeclineCode
  )

  /**
   * Refund actually transfers funds. You can refund as many times as you'd like up
   * until the total amount of captured funds has been refunded. Note when creating a
   * refund you can specify either an order authorization id, a capture id, or an
   * order number (or all of them as long as they match).
   * 
   * @param authorizationId The Id of the authorization against which to issue the refund. If specified, we
   *        will look at all captures for this authorization, selecting 1 or more captures
   *        against which to issue the refund of the requested amount.
   * @param captureId The Id of the capture against which to issue the refund. If specified, we will
   *        only consider this capture.
   * @param orderNumber The order number if specified during authorization. If specified, we will lookup
   *        all authorizations made against this order number, and then selecting 1 or more
   *        authorizations against which to issue the refund of the requested amount.
   * @param key Your unique identifier for this transaction, which if provided is used to
   *        implement idempotency. If not provided, we will assign.
   * @param amount The amount to refund, in the currency of the associated capture. Defaults to the
   *        value of the capture minus any prior refunds.
   * @param currency The ISO 4217-3 code for the currency. Required if amount is specified. Case
   *        insensitive. Note you will get an error if the currency does not match the
   *        related authorization's currency. See https://api.flow.io/reference/currencies
   * @param rmaKey The RMA key, if available. If specified, this will update the RMA status as
   *        refunded.
   * @param attributes A set of key/value pairs that you can attach to a refund object
   */
  final case class RefundForm(
    authorizationId: _root_.scala.Option[String] = None,
    captureId: _root_.scala.Option[String] = None,
    orderNumber: _root_.scala.Option[String] = None,
    key: _root_.scala.Option[String] = None,
    amount: _root_.scala.Option[BigDecimal] = None,
    currency: _root_.scala.Option[String] = None,
    rmaKey: _root_.scala.Option[String] = None,
    attributes: _root_.scala.Option[Map[String, String]] = None
  )

  final case class RefundIdentifier(
    id: String,
    refund: io.flow.payment.v0.models.RefundReference,
    identifier: String,
    primary: Boolean
  )

  /**
   * For merchant of record authorizations, we provide a summary of refund
   * information primarily to support customer service workflow.
   * 
   * @param orderNumber Client order number
   * @param currency The ISO 4217-3 code for the currency. Case insensitive. See
   *        https://api.flow.io/reference/currencies
   * @param captured The total amount of funds captured for this order. If there were multiple
   *        captures, this number will include the sum of the amounts captured.
   * @param refunded The total amount of refunds issued for this order. If there were multiple
   *        refunds, this number will include the sum of the amounts refunded.
   * @param amounts Suggested amounts to refund based on the most common use cases
   */
  final case class RefundOrderSummary(
    orderNumber: String,
    currency: String,
    captured: BigDecimal,
    refunded: BigDecimal,
    amounts: io.flow.payment.v0.models.RefundOrderSummaryAmounts
  )

  /**
   * Detailed examples of amount to refund following common e-commerce use cases.
   * 
   * @param balance The total amount of funds available to refund (sum of all captures minus all
   *        prior refunds).
   * @param balanceExcludingShipping The balance minus shipping costs. If there was either no shipping cost or the
   *        remaining balance is less than the shipping cost, this field will not be
   *        provided.
   * @param shipping The total amount of shipping on the order, if there was a shipping fee. We
   *        highlight this value separately to simplify use cases where a full refund minus
   *        shipping is used.
   */
  final case class RefundOrderSummaryAmounts(
    balance: BigDecimal,
    balanceExcludingShipping: _root_.scala.Option[BigDecimal] = None,
    shipping: _root_.scala.Option[BigDecimal] = None
  )

  final case class RefundReference(
    id: String,
    key: String
  )

  final case class RefundVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    refund: io.flow.payment.v0.models.Refund
  )

  /**
   * A reversal is used to clear an authorization (full or partial).
   * 
   * @param authorization The authorization that this reversal undoes
   * @param amount The amount reversed
   * @param currency The ISO 4217-3 code for the currency. Case insensitive. See
   *        https://api.flow.io/reference/currencies
   * @param requested The requested amount/currency of the capture when created. We record this value
   *        as it will be converted to the currency of the authorization automatically if it
   *        does not match.
   * @param attributes A set of key/value pairs that you can attach to a reversal object
   * @param base The amount/currency of the reversal in base currency. Added in Summer 2018 and
   *        always present since then.
   */
  final case class Reversal(
    id: String,
    key: String,
    authorization: io.flow.payment.v0.models.AuthorizationReference,
    status: io.flow.payment.v0.models.ReversalStatus,
    amount: BigDecimal,
    currency: String,
    requested: io.flow.common.v0.models.Money,
    createdAt: _root_.org.joda.time.DateTime,
    attributes: Map[String, String],
    base: _root_.scala.Option[io.flow.common.v0.models.Money] = None
  )

  /**
   * Details for why a reversal could not be created
   */
  final case class ReversalError(
    code: String = "reversal_error",
    messages: Seq[String],
    codes: Seq[io.flow.payment.v0.models.ReversalErrorCode]
  )

  /**
   * @param key Your unique identifier for this transaction, which if provided is used to
   *        implement idempotency. If not provided, we will assign.
   * @param authorizationId The ID of the authorization to reverse.
   * @param amount The amount to reverse. If not specified, reverse the full or remaining amount.
   * @param currency The ISO 4217-3 code for the currency to reverse. Required if amount is provided.
   *        Case insensitive. See https://api.flow.io/reference/currencies
   * @param attributes A set of key/value pairs that you can attach to a reversal object
   */
  final case class ReversalForm(
    key: _root_.scala.Option[String] = None,
    authorizationId: String,
    amount: _root_.scala.Option[BigDecimal] = None,
    currency: _root_.scala.Option[String] = None,
    attributes: _root_.scala.Option[Map[String, String]] = None
  )

  /**
   * @param authorizationId The ID of the authorization to reverse.
   * @param amount The amount to reverse. If not specified, reverse the full or remaining amount.
   * @param currency The ISO 4217-3 code for the currency to reverse. Required if amount is provided.
   *        Case insensitive. See https://api.flow.io/reference/currencies
   * @param attributes A set of key/value pairs that you can attach to a reversal object
   */
  final case class ReversalPutForm(
    authorizationId: String,
    amount: _root_.scala.Option[BigDecimal] = None,
    currency: _root_.scala.Option[String] = None,
    attributes: _root_.scala.Option[Map[String, String]] = None
  )

  final case class ReversalVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    reversal: io.flow.payment.v0.models.Reversal
  )

  /**
   * Stripe authentication data.
   * 
   * @param secretKeyReference Reference to Stripe API secret key.
   */
  final case class StripeAuthenticationData(
    secretKeyReference: String
  ) extends GatewayAuthenticationData

  /**
   * Used to specify Stripe API secret key.
   * 
   * @param accountId Stripe account id.
   * @param secretKey Stripe API secret key.
   */
  final case class StripeAuthenticationDataForm(
    accountId: String,
    secretKey: String
  ) extends GatewayAuthenticationDataForm

  /**
   * Represents the results from 3D Secure, if applied to an authorization
   */
  final case class ThreeDSecure(
    code: io.flow.payment.v0.models.ThreeDSecureCode,
    description: _root_.scala.Option[String] = None
  )

  /**
   * Virtual credit cards are created for a specific limit and currency. Currently
   * only USD denominated cards can be issued. Once created the virtual card can be
   * used in the same way as a physical credit card using the card number, cvv and
   * expiration details.
   * 
   * @param id Globally unique identifier generated by Flow for this virtual card.
   * @param key Your unique identifier for this transaction, which if provided is used to
   *        implement idempotency.
   * @param number The actual card number. This will be populated on the first request but not
   *        returned for subsequent requests for the same card. The card number is not
   *        persisted to maintain PCI compliance.
   * @param cvv The short card verification value. This will be populated on the first request
   *        but not returned for subsequent requests for the same card. The cvv is not
   *        persisted to maintain PCI compliance.
   * @param limit The virtual card limit amount in USD.
   * @param `type` The virtual card brand type.
   * @param expiration The expiry date as would be displayed on the card. Note that internally the card
   *        may be valid for a shorter period of time.
   * @param iin The issuer identification number (IIN) (formerly known as the Bank
   *        Identification Number) which are the leading digits of the card number.
   * @param last4 Cleartext last 4 numbers of the card
   * @param name Cardholder name
   * @param attributes A set of key/value pairs that you can attach to a virtual card object
   */
  final case class VirtualCard(
    id: String,
    key: String,
    number: _root_.scala.Option[String] = None,
    cvv: _root_.scala.Option[String] = None,
    limit: io.flow.common.v0.models.Price,
    `type`: io.flow.payment.v0.models.CardType,
    expiration: io.flow.payment.v0.models.Expiration,
    iin: String,
    last4: String,
    name: String,
    attributes: _root_.scala.Option[Map[String, String]] = None
  )

  /**
   * Payment has been captured for the virtual credit card
   * 
   * @param issuer The virtual credit card issuing bank details.
   * @param virtualCard Flows reference identifier for the virtual credit card.
   * @param authorization Flows payment authorization details.
   * @param amount The amount of the virtual card capture in the specified currency.
   * @param currency The ISO 4217-3 code for the currency. See
   *        https://api.flow.io/reference/currencies
   */
  final case class VirtualCardCapture(
    id: String,
    issuer: io.flow.payment.v0.models.IssuerV1,
    virtualCard: io.flow.payment.v0.models.VirtualCardReference,
    authorization: io.flow.payment.v0.models.AuthorizationReference,
    amount: BigDecimal,
    currency: String,
    createdAt: _root_.org.joda.time.DateTime
  )

  final case class VirtualCardCaptureVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    virtualCardCapture: io.flow.payment.v0.models.VirtualCardCapture
  )

  /**
   * @param limit The requested limit of the card
   * @param attributes A set of key/value pairs that you can attach to a virtual card object
   */
  final case class VirtualCardForm(
    limit: io.flow.common.v0.models.Money,
    attributes: _root_.scala.Option[Map[String, String]] = None
  )

  /**
   * Flows reference identifier for the virtual credit card.
   */
  final case class VirtualCardReference(
    id: String
  )

  /**
   * A refund has been issued for the virtual credit card
   * 
   * @param issuer The virtual credit card issuing bank details.
   * @param virtualCard Flows reference identifier for the virtual credit card.
   * @param authorization Flows payment authorization details.
   * @param amount The amount of the virtual card refund in the specified currency
   * @param currency The ISO 4217-3 code for the currency. See
   *        https://api.flow.io/reference/currencies
   */
  final case class VirtualCardRefund(
    id: String,
    issuer: io.flow.payment.v0.models.IssuerV1,
    virtualCard: io.flow.payment.v0.models.VirtualCardReference,
    authorization: io.flow.payment.v0.models.AuthorizationReference,
    amount: BigDecimal,
    currency: String,
    createdAt: _root_.org.joda.time.DateTime
  )

  final case class VirtualCardRefundVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    virtualCardRefund: io.flow.payment.v0.models.VirtualCardRefund
  )

  final case class VirtualCardVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    virtualCard: io.flow.payment.v0.models.VirtualCard
  )

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union Authorization, it will need to be handled in the client code. This
   * implementation will deserialize these future types as an instance of this class.
   * 
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  final case class AuthorizationUndefinedType(
    description: String
  ) extends Authorization

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union AuthorizationForm, it will need to be handled in the client code.
   * This implementation will deserialize these future types as an instance of this
   * class.
   * 
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  final case class AuthorizationFormUndefinedType(
    description: String
  ) extends AuthorizationForm

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union AuthorizationPayloadParameters, it will need to be handled in the
   * client code. This implementation will deserialize these future types as an
   * instance of this class.
   * 
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  final case class AuthorizationPayloadParametersUndefinedType(
    description: String
  ) extends AuthorizationPayloadParameters

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union AuthorizationResultAction, it will need to be handled in the client
   * code. This implementation will deserialize these future types as an instance of
   * this class.
   * 
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  final case class AuthorizationResultActionUndefinedType(
    description: String
  ) extends AuthorizationResultAction

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union ConfirmationDetails, it will need to be handled in the client code.
   * This implementation will deserialize these future types as an instance of this
   * class.
   * 
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  final case class ConfirmationDetailsUndefinedType(
    description: String
  ) extends ConfirmationDetails

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union ExpandableCard, it will need to be handled in the client code. This
   * implementation will deserialize these future types as an instance of this class.
   * 
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  final case class ExpandableCardUndefinedType(
    description: String
  ) extends ExpandableCard

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union GatewayAuthenticationData, it will need to be handled in the client
   * code. This implementation will deserialize these future types as an instance of
   * this class.
   * 
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  final case class GatewayAuthenticationDataUndefinedType(
    description: String
  ) extends GatewayAuthenticationData

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union GatewayAuthenticationDataForm, it will need to be handled in the
   * client code. This implementation will deserialize these future types as an
   * instance of this class.
   * 
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  final case class GatewayAuthenticationDataFormUndefinedType(
    description: String
  ) extends GatewayAuthenticationDataForm

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union OnlineAuthorizationDetails, it will need to be handled in the
   * client code. This implementation will deserialize these future types as an
   * instance of this class.
   * 
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  final case class OnlineAuthorizationDetailsUndefinedType(
    description: String
  ) extends OnlineAuthorizationDetails

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union Payment, it will need to be handled in the client code. This
   * implementation will deserialize these future types as an instance of this class.
   * 
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  final case class PaymentUndefinedType(
    description: String
  ) extends Payment

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union PaymentForm, it will need to be handled in the client code. This
   * implementation will deserialize these future types as an instance of this class.
   * 
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  final case class PaymentFormUndefinedType(
    description: String
  ) extends PaymentForm

  /**
   * Contains details related to the reason for which an authorization was declined.
   */
  sealed trait AuthorizationDeclineCode extends _root_.scala.Product with _root_.scala.Serializable

  object AuthorizationDeclineCode {

    /**
     * Payment method has expired
     */
    case object Expired extends AuthorizationDeclineCode { override def toString = "expired" }
    /**
     * Invalid card holder name
     */
    case object InvalidName extends AuthorizationDeclineCode { override def toString = "invalid_name" }
    /**
     * Invalid payment number
     */
    case object InvalidNumber extends AuthorizationDeclineCode { override def toString = "invalid_number" }
    /**
     * Invalid expiration date
     */
    case object InvalidExpiration extends AuthorizationDeclineCode { override def toString = "invalid_expiration" }
    /**
     * Invalid billing address
     */
    case object InvalidAddress extends AuthorizationDeclineCode { override def toString = "invalid_address" }
    /**
     * Cannot create a permanent card via an unauthorized request
     */
    case object InvalidTokenType extends AuthorizationDeclineCode { override def toString = "invalid_token_type" }
    /**
     * The provided card token is invalid or it does not exist.
     */
    case object InvalidToken extends AuthorizationDeclineCode { override def toString = "invalid_token" }
    /**
     * The provided payment method is not known by the issuing bank (the account does
     * not exist)
     */
    case object NoAccount extends AuthorizationDeclineCode { override def toString = "no_account" }
    /**
     * Declined due to avs mismatch)
     */
    case object Avs extends AuthorizationDeclineCode { override def toString = "avs" }
    /**
     * Declined due to cvv mismatch)
     */
    case object Cvv extends AuthorizationDeclineCode { override def toString = "cvv" }
    /**
     * Declined due to suspected fraud
     */
    case object Fraud extends AuthorizationDeclineCode { override def toString = "fraud" }
    /**
     * Declined due to suspected duplicate transaction
     */
    case object Duplicate extends AuthorizationDeclineCode { override def toString = "duplicate" }
    /**
     * Declined as payment method is not supported
     */
    case object NotSupported extends AuthorizationDeclineCode { override def toString = "not_supported" }
    /**
     * Declined due to another reason (details not known)
     */
    case object Unknown extends AuthorizationDeclineCode { override def toString = "unknown" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends AuthorizationDeclineCode

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[AuthorizationDeclineCode] = scala.List(Expired, InvalidName, InvalidNumber, InvalidExpiration, InvalidAddress, InvalidTokenType, InvalidToken, NoAccount, Avs, Cvv, Fraud, Duplicate, NotSupported, Unknown)

    private[this]
    val byName: Map[String, AuthorizationDeclineCode] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): AuthorizationDeclineCode = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[AuthorizationDeclineCode] = byName.get(value.toLowerCase)

  }

  /**
   * Specifies optional behaviors that can be applied during an authorization
   */
  sealed trait AuthorizationOption extends _root_.scala.Product with _root_.scala.Serializable

  object AuthorizationOption {

    /**
     * If set, and the authorization is created using a one time nonce, we
     * automatically tokenize and store the card. In these cases you will want to store
     * the new card token in the authorization response (card object)
     */
    case object StoreCard extends AuthorizationOption { override def toString = "store_card" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends AuthorizationOption

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[AuthorizationOption] = scala.List(StoreCard)

    private[this]
    val byName: Map[String, AuthorizationOption] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): AuthorizationOption = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[AuthorizationOption] = byName.get(value.toLowerCase)

  }

  /**
   * Specifies an action necessary to continue processing the authorization, such as
   * redirecting to a payment issuer to complete user verification.
   */
  sealed trait AuthorizationResultActionType extends _root_.scala.Product with _root_.scala.Serializable

  object AuthorizationResultActionType {

    /**
     * Indicates that the user should be redirected to the provided URL.
     */
    case object Redirect extends AuthorizationResultActionType { override def toString = "redirect" }
    /**
     * Indicates that more time is needed before the authorization result is known. In
     * the case of 3D Secure, this means the authorization status should be polled
     * until it is no longer pending.
     */
    case object Wait extends AuthorizationResultActionType { override def toString = "wait" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends AuthorizationResultActionType

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[AuthorizationResultActionType] = scala.List(Redirect, Wait)

    private[this]
    val byName: Map[String, AuthorizationResultActionType] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): AuthorizationResultActionType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[AuthorizationResultActionType] = byName.get(value.toLowerCase)

  }

  sealed trait AuthorizationStatus extends _root_.scala.Product with _root_.scala.Serializable

  object AuthorizationStatus {

    /**
     * If an immediate response is not available, the state will be 'pending'. For
     * example, online payment methods like AliPay or PayPal will have a status of
     * 'pending' until the user completes the payment. Pending authorizations expire if
     * the user does not complete the payment in a timely fashion.
     */
    case object Pending extends AuthorizationStatus { override def toString = "pending" }
    /**
     * Authorization has expired.
     */
    case object Expired extends AuthorizationStatus { override def toString = "expired" }
    /**
     * Authorization was successful
     */
    case object Authorized extends AuthorizationStatus { override def toString = "authorized" }
    /**
     * If an immediate response is not available, the state will be 'review' - this
     * usually indicates fraud review requires additional time / verification (or a
     * potential network issue with the issuing bank)
     */
    case object Review extends AuthorizationStatus { override def toString = "review" }
    /**
     * Indicates the authorization has been declined by the issuing bank. See the
     * authorization decline code for more details as to the reason for decline.
     */
    case object Declined extends AuthorizationStatus { override def toString = "declined" }
    /**
     * Indicates the authorization has been fully reversed. You can fully reverse an
     * authorization up until the moment you capture funds; once you have captured
     * funds you must create refunds.
     */
    case object Reversed extends AuthorizationStatus { override def toString = "reversed" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends AuthorizationStatus

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[AuthorizationStatus] = scala.List(Pending, Expired, Authorized, Review, Declined, Reversed)

    private[this]
    val byName: Map[String, AuthorizationStatus] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): AuthorizationStatus = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[AuthorizationStatus] = byName.get(value.toLowerCase)

  }

  sealed trait AvsCode extends _root_.scala.Product with _root_.scala.Serializable

  object AvsCode {

    /**
     * Full match
     */
    case object Match extends AvsCode { override def toString = "match" }
    /**
     * Partial match; see details in 'avs' model to understand which components matched
     */
    case object Partial extends AvsCode { override def toString = "partial" }
    /**
     * Issuer does not support address verification
     */
    case object Unsupported extends AvsCode { override def toString = "unsupported" }
    /**
     * Address does not match expected card values
     */
    case object NoMatch extends AvsCode { override def toString = "no_match" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends AvsCode

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[AvsCode] = scala.List(Match, Partial, Unsupported, NoMatch)

    private[this]
    val byName: Map[String, AvsCode] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): AvsCode = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[AvsCode] = byName.get(value.toLowerCase)

  }

  /**
   * Contains details related to the reason for which a capture failed.
   */
  sealed trait CaptureDeclineCode extends _root_.scala.Product with _root_.scala.Serializable

  object CaptureDeclineCode {

    /**
     * Payment authorization has expired
     */
    case object Expired extends CaptureDeclineCode { override def toString = "expired" }
    /**
     * The amount to capture exceeded the amount authorized and not yet captured
     */
    case object InsufficientFunds extends CaptureDeclineCode { override def toString = "insufficient_funds" }
    /**
     * Failed due to another reason (details not known)
     */
    case object Unknown extends CaptureDeclineCode { override def toString = "unknown" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends CaptureDeclineCode

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[CaptureDeclineCode] = scala.List(Expired, InsufficientFunds, Unknown)

    private[this]
    val byName: Map[String, CaptureDeclineCode] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): CaptureDeclineCode = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[CaptureDeclineCode] = byName.get(value.toLowerCase)

  }

  sealed trait CaptureStatus extends _root_.scala.Product with _root_.scala.Serializable

  object CaptureStatus {

    /**
     * The capture has been initiated and requires time to complete.
     */
    case object Pending extends CaptureStatus { override def toString = "pending" }
    /**
     * The capture has been processed successfully.
     */
    case object Succeeded extends CaptureStatus { override def toString = "succeeded" }
    /**
     * The capture failed to process.
     */
    case object Failed extends CaptureStatus { override def toString = "failed" }
    /**
     * The capture was canceled.
     */
    case object Canceled extends CaptureStatus { override def toString = "canceled" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends CaptureStatus

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[CaptureStatus] = scala.List(Pending, Succeeded, Failed, Canceled)

    private[this]
    val byName: Map[String, CaptureStatus] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): CaptureStatus = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[CaptureStatus] = byName.get(value.toLowerCase)

  }

  sealed trait CardErrorCode extends _root_.scala.Product with _root_.scala.Serializable

  object CardErrorCode {

    /**
     * Invalid billing address
     */
    case object InvalidAddress extends CardErrorCode { override def toString = "invalid_address" }
    /**
     * Invalid cardholder name
     */
    case object InvalidName extends CardErrorCode { override def toString = "invalid_name" }
    /**
     * Invalid payment number
     */
    case object InvalidNumber extends CardErrorCode { override def toString = "invalid_number" }
    /**
     * Invalid expiration date
     */
    case object InvalidExpiration extends CardErrorCode { override def toString = "invalid_expiration" }
    /**
     * Cannot create a permanent card via an unauthorized request
     */
    case object InvalidTokenType extends CardErrorCode { override def toString = "invalid_token_type" }
    /**
     * Declined due to avs mismatch
     */
    case object Avs extends CardErrorCode { override def toString = "avs" }
    /**
     * Declined due to cvv mismatch
     */
    case object Cvv extends CardErrorCode { override def toString = "cvv" }
    /**
     * Declined due to suspected fraud
     */
    case object Fraud extends CardErrorCode { override def toString = "fraud" }
    /**
     * Declined due to another reason (details not known)
     */
    case object Unknown extends CardErrorCode { override def toString = "unknown" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends CardErrorCode

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[CardErrorCode] = scala.List(InvalidAddress, InvalidName, InvalidNumber, InvalidExpiration, InvalidTokenType, Avs, Cvv, Fraud, Unknown)

    private[this]
    val byName: Map[String, CardErrorCode] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): CardErrorCode = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[CardErrorCode] = byName.get(value.toLowerCase)

  }

  sealed trait CardType extends _root_.scala.Product with _root_.scala.Serializable

  object CardType {

    case object AmericanExpress extends CardType { override def toString = "american_express" }
    case object CartesBancaires extends CardType { override def toString = "cartes_bancaires" }
    case object ChinaUnionPay extends CardType { override def toString = "china_union_pay" }
    case object Dankort extends CardType { override def toString = "dankort" }
    case object DinersClub extends CardType { override def toString = "diners_club" }
    case object Discover extends CardType { override def toString = "discover" }
    case object Jcb extends CardType { override def toString = "jcb" }
    case object Maestro extends CardType { override def toString = "maestro" }
    case object Mastercard extends CardType { override def toString = "mastercard" }
    case object Visa extends CardType { override def toString = "visa" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends CardType

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[CardType] = scala.List(AmericanExpress, CartesBancaires, ChinaUnionPay, Dankort, DinersClub, Discover, Jcb, Maestro, Mastercard, Visa)

    private[this]
    val byName: Map[String, CardType] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): CardType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[CardType] = byName.get(value.toLowerCase)

  }

  sealed trait CvvCode extends _root_.scala.Product with _root_.scala.Serializable

  object CvvCode {

    /**
     * CVV matches
     */
    case object Match extends CvvCode { override def toString = "match" }
    /**
     * CVV did not match; Transaction is possibly fraudulent
     */
    case object Suspicious extends CvvCode { override def toString = "suspicious" }
    /**
     * CVV did not match; Issuer does not support card verification numbers
     */
    case object Unsupported extends CvvCode { override def toString = "unsupported" }
    /**
     * CVV did not match; Specific reason not available
     */
    case object NoMatch extends CvvCode { override def toString = "no_match" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends CvvCode

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[CvvCode] = scala.List(Match, Suspicious, Unsupported, NoMatch)

    private[this]
    val byName: Map[String, CvvCode] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): CvvCode = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[CvvCode] = byName.get(value.toLowerCase)

  }

  sealed trait PaymentErrorCode extends _root_.scala.Product with _root_.scala.Serializable

  object PaymentErrorCode {

    case object Duplicate extends PaymentErrorCode { override def toString = "duplicate" }
    /**
     * Amount is not valid (e.g. for merchant of record payments, the amount specified
     * must match the order). This typically is handled by refreshing the order amount
     * and reconfirming with the user as something has changed.
     */
    case object InvalidAmount extends PaymentErrorCode { override def toString = "invalid_amount" }
    /**
     * Currency is either not known or invalid (e.g. for merchant of record payments,
     * the currency specified must match the order).
     */
    case object InvalidCurrency extends PaymentErrorCode { override def toString = "invalid_currency" }
    /**
     * Invalid payment method
     */
    case object InvalidMethod extends PaymentErrorCode { override def toString = "invalid_method" }
    /**
     * The specified order number was not found
     */
    case object InvalidOrder extends PaymentErrorCode { override def toString = "invalid_order" }
    /**
     * Customer information is invalid (e.g. email specified but not a valid email)
     */
    case object InvalidCustomer extends PaymentErrorCode { override def toString = "invalid_customer" }
    /**
     * Destination/shipping address is not valid
     */
    case object InvalidDestination extends PaymentErrorCode { override def toString = "invalid_destination" }
    /**
     * Failed due to another reason (details not known)
     */
    case object Unknown extends PaymentErrorCode { override def toString = "unknown" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends PaymentErrorCode

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[PaymentErrorCode] = scala.List(Duplicate, InvalidAmount, InvalidCurrency, InvalidMethod, InvalidOrder, InvalidCustomer, InvalidDestination, Unknown)

    private[this]
    val byName: Map[String, PaymentErrorCode] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): PaymentErrorCode = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[PaymentErrorCode] = byName.get(value.toLowerCase)

  }

  /**
   * Contains details related to the reason for which a refund failed.
   */
  sealed trait RefundDeclineCode extends _root_.scala.Product with _root_.scala.Serializable

  object RefundDeclineCode {

    /**
     * All associated payment captures have expired; refunds can no longer be issued
     */
    case object Expired extends RefundDeclineCode { override def toString = "expired" }
    /**
     * The requested refund amount exceeded the amount of remaining unrefunded funds
     */
    case object InsufficientFunds extends RefundDeclineCode { override def toString = "insufficient_funds" }
    /**
     * Failed due to another reason (details not known)
     */
    case object Unknown extends RefundDeclineCode { override def toString = "unknown" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends RefundDeclineCode

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[RefundDeclineCode] = scala.List(Expired, InsufficientFunds, Unknown)

    private[this]
    val byName: Map[String, RefundDeclineCode] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): RefundDeclineCode = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[RefundDeclineCode] = byName.get(value.toLowerCase)

  }

  sealed trait RefundStatus extends _root_.scala.Product with _root_.scala.Serializable

  object RefundStatus {

    /**
     * The refund has been initiated and requires time to complete.
     */
    case object Pending extends RefundStatus { override def toString = "pending" }
    /**
     * The refund has been processed successfully.
     */
    case object Succeeded extends RefundStatus { override def toString = "succeeded" }
    /**
     * The refund failed to process.
     */
    case object Failed extends RefundStatus { override def toString = "failed" }
    /**
     * The refund was canceled.
     */
    case object Canceled extends RefundStatus { override def toString = "canceled" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends RefundStatus

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[RefundStatus] = scala.List(Pending, Succeeded, Failed, Canceled)

    private[this]
    val byName: Map[String, RefundStatus] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): RefundStatus = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[RefundStatus] = byName.get(value.toLowerCase)

  }

  sealed trait ReversalErrorCode extends _root_.scala.Product with _root_.scala.Serializable

  object ReversalErrorCode {

    /**
     * Amount specified exceeds the remaining authorization balance.
     */
    case object AmountExceedsBalance extends ReversalErrorCode { override def toString = "amount_exceeds_balance" }
    /**
     * The authorization was initially declined; there is nothing to reverse.
     */
    case object AuthorizationDeclined extends ReversalErrorCode { override def toString = "authorization_declined" }
    /**
     * The authorization has expired and can no longer be reversed.
     */
    case object AuthorizationExpired extends ReversalErrorCode { override def toString = "authorization_expired" }
    /**
     * The authorization was not found.
     */
    case object InvalidAuthorization extends ReversalErrorCode { override def toString = "invalid_authorization" }
    /**
     * Invalid key
     */
    case object InvalidKey extends ReversalErrorCode { override def toString = "invalid_key" }
    /**
     * Amount is not valid - usually because amount was <= 0
     */
    case object InvalidAmount extends ReversalErrorCode { override def toString = "invalid_amount" }
    /**
     * Currency is either not known or invalid
     */
    case object InvalidCurrency extends ReversalErrorCode { override def toString = "invalid_currency" }
    /**
     * The authorization has already been fully captured and/or reversed - there are no
     * additional funds to reverse.
     */
    case object NoRemainingBalance extends ReversalErrorCode { override def toString = "no_remaining_balance" }
    /**
     * Indicates a request for a partial reversal when the underlying processor does
     * not support it
     */
    case object PartialReversalNotSupported extends ReversalErrorCode { override def toString = "partial_reversal_not_supported" }
    /**
     * Unknown or other
     */
    case object Unknown extends ReversalErrorCode { override def toString = "unknown" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends ReversalErrorCode

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[ReversalErrorCode] = scala.List(AmountExceedsBalance, AuthorizationDeclined, AuthorizationExpired, InvalidAuthorization, InvalidKey, InvalidAmount, InvalidCurrency, NoRemainingBalance, PartialReversalNotSupported, Unknown)

    private[this]
    val byName: Map[String, ReversalErrorCode] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ReversalErrorCode = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ReversalErrorCode] = byName.get(value.toLowerCase)

  }

  sealed trait ReversalStatus extends _root_.scala.Product with _root_.scala.Serializable

  object ReversalStatus {

    /**
     * Reversal is pending processing.
     */
    case object Pending extends ReversalStatus { override def toString = "pending" }
    /**
     * Reversal has been processed successfully.
     */
    case object Processed extends ReversalStatus { override def toString = "processed" }
    /**
     * Reversal failed to process.
     */
    case object Failed extends ReversalStatus { override def toString = "failed" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends ReversalStatus

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[ReversalStatus] = scala.List(Pending, Processed, Failed)

    private[this]
    val byName: Map[String, ReversalStatus] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ReversalStatus = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ReversalStatus] = byName.get(value.toLowerCase)

  }

  sealed trait ThreeDSecureCode extends _root_.scala.Product with _root_.scala.Serializable

  object ThreeDSecureCode {

    case object Verified extends ThreeDSecureCode { override def toString = "verified" }
    case object NotVerified extends ThreeDSecureCode { override def toString = "not_verified" }
    case object Failed extends ThreeDSecureCode { override def toString = "failed" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends ThreeDSecureCode

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[ThreeDSecureCode] = scala.List(Verified, NotVerified, Failed)

    private[this]
    val byName: Map[String, ThreeDSecureCode] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ThreeDSecureCode = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ThreeDSecureCode] = byName.get(value.toLowerCase)

  }

  sealed trait TokenType extends _root_.scala.Product with _root_.scala.Serializable

  object TokenType {

    /**
     * Create a permanent token for the card (stored up until normal purge interval)
     */
    case object Permanent extends TokenType { override def toString = "permanent" }
    /**
     * Create a one time token for the card. This token can be used to either
     * authorized payment or later exchange for a permanent token. Once used, this
     * token cannot be used for future activity.
     */
    case object OneTime extends TokenType { override def toString = "one_time" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends TokenType

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[TokenType] = scala.List(Permanent, OneTime)

    private[this]
    val byName: Map[String, TokenType] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): TokenType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[TokenType] = byName.get(value.toLowerCase)

  }

}

package io.flow.payment.v0.models {

  package object json {
    import play.api.libs.json.__
    import play.api.libs.json.JsString
    import play.api.libs.json.Writes
    import play.api.libs.functional.syntax._
    import io.flow.common.v0.models.json._
    import io.flow.error.v0.models.json._
    import io.flow.payment.v0.models.json._
    import io.flow.permission.v0.models.json._
    import io.flow.reference.v0.models.json._

    private[v0] implicit val jsonReadsUUID = __.read[String].map { str =>
      _root_.java.util.UUID.fromString(str)
    }

    private[v0] implicit val jsonWritesUUID = new Writes[_root_.java.util.UUID] {
      def writes(x: _root_.java.util.UUID) = JsString(x.toString)
    }

    private[v0] implicit val jsonReadsJodaDateTime = __.read[String].map { str =>
      _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseDateTime(str)
    }

    private[v0] implicit val jsonWritesJodaDateTime = new Writes[_root_.org.joda.time.DateTime] {
      def writes(x: _root_.org.joda.time.DateTime) = {
        JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(x))
      }
    }

    private[v0] implicit val jsonReadsJodaLocalDate = __.read[String].map { str =>
      _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseLocalDate(str)
    }

    private[v0] implicit val jsonWritesJodaLocalDate = new Writes[_root_.org.joda.time.LocalDate] {
      def writes(x: _root_.org.joda.time.LocalDate) = {
        JsString(_root_.org.joda.time.format.ISODateTimeFormat.date.print(x))
      }
    }

    implicit val jsonReadsPaymentAuthorizationDeclineCode = new play.api.libs.json.Reads[io.flow.payment.v0.models.AuthorizationDeclineCode] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.payment.v0.models.AuthorizationDeclineCode] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.AuthorizationDeclineCode(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.AuthorizationDeclineCode(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesPaymentAuthorizationDeclineCode(obj: io.flow.payment.v0.models.AuthorizationDeclineCode) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectAuthorizationDeclineCode(obj: io.flow.payment.v0.models.AuthorizationDeclineCode) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesPaymentAuthorizationDeclineCode: play.api.libs.json.Writes[AuthorizationDeclineCode] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.AuthorizationDeclineCode] {
        def writes(obj: io.flow.payment.v0.models.AuthorizationDeclineCode) = {
          jsonWritesPaymentAuthorizationDeclineCode(obj)
        }
      }
    }

    implicit val jsonReadsPaymentAuthorizationOption = new play.api.libs.json.Reads[io.flow.payment.v0.models.AuthorizationOption] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.payment.v0.models.AuthorizationOption] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.AuthorizationOption(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.AuthorizationOption(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesPaymentAuthorizationOption(obj: io.flow.payment.v0.models.AuthorizationOption) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectAuthorizationOption(obj: io.flow.payment.v0.models.AuthorizationOption) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesPaymentAuthorizationOption: play.api.libs.json.Writes[AuthorizationOption] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.AuthorizationOption] {
        def writes(obj: io.flow.payment.v0.models.AuthorizationOption) = {
          jsonWritesPaymentAuthorizationOption(obj)
        }
      }
    }

    implicit val jsonReadsPaymentAuthorizationResultActionType = new play.api.libs.json.Reads[io.flow.payment.v0.models.AuthorizationResultActionType] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.payment.v0.models.AuthorizationResultActionType] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.AuthorizationResultActionType(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.AuthorizationResultActionType(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesPaymentAuthorizationResultActionType(obj: io.flow.payment.v0.models.AuthorizationResultActionType) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectAuthorizationResultActionType(obj: io.flow.payment.v0.models.AuthorizationResultActionType) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesPaymentAuthorizationResultActionType: play.api.libs.json.Writes[AuthorizationResultActionType] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.AuthorizationResultActionType] {
        def writes(obj: io.flow.payment.v0.models.AuthorizationResultActionType) = {
          jsonWritesPaymentAuthorizationResultActionType(obj)
        }
      }
    }

    implicit val jsonReadsPaymentAuthorizationStatus = new play.api.libs.json.Reads[io.flow.payment.v0.models.AuthorizationStatus] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.payment.v0.models.AuthorizationStatus] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.AuthorizationStatus(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.AuthorizationStatus(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesPaymentAuthorizationStatus(obj: io.flow.payment.v0.models.AuthorizationStatus) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectAuthorizationStatus(obj: io.flow.payment.v0.models.AuthorizationStatus) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesPaymentAuthorizationStatus: play.api.libs.json.Writes[AuthorizationStatus] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.AuthorizationStatus] {
        def writes(obj: io.flow.payment.v0.models.AuthorizationStatus) = {
          jsonWritesPaymentAuthorizationStatus(obj)
        }
      }
    }

    implicit val jsonReadsPaymentAvsCode = new play.api.libs.json.Reads[io.flow.payment.v0.models.AvsCode] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.payment.v0.models.AvsCode] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.AvsCode(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.AvsCode(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesPaymentAvsCode(obj: io.flow.payment.v0.models.AvsCode) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectAvsCode(obj: io.flow.payment.v0.models.AvsCode) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesPaymentAvsCode: play.api.libs.json.Writes[AvsCode] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.AvsCode] {
        def writes(obj: io.flow.payment.v0.models.AvsCode) = {
          jsonWritesPaymentAvsCode(obj)
        }
      }
    }

    implicit val jsonReadsPaymentCaptureDeclineCode = new play.api.libs.json.Reads[io.flow.payment.v0.models.CaptureDeclineCode] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.payment.v0.models.CaptureDeclineCode] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.CaptureDeclineCode(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.CaptureDeclineCode(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesPaymentCaptureDeclineCode(obj: io.flow.payment.v0.models.CaptureDeclineCode) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectCaptureDeclineCode(obj: io.flow.payment.v0.models.CaptureDeclineCode) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesPaymentCaptureDeclineCode: play.api.libs.json.Writes[CaptureDeclineCode] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.CaptureDeclineCode] {
        def writes(obj: io.flow.payment.v0.models.CaptureDeclineCode) = {
          jsonWritesPaymentCaptureDeclineCode(obj)
        }
      }
    }

    implicit val jsonReadsPaymentCaptureStatus = new play.api.libs.json.Reads[io.flow.payment.v0.models.CaptureStatus] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.payment.v0.models.CaptureStatus] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.CaptureStatus(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.CaptureStatus(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesPaymentCaptureStatus(obj: io.flow.payment.v0.models.CaptureStatus) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectCaptureStatus(obj: io.flow.payment.v0.models.CaptureStatus) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesPaymentCaptureStatus: play.api.libs.json.Writes[CaptureStatus] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.CaptureStatus] {
        def writes(obj: io.flow.payment.v0.models.CaptureStatus) = {
          jsonWritesPaymentCaptureStatus(obj)
        }
      }
    }

    implicit val jsonReadsPaymentCardErrorCode = new play.api.libs.json.Reads[io.flow.payment.v0.models.CardErrorCode] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.payment.v0.models.CardErrorCode] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.CardErrorCode(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.CardErrorCode(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesPaymentCardErrorCode(obj: io.flow.payment.v0.models.CardErrorCode) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectCardErrorCode(obj: io.flow.payment.v0.models.CardErrorCode) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesPaymentCardErrorCode: play.api.libs.json.Writes[CardErrorCode] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.CardErrorCode] {
        def writes(obj: io.flow.payment.v0.models.CardErrorCode) = {
          jsonWritesPaymentCardErrorCode(obj)
        }
      }
    }

    implicit val jsonReadsPaymentCardType = new play.api.libs.json.Reads[io.flow.payment.v0.models.CardType] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.payment.v0.models.CardType] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.CardType(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.CardType(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesPaymentCardType(obj: io.flow.payment.v0.models.CardType) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectCardType(obj: io.flow.payment.v0.models.CardType) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesPaymentCardType: play.api.libs.json.Writes[CardType] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.CardType] {
        def writes(obj: io.flow.payment.v0.models.CardType) = {
          jsonWritesPaymentCardType(obj)
        }
      }
    }

    implicit val jsonReadsPaymentCvvCode = new play.api.libs.json.Reads[io.flow.payment.v0.models.CvvCode] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.payment.v0.models.CvvCode] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.CvvCode(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.CvvCode(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesPaymentCvvCode(obj: io.flow.payment.v0.models.CvvCode) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectCvvCode(obj: io.flow.payment.v0.models.CvvCode) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesPaymentCvvCode: play.api.libs.json.Writes[CvvCode] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.CvvCode] {
        def writes(obj: io.flow.payment.v0.models.CvvCode) = {
          jsonWritesPaymentCvvCode(obj)
        }
      }
    }

    implicit val jsonReadsPaymentPaymentErrorCode = new play.api.libs.json.Reads[io.flow.payment.v0.models.PaymentErrorCode] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.payment.v0.models.PaymentErrorCode] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.PaymentErrorCode(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.PaymentErrorCode(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesPaymentPaymentErrorCode(obj: io.flow.payment.v0.models.PaymentErrorCode) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectPaymentErrorCode(obj: io.flow.payment.v0.models.PaymentErrorCode) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesPaymentPaymentErrorCode: play.api.libs.json.Writes[PaymentErrorCode] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.PaymentErrorCode] {
        def writes(obj: io.flow.payment.v0.models.PaymentErrorCode) = {
          jsonWritesPaymentPaymentErrorCode(obj)
        }
      }
    }

    implicit val jsonReadsPaymentRefundDeclineCode = new play.api.libs.json.Reads[io.flow.payment.v0.models.RefundDeclineCode] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.payment.v0.models.RefundDeclineCode] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.RefundDeclineCode(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.RefundDeclineCode(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesPaymentRefundDeclineCode(obj: io.flow.payment.v0.models.RefundDeclineCode) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectRefundDeclineCode(obj: io.flow.payment.v0.models.RefundDeclineCode) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesPaymentRefundDeclineCode: play.api.libs.json.Writes[RefundDeclineCode] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.RefundDeclineCode] {
        def writes(obj: io.flow.payment.v0.models.RefundDeclineCode) = {
          jsonWritesPaymentRefundDeclineCode(obj)
        }
      }
    }

    implicit val jsonReadsPaymentRefundStatus = new play.api.libs.json.Reads[io.flow.payment.v0.models.RefundStatus] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.payment.v0.models.RefundStatus] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.RefundStatus(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.RefundStatus(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesPaymentRefundStatus(obj: io.flow.payment.v0.models.RefundStatus) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectRefundStatus(obj: io.flow.payment.v0.models.RefundStatus) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesPaymentRefundStatus: play.api.libs.json.Writes[RefundStatus] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.RefundStatus] {
        def writes(obj: io.flow.payment.v0.models.RefundStatus) = {
          jsonWritesPaymentRefundStatus(obj)
        }
      }
    }

    implicit val jsonReadsPaymentReversalErrorCode = new play.api.libs.json.Reads[io.flow.payment.v0.models.ReversalErrorCode] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.payment.v0.models.ReversalErrorCode] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.ReversalErrorCode(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.ReversalErrorCode(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesPaymentReversalErrorCode(obj: io.flow.payment.v0.models.ReversalErrorCode) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectReversalErrorCode(obj: io.flow.payment.v0.models.ReversalErrorCode) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesPaymentReversalErrorCode: play.api.libs.json.Writes[ReversalErrorCode] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.ReversalErrorCode] {
        def writes(obj: io.flow.payment.v0.models.ReversalErrorCode) = {
          jsonWritesPaymentReversalErrorCode(obj)
        }
      }
    }

    implicit val jsonReadsPaymentReversalStatus = new play.api.libs.json.Reads[io.flow.payment.v0.models.ReversalStatus] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.payment.v0.models.ReversalStatus] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.ReversalStatus(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.ReversalStatus(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesPaymentReversalStatus(obj: io.flow.payment.v0.models.ReversalStatus) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectReversalStatus(obj: io.flow.payment.v0.models.ReversalStatus) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesPaymentReversalStatus: play.api.libs.json.Writes[ReversalStatus] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.ReversalStatus] {
        def writes(obj: io.flow.payment.v0.models.ReversalStatus) = {
          jsonWritesPaymentReversalStatus(obj)
        }
      }
    }

    implicit val jsonReadsPaymentThreeDSecureCode = new play.api.libs.json.Reads[io.flow.payment.v0.models.ThreeDSecureCode] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.payment.v0.models.ThreeDSecureCode] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.ThreeDSecureCode(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.ThreeDSecureCode(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesPaymentThreeDSecureCode(obj: io.flow.payment.v0.models.ThreeDSecureCode) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectThreeDSecureCode(obj: io.flow.payment.v0.models.ThreeDSecureCode) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesPaymentThreeDSecureCode: play.api.libs.json.Writes[ThreeDSecureCode] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.ThreeDSecureCode] {
        def writes(obj: io.flow.payment.v0.models.ThreeDSecureCode) = {
          jsonWritesPaymentThreeDSecureCode(obj)
        }
      }
    }

    implicit val jsonReadsPaymentTokenType = new play.api.libs.json.Reads[io.flow.payment.v0.models.TokenType] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.payment.v0.models.TokenType] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.TokenType(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.TokenType(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesPaymentTokenType(obj: io.flow.payment.v0.models.TokenType) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectTokenType(obj: io.flow.payment.v0.models.TokenType) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesPaymentTokenType: play.api.libs.json.Writes[TokenType] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.TokenType] {
        def writes(obj: io.flow.payment.v0.models.TokenType) = {
          jsonWritesPaymentTokenType(obj)
        }
      }
    }

    implicit def jsonReadsPaymentAchAuthorizationForm: play.api.libs.json.Reads[AchAuthorizationForm] = {
      for {
        accountOwnerName <- (__ \ "account_owner_name").read[String]
        accountNumber <- (__ \ "account_number").read[String]
        routingNumber <- (__ \ "routing_number").read[String]
        billingAddress <- (__ \ "billing_address").read[io.flow.common.v0.models.BillingAddress]
        orderNumber <- (__ \ "order_number").readNullable[String]
        amount <- (__ \ "amount").read[BigDecimal]
        currency <- (__ \ "currency").read[String]
        key <- (__ \ "key").readNullable[String]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
        ip <- (__ \ "ip").readNullable[String]
      } yield AchAuthorizationForm(accountOwnerName, accountNumber, routingNumber, billingAddress, orderNumber, amount, currency, key, attributes, ip)
    }

    def jsObjectAchAuthorizationForm(obj: io.flow.payment.v0.models.AchAuthorizationForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "account_owner_name" -> play.api.libs.json.JsString(obj.accountOwnerName),
        "account_number" -> play.api.libs.json.JsString(obj.accountNumber),
        "routing_number" -> play.api.libs.json.JsString(obj.routingNumber),
        "billing_address" -> io.flow.common.v0.models.json.jsObjectBillingAddress(obj.billingAddress),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "currency" -> play.api.libs.json.JsString(obj.currency)
      ) ++ (obj.orderNumber match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("order_number" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.key match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("key" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.ip match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("ip" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonReadsPaymentApplePayMerchantValidationPayload: play.api.libs.json.Reads[ApplePayMerchantValidationPayload] = {
      for {
        validationUrl <- (__ \ "validation_url").read[String]
        displayName <- (__ \ "display_name").readNullable[String]
      } yield ApplePayMerchantValidationPayload(validationUrl, displayName)
    }

    def jsObjectApplePayMerchantValidationPayload(obj: io.flow.payment.v0.models.ApplePayMerchantValidationPayload): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "validation_url" -> play.api.libs.json.JsString(obj.validationUrl)
      ) ++ (obj.displayName match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("display_name" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonReadsPaymentAuthorizationCopyForm: play.api.libs.json.Reads[AuthorizationCopyForm] = {
      for {
        sourceAuthorizationKey <- (__ \ "source_authorization_key").read[String]
        amount <- (__ \ "amount").read[BigDecimal]
        currency <- (__ \ "currency").read[String]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
      } yield AuthorizationCopyForm(sourceAuthorizationKey, amount, currency, attributes)
    }

    def jsObjectAuthorizationCopyForm(obj: io.flow.payment.v0.models.AuthorizationCopyForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "source_authorization_key" -> play.api.libs.json.JsString(obj.sourceAuthorizationKey),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "currency" -> play.api.libs.json.JsString(obj.currency)
      ) ++ (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonReadsPaymentAuthorizationError: play.api.libs.json.Reads[AuthorizationError] = {
      for {
        code <- (__ \ "code").read[io.flow.payment.v0.models.AuthorizationDeclineCode]
        messages <- (__ \ "messages").read[Seq[String]]
        avs <- (__ \ "avs").readNullable[io.flow.payment.v0.models.Avs]
        cvv <- (__ \ "cvv").readNullable[io.flow.payment.v0.models.Cvv]
      } yield AuthorizationError(code, messages, avs, cvv)
    }

    def jsObjectAuthorizationError(obj: io.flow.payment.v0.models.AuthorizationError): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "code" -> play.api.libs.json.JsString(obj.code.toString),
        "messages" -> play.api.libs.json.Json.toJson(obj.messages)
      ) ++ (obj.avs match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("avs" -> jsObjectAvs(x))
      }) ++
      (obj.cvv match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("cvv" -> jsObjectCvv(x))
      })
    }

    implicit def jsonWritesPaymentAuthorizationError: play.api.libs.json.Writes[AuthorizationError] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.AuthorizationError] {
        def writes(obj: io.flow.payment.v0.models.AuthorizationError) = {
          jsObjectAuthorizationError(obj)
        }
      }
    }

    implicit def jsonReadsPaymentAuthorizationOrderReference: play.api.libs.json.Reads[AuthorizationOrderReference] = {
      (__ \ "number").read[String].map { x => new AuthorizationOrderReference(number = x) }
    }

    def jsObjectAuthorizationOrderReference(obj: io.flow.payment.v0.models.AuthorizationOrderReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "number" -> play.api.libs.json.JsString(obj.number)
      )
    }

    implicit def jsonWritesPaymentAuthorizationOrderReference: play.api.libs.json.Writes[AuthorizationOrderReference] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.AuthorizationOrderReference] {
        def writes(obj: io.flow.payment.v0.models.AuthorizationOrderReference) = {
          jsObjectAuthorizationOrderReference(obj)
        }
      }
    }

    implicit def jsonReadsPaymentAuthorizationPayload: play.api.libs.json.Reads[AuthorizationPayload] = {
      (__ \ "parameters").read[io.flow.payment.v0.models.AuthorizationPayloadParameters].map { x => new AuthorizationPayload(parameters = x) }
    }

    def jsObjectAuthorizationPayload(obj: io.flow.payment.v0.models.AuthorizationPayload): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "parameters" -> jsObjectAuthorizationPayloadParameters(obj.parameters)
      )
    }

    implicit def jsonWritesPaymentAuthorizationPayload: play.api.libs.json.Writes[AuthorizationPayload] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.AuthorizationPayload] {
        def writes(obj: io.flow.payment.v0.models.AuthorizationPayload) = {
          jsObjectAuthorizationPayload(obj)
        }
      }
    }

    implicit def jsonReadsPaymentAuthorizationReference: play.api.libs.json.Reads[AuthorizationReference] = {
      for {
        id <- (__ \ "id").read[String]
        key <- (__ \ "key").read[String]
        order <- (__ \ "order").readNullable[io.flow.payment.v0.models.AuthorizationOrderReference]
      } yield AuthorizationReference(id, key, order)
    }

    def jsObjectAuthorizationReference(obj: io.flow.payment.v0.models.AuthorizationReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "key" -> play.api.libs.json.JsString(obj.key)
      ) ++ (obj.order match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("order" -> jsObjectAuthorizationOrderReference(x))
      })
    }

    implicit def jsonWritesPaymentAuthorizationReference: play.api.libs.json.Writes[AuthorizationReference] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.AuthorizationReference] {
        def writes(obj: io.flow.payment.v0.models.AuthorizationReference) = {
          jsObjectAuthorizationReference(obj)
        }
      }
    }

    implicit def jsonReadsPaymentAuthorizationResult: play.api.libs.json.Reads[AuthorizationResult] = {
      for {
        status <- (__ \ "status").read[io.flow.payment.v0.models.AuthorizationStatus]
        action <- (__ \ "action").readNullable[io.flow.payment.v0.models.AuthorizationResultAction]
        declineCode <- (__ \ "decline_code").readNullable[io.flow.payment.v0.models.AuthorizationDeclineCode]
        avs <- (__ \ "avs").readNullable[io.flow.payment.v0.models.Avs]
        cvv <- (__ \ "cvv").readNullable[io.flow.payment.v0.models.Cvv]
        threeDSecure <- (__ \ "three_d_secure").readNullable[io.flow.payment.v0.models.ThreeDSecure]
        description <- (__ \ "description").readNullable[io.flow.payment.v0.models.AuthorizationResultDescription]
      } yield AuthorizationResult(status, action, declineCode, avs, cvv, threeDSecure, description)
    }

    def jsObjectAuthorizationResult(obj: io.flow.payment.v0.models.AuthorizationResult): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "status" -> play.api.libs.json.JsString(obj.status.toString)
      ) ++ (obj.action match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("action" -> jsObjectAuthorizationResultAction(x))
      }) ++
      (obj.declineCode match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("decline_code" -> play.api.libs.json.JsString(x.toString))
      }) ++
      (obj.avs match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("avs" -> jsObjectAvs(x))
      }) ++
      (obj.cvv match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("cvv" -> jsObjectCvv(x))
      }) ++
      (obj.threeDSecure match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("three_d_secure" -> jsObjectThreeDSecure(x))
      }) ++
      (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> jsObjectAuthorizationResultDescription(x))
      })
    }

    implicit def jsonWritesPaymentAuthorizationResult: play.api.libs.json.Writes[AuthorizationResult] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.AuthorizationResult] {
        def writes(obj: io.flow.payment.v0.models.AuthorizationResult) = {
          jsObjectAuthorizationResult(obj)
        }
      }
    }

    implicit def jsonReadsPaymentAuthorizationResultActionGet: play.api.libs.json.Reads[AuthorizationResultActionGet] = {
      for {
        `type` <- (__ \ "type").read[io.flow.payment.v0.models.AuthorizationResultActionType]
        url <- (__ \ "url").readNullable[String]
      } yield AuthorizationResultActionGet(`type`, url)
    }

    def jsObjectAuthorizationResultActionGet(obj: io.flow.payment.v0.models.AuthorizationResultActionGet): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "type" -> play.api.libs.json.JsString(obj.`type`.toString)
      ) ++ (obj.url match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("url" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonReadsPaymentAuthorizationResultActionPost: play.api.libs.json.Reads[AuthorizationResultActionPost] = {
      for {
        `type` <- (__ \ "type").read[io.flow.payment.v0.models.AuthorizationResultActionType]
        url <- (__ \ "url").read[String]
        parameters <- (__ \ "parameters").read[_root_.play.api.libs.json.JsObject]
      } yield AuthorizationResultActionPost(`type`, url, parameters)
    }

    def jsObjectAuthorizationResultActionPost(obj: io.flow.payment.v0.models.AuthorizationResultActionPost): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "url" -> play.api.libs.json.JsString(obj.url),
        "parameters" -> obj.parameters
      )
    }

    implicit def jsonReadsPaymentAuthorizationResultActionWait: play.api.libs.json.Reads[AuthorizationResultActionWait] = {
      (__ \ "type").read[io.flow.payment.v0.models.AuthorizationResultActionType].map { x => new AuthorizationResultActionWait(`type` = x) }
    }

    def jsObjectAuthorizationResultActionWait(obj: io.flow.payment.v0.models.AuthorizationResultActionWait): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "type" -> play.api.libs.json.JsString(obj.`type`.toString)
      )
    }

    implicit def jsonReadsPaymentAuthorizationResultDescription: play.api.libs.json.Reads[AuthorizationResultDescription] = {
      (__ \ "display").read[String].map { x => new AuthorizationResultDescription(display = x) }
    }

    def jsObjectAuthorizationResultDescription(obj: io.flow.payment.v0.models.AuthorizationResultDescription): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "display" -> play.api.libs.json.JsString(obj.display)
      )
    }

    implicit def jsonWritesPaymentAuthorizationResultDescription: play.api.libs.json.Writes[AuthorizationResultDescription] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.AuthorizationResultDescription] {
        def writes(obj: io.flow.payment.v0.models.AuthorizationResultDescription) = {
          jsObjectAuthorizationResultDescription(obj)
        }
      }
    }

    implicit def jsonReadsPaymentAuthorizationVersion: play.api.libs.json.Reads[AuthorizationVersion] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        authorization <- (__ \ "authorization").read[io.flow.payment.v0.models.Authorization]
      } yield AuthorizationVersion(id, timestamp, `type`, authorization)
    }

    def jsObjectAuthorizationVersion(obj: io.flow.payment.v0.models.AuthorizationVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "authorization" -> jsObjectAuthorization(obj.authorization)
      )
    }

    implicit def jsonWritesPaymentAuthorizationVersion: play.api.libs.json.Writes[AuthorizationVersion] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.AuthorizationVersion] {
        def writes(obj: io.flow.payment.v0.models.AuthorizationVersion) = {
          jsObjectAuthorizationVersion(obj)
        }
      }
    }

    implicit def jsonReadsPaymentAvs: play.api.libs.json.Reads[Avs] = {
      for {
        code <- (__ \ "code").read[io.flow.payment.v0.models.AvsCode]
        name <- (__ \ "name").readNullable[Boolean]
        address <- (__ \ "address").readNullable[Boolean]
        postal <- (__ \ "postal").readNullable[Boolean]
        description <- (__ \ "description").readNullable[String]
      } yield Avs(code, name, address, postal, description)
    }

    def jsObjectAvs(obj: io.flow.payment.v0.models.Avs): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "code" -> play.api.libs.json.JsString(obj.code.toString)
      ) ++ (obj.name match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("name" -> play.api.libs.json.JsBoolean(x))
      }) ++
      (obj.address match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("address" -> play.api.libs.json.JsBoolean(x))
      }) ++
      (obj.postal match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("postal" -> play.api.libs.json.JsBoolean(x))
      }) ++
      (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesPaymentAvs: play.api.libs.json.Writes[Avs] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.Avs] {
        def writes(obj: io.flow.payment.v0.models.Avs) = {
          jsObjectAvs(obj)
        }
      }
    }

    implicit def jsonReadsPaymentCapture: play.api.libs.json.Reads[Capture] = {
      for {
        id <- (__ \ "id").read[String]
        key <- (__ \ "key").read[String]
        authorization <- (__ \ "authorization").read[io.flow.payment.v0.models.AuthorizationReference]
        amount <- (__ \ "amount").read[BigDecimal]
        currency <- (__ \ "currency").read[String]
        requested <- (__ \ "requested").readNullable[io.flow.common.v0.models.Money]
        createdAt <- (__ \ "created_at").read[_root_.org.joda.time.DateTime]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
        status <- (__ \ "status").readWithDefault[io.flow.payment.v0.models.CaptureStatus](io.flow.payment.v0.models.CaptureStatus.Succeeded)
        base <- (__ \ "base").readNullable[io.flow.common.v0.models.Money]
      } yield Capture(id, key, authorization, amount, currency, requested, createdAt, attributes, status, base)
    }

    def jsObjectCapture(obj: io.flow.payment.v0.models.Capture): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "key" -> play.api.libs.json.JsString(obj.key),
        "authorization" -> jsObjectAuthorizationReference(obj.authorization),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "created_at" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.createdAt)),
        "status" -> play.api.libs.json.JsString(obj.status.toString)
      ) ++ (obj.requested match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("requested" -> io.flow.common.v0.models.json.jsObjectMoney(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.base match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("base" -> io.flow.common.v0.models.json.jsObjectMoney(x))
      })
    }

    implicit def jsonWritesPaymentCapture: play.api.libs.json.Writes[Capture] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.Capture] {
        def writes(obj: io.flow.payment.v0.models.Capture) = {
          jsObjectCapture(obj)
        }
      }
    }

    implicit def jsonReadsPaymentCaptureError: play.api.libs.json.Reads[CaptureError] = {
      for {
        code <- (__ \ "code").read[io.flow.error.v0.models.GenericErrorCode]
        messages <- (__ \ "messages").read[Seq[String]]
        declineCode <- (__ \ "decline_code").read[io.flow.payment.v0.models.CaptureDeclineCode]
      } yield CaptureError(code, messages, declineCode)
    }

    def jsObjectCaptureError(obj: io.flow.payment.v0.models.CaptureError): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "code" -> play.api.libs.json.JsString(obj.code.toString),
        "messages" -> play.api.libs.json.Json.toJson(obj.messages),
        "decline_code" -> play.api.libs.json.JsString(obj.declineCode.toString)
      )
    }

    implicit def jsonWritesPaymentCaptureError: play.api.libs.json.Writes[CaptureError] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.CaptureError] {
        def writes(obj: io.flow.payment.v0.models.CaptureError) = {
          jsObjectCaptureError(obj)
        }
      }
    }

    implicit def jsonReadsPaymentCaptureForm: play.api.libs.json.Reads[CaptureForm] = {
      for {
        authorizationId <- (__ \ "authorization_id").read[String]
        key <- (__ \ "key").readNullable[String]
        amount <- (__ \ "amount").readNullable[BigDecimal]
        currency <- (__ \ "currency").readNullable[String]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
      } yield CaptureForm(authorizationId, key, amount, currency, attributes)
    }

    def jsObjectCaptureForm(obj: io.flow.payment.v0.models.CaptureForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "authorization_id" -> play.api.libs.json.JsString(obj.authorizationId)
      ) ++ (obj.key match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("key" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.amount match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("amount" -> play.api.libs.json.JsNumber(x))
      }) ++
      (obj.currency match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("currency" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesPaymentCaptureForm: play.api.libs.json.Writes[CaptureForm] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.CaptureForm] {
        def writes(obj: io.flow.payment.v0.models.CaptureForm) = {
          jsObjectCaptureForm(obj)
        }
      }
    }

    implicit def jsonReadsPaymentCaptureIdentifier: play.api.libs.json.Reads[CaptureIdentifier] = {
      for {
        id <- (__ \ "id").read[String]
        capture <- (__ \ "capture").read[io.flow.payment.v0.models.CaptureReference]
        identifier <- (__ \ "identifier").read[String]
        primary <- (__ \ "primary").read[Boolean]
      } yield CaptureIdentifier(id, capture, identifier, primary)
    }

    def jsObjectCaptureIdentifier(obj: io.flow.payment.v0.models.CaptureIdentifier): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "capture" -> jsObjectCaptureReference(obj.capture),
        "identifier" -> play.api.libs.json.JsString(obj.identifier),
        "primary" -> play.api.libs.json.JsBoolean(obj.primary)
      )
    }

    implicit def jsonWritesPaymentCaptureIdentifier: play.api.libs.json.Writes[CaptureIdentifier] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.CaptureIdentifier] {
        def writes(obj: io.flow.payment.v0.models.CaptureIdentifier) = {
          jsObjectCaptureIdentifier(obj)
        }
      }
    }

    implicit def jsonReadsPaymentCaptureReference: play.api.libs.json.Reads[CaptureReference] = {
      for {
        id <- (__ \ "id").read[String]
        key <- (__ \ "key").read[String]
      } yield CaptureReference(id, key)
    }

    def jsObjectCaptureReference(obj: io.flow.payment.v0.models.CaptureReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "key" -> play.api.libs.json.JsString(obj.key)
      )
    }

    implicit def jsonWritesPaymentCaptureReference: play.api.libs.json.Writes[CaptureReference] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.CaptureReference] {
        def writes(obj: io.flow.payment.v0.models.CaptureReference) = {
          jsObjectCaptureReference(obj)
        }
      }
    }

    implicit def jsonReadsPaymentCaptureVersion: play.api.libs.json.Reads[CaptureVersion] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        capture <- (__ \ "capture").read[io.flow.payment.v0.models.Capture]
      } yield CaptureVersion(id, timestamp, `type`, capture)
    }

    def jsObjectCaptureVersion(obj: io.flow.payment.v0.models.CaptureVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "capture" -> jsObjectCapture(obj.capture)
      )
    }

    implicit def jsonWritesPaymentCaptureVersion: play.api.libs.json.Writes[CaptureVersion] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.CaptureVersion] {
        def writes(obj: io.flow.payment.v0.models.CaptureVersion) = {
          jsObjectCaptureVersion(obj)
        }
      }
    }

    implicit def jsonReadsPaymentCard: play.api.libs.json.Reads[Card] = {
      for {
        id <- (__ \ "id").read[String]
        token <- (__ \ "token").read[String]
        `type` <- (__ \ "type").read[io.flow.payment.v0.models.CardType]
        expiration <- (__ \ "expiration").read[io.flow.payment.v0.models.Expiration]
        iin <- (__ \ "iin").read[String]
        issuer <- (__ \ "issuer").readNullable[io.flow.payment.v0.models.IssuerSummary]
        last4 <- (__ \ "last4").read[String]
        name <- (__ \ "name").read[String]
        address <- (__ \ "address").readNullable[io.flow.common.v0.models.BillingAddress]
      } yield Card(id, token, `type`, expiration, iin, issuer, last4, name, address)
    }

    def jsObjectCard(obj: io.flow.payment.v0.models.Card): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "token" -> play.api.libs.json.JsString(obj.token),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "expiration" -> jsObjectExpiration(obj.expiration),
        "iin" -> play.api.libs.json.JsString(obj.iin),
        "last4" -> play.api.libs.json.JsString(obj.last4),
        "name" -> play.api.libs.json.JsString(obj.name)
      ) ++ (obj.issuer match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("issuer" -> jsObjectIssuerSummary(x))
      }) ++
      (obj.address match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("address" -> io.flow.common.v0.models.json.jsObjectBillingAddress(x))
      })
    }

    implicit def jsonReadsPaymentCardAuthorization: play.api.libs.json.Reads[CardAuthorization] = {
      for {
        id <- (__ \ "id").read[String]
        key <- (__ \ "key").read[String]
        merchantOfRecord <- (__ \ "merchant_of_record").readWithDefault[io.flow.common.v0.models.MerchantOfRecord](io.flow.common.v0.models.MerchantOfRecord.Flow)
        method <- (__ \ "method").readNullable[io.flow.reference.v0.models.PaymentMethod]
        card <- (__ \ "card").read[io.flow.payment.v0.models.ExpandableCard]
        amount <- (__ \ "amount").read[BigDecimal]
        currency <- (__ \ "currency").read[String]
        requested <- (__ \ "requested").readNullable[io.flow.common.v0.models.Money]
        customer <- (__ \ "customer").read[io.flow.common.v0.models.OrderCustomer]
        attributes <- (__ \ "attributes").read[Map[String, String]]
        destination <- (__ \ "destination").readNullable[io.flow.common.v0.models.Address]
        billingAddress <- (__ \ "billing_address").readNullable[io.flow.common.v0.models.BillingAddress]
        order <- (__ \ "order").readNullable[io.flow.payment.v0.models.AuthorizationOrderReference]
        ip <- (__ \ "ip").readNullable[String]
        result <- (__ \ "result").read[io.flow.payment.v0.models.AuthorizationResult]
        createdAt <- (__ \ "created_at").read[_root_.org.joda.time.DateTime]
        expiresAt <- (__ \ "expires_at").readNullable[_root_.org.joda.time.DateTime]
        base <- (__ \ "base").readNullable[io.flow.common.v0.models.Money]
      } yield CardAuthorization(id, key, merchantOfRecord, method, card, amount, currency, requested, customer, attributes, destination, billingAddress, order, ip, result, createdAt, expiresAt, base)
    }

    def jsObjectCardAuthorization(obj: io.flow.payment.v0.models.CardAuthorization): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "key" -> play.api.libs.json.JsString(obj.key),
        "merchant_of_record" -> play.api.libs.json.JsString(obj.merchantOfRecord.toString),
        "card" -> jsObjectExpandableCard(obj.card),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "customer" -> io.flow.common.v0.models.json.jsObjectOrderCustomer(obj.customer),
        "attributes" -> play.api.libs.json.Json.toJson(obj.attributes),
        "result" -> jsObjectAuthorizationResult(obj.result),
        "created_at" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.createdAt))
      ) ++ (obj.method match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("method" -> io.flow.reference.v0.models.json.jsObjectPaymentMethod(x))
      }) ++
      (obj.requested match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("requested" -> io.flow.common.v0.models.json.jsObjectMoney(x))
      }) ++
      (obj.destination match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("destination" -> io.flow.common.v0.models.json.jsObjectAddress(x))
      }) ++
      (obj.billingAddress match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("billing_address" -> io.flow.common.v0.models.json.jsObjectBillingAddress(x))
      }) ++
      (obj.order match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("order" -> jsObjectAuthorizationOrderReference(x))
      }) ++
      (obj.ip match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("ip" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.expiresAt match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("expires_at" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(x)))
      }) ++
      (obj.base match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("base" -> io.flow.common.v0.models.json.jsObjectMoney(x))
      })
    }

    implicit def jsonReadsPaymentCardError: play.api.libs.json.Reads[CardError] = {
      for {
        code <- (__ \ "code").read[io.flow.payment.v0.models.CardErrorCode]
        messages <- (__ \ "messages").read[Seq[String]]
        avs <- (__ \ "avs").readNullable[io.flow.payment.v0.models.Avs]
        cvv <- (__ \ "cvv").readNullable[io.flow.payment.v0.models.Cvv]
      } yield CardError(code, messages, avs, cvv)
    }

    def jsObjectCardError(obj: io.flow.payment.v0.models.CardError): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "code" -> play.api.libs.json.JsString(obj.code.toString),
        "messages" -> play.api.libs.json.Json.toJson(obj.messages)
      ) ++ (obj.avs match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("avs" -> jsObjectAvs(x))
      }) ++
      (obj.cvv match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("cvv" -> jsObjectCvv(x))
      })
    }

    implicit def jsonWritesPaymentCardError: play.api.libs.json.Writes[CardError] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.CardError] {
        def writes(obj: io.flow.payment.v0.models.CardError) = {
          jsObjectCardError(obj)
        }
      }
    }

    implicit def jsonReadsPaymentCardForm: play.api.libs.json.Reads[CardForm] = {
      for {
        number <- (__ \ "number").readNullable[String]
        cipher <- (__ \ "cipher").readNullable[String]
        expirationMonth <- (__ \ "expiration_month").read[Int]
        expirationYear <- (__ \ "expiration_year").read[Int]
        name <- (__ \ "name").read[String]
        cvv <- (__ \ "cvv").read[String]
        address <- (__ \ "address").readNullable[io.flow.common.v0.models.BillingAddress]
        ip <- (__ \ "ip").readNullable[String]
        challengeText <- (__ \ "challenge_text").readNullable[String]
        challengeCipher <- (__ \ "challenge_cipher").readNullable[String]
        tokenType <- (__ \ "token_type").readNullable[io.flow.payment.v0.models.TokenType]
      } yield CardForm(number, cipher, expirationMonth, expirationYear, name, cvv, address, ip, challengeText, challengeCipher, tokenType)
    }

    def jsObjectCardForm(obj: io.flow.payment.v0.models.CardForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "expiration_month" -> play.api.libs.json.JsNumber(obj.expirationMonth),
        "expiration_year" -> play.api.libs.json.JsNumber(obj.expirationYear),
        "name" -> play.api.libs.json.JsString(obj.name),
        "cvv" -> play.api.libs.json.JsString(obj.cvv)
      ) ++ (obj.number match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("number" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.cipher match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("cipher" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.address match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("address" -> io.flow.common.v0.models.json.jsObjectBillingAddress(x))
      }) ++
      (obj.ip match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("ip" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.challengeText match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("challenge_text" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.challengeCipher match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("challenge_cipher" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.tokenType match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("token_type" -> play.api.libs.json.JsString(x.toString))
      })
    }

    implicit def jsonWritesPaymentCardForm: play.api.libs.json.Writes[CardForm] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.CardForm] {
        def writes(obj: io.flow.payment.v0.models.CardForm) = {
          jsObjectCardForm(obj)
        }
      }
    }

    implicit def jsonReadsPaymentCardNonceForm: play.api.libs.json.Reads[CardNonceForm] = {
      (__ \ "token").read[String].map { x => new CardNonceForm(token = x) }
    }

    def jsObjectCardNonceForm(obj: io.flow.payment.v0.models.CardNonceForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "token" -> play.api.libs.json.JsString(obj.token)
      )
    }

    implicit def jsonWritesPaymentCardNonceForm: play.api.libs.json.Writes[CardNonceForm] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.CardNonceForm] {
        def writes(obj: io.flow.payment.v0.models.CardNonceForm) = {
          jsObjectCardNonceForm(obj)
        }
      }
    }

    implicit def jsonReadsPaymentCardReference: play.api.libs.json.Reads[CardReference] = {
      for {
        id <- (__ \ "id").read[String]
        token <- (__ \ "token").read[String]
      } yield CardReference(id, token)
    }

    def jsObjectCardReference(obj: io.flow.payment.v0.models.CardReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "token" -> play.api.libs.json.JsString(obj.token)
      )
    }

    implicit def jsonReadsPaymentCardSummary: play.api.libs.json.Reads[CardSummary] = {
      for {
        id <- (__ \ "id").read[String]
        `type` <- (__ \ "type").read[io.flow.payment.v0.models.CardType]
        expiration <- (__ \ "expiration").read[io.flow.payment.v0.models.Expiration]
        iin <- (__ \ "iin").read[String]
        issuer <- (__ \ "issuer").readNullable[io.flow.payment.v0.models.IssuerSummary]
        last4 <- (__ \ "last4").read[String]
        name <- (__ \ "name").read[String]
        address <- (__ \ "address").readNullable[io.flow.common.v0.models.BillingAddress]
      } yield CardSummary(id, `type`, expiration, iin, issuer, last4, name, address)
    }

    def jsObjectCardSummary(obj: io.flow.payment.v0.models.CardSummary): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "expiration" -> jsObjectExpiration(obj.expiration),
        "iin" -> play.api.libs.json.JsString(obj.iin),
        "last4" -> play.api.libs.json.JsString(obj.last4),
        "name" -> play.api.libs.json.JsString(obj.name)
      ) ++ (obj.issuer match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("issuer" -> jsObjectIssuerSummary(x))
      }) ++
      (obj.address match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("address" -> io.flow.common.v0.models.json.jsObjectBillingAddress(x))
      })
    }

    implicit def jsonReadsPaymentCardTokenForm: play.api.libs.json.Reads[CardTokenForm] = {
      (__ \ "token").read[String].map { x => new CardTokenForm(token = x) }
    }

    def jsObjectCardTokenForm(obj: io.flow.payment.v0.models.CardTokenForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "token" -> play.api.libs.json.JsString(obj.token)
      )
    }

    implicit def jsonWritesPaymentCardTokenForm: play.api.libs.json.Writes[CardTokenForm] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.CardTokenForm] {
        def writes(obj: io.flow.payment.v0.models.CardTokenForm) = {
          jsObjectCardTokenForm(obj)
        }
      }
    }

    implicit def jsonReadsPaymentCardVersion: play.api.libs.json.Reads[CardVersion] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        card <- (__ \ "card").read[io.flow.payment.v0.models.Card]
      } yield CardVersion(id, timestamp, `type`, card)
    }

    def jsObjectCardVersion(obj: io.flow.payment.v0.models.CardVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "card" -> jsObjectCard(obj.card)
      )
    }

    implicit def jsonWritesPaymentCardVersion: play.api.libs.json.Writes[CardVersion] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.CardVersion] {
        def writes(obj: io.flow.payment.v0.models.CardVersion) = {
          jsObjectCardVersion(obj)
        }
      }
    }

    implicit def jsonReadsPaymentCvv: play.api.libs.json.Reads[Cvv] = {
      for {
        code <- (__ \ "code").read[io.flow.payment.v0.models.CvvCode]
        description <- (__ \ "description").readNullable[String]
      } yield Cvv(code, description)
    }

    def jsObjectCvv(obj: io.flow.payment.v0.models.Cvv): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "code" -> play.api.libs.json.JsString(obj.code.toString)
      ) ++ (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesPaymentCvv: play.api.libs.json.Writes[Cvv] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.Cvv] {
        def writes(obj: io.flow.payment.v0.models.Cvv) = {
          jsObjectCvv(obj)
        }
      }
    }

    implicit def jsonReadsPaymentDirectAuthorizationForm: play.api.libs.json.Reads[DirectAuthorizationForm] = {
      for {
        token <- (__ \ "token").read[String]
        amount <- (__ \ "amount").read[BigDecimal]
        currency <- (__ \ "currency").read[String]
        customer <- (__ \ "customer").readNullable[io.flow.common.v0.models.OrderCustomer]
        key <- (__ \ "key").readNullable[String]
        cvv <- (__ \ "cvv").readNullable[String]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
        destination <- (__ \ "destination").readNullable[io.flow.common.v0.models.Address]
        billingAddress <- (__ \ "billing_address").readNullable[io.flow.common.v0.models.BillingAddress]
        ip <- (__ \ "ip").readNullable[String]
        options <- (__ \ "options").readNullable[Seq[io.flow.payment.v0.models.AuthorizationOption]]
        redirectUrls <- (__ \ "redirect_urls").readNullable[io.flow.payment.v0.models.PostPaymentRedirectUrls]
      } yield DirectAuthorizationForm(token, amount, currency, customer, key, cvv, attributes, destination, billingAddress, ip, options, redirectUrls)
    }

    def jsObjectDirectAuthorizationForm(obj: io.flow.payment.v0.models.DirectAuthorizationForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "token" -> play.api.libs.json.JsString(obj.token),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "currency" -> play.api.libs.json.JsString(obj.currency)
      ) ++ (obj.customer match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("customer" -> io.flow.common.v0.models.json.jsObjectOrderCustomer(x))
      }) ++
      (obj.key match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("key" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.cvv match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("cvv" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.destination match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("destination" -> io.flow.common.v0.models.json.jsObjectAddress(x))
      }) ++
      (obj.billingAddress match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("billing_address" -> io.flow.common.v0.models.json.jsObjectBillingAddress(x))
      }) ++
      (obj.ip match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("ip" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.options match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("options" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.redirectUrls match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("redirect_urls" -> jsObjectPostPaymentRedirectUrls(x))
      })
    }

    implicit def jsonReadsPaymentDirectDebit: play.api.libs.json.Reads[DirectDebit] = {
      for {
        routingNumber <- (__ \ "routing_number").read[String]
        last4 <- (__ \ "last4").read[String]
      } yield DirectDebit(routingNumber, last4)
    }

    def jsObjectDirectDebit(obj: io.flow.payment.v0.models.DirectDebit): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "routing_number" -> play.api.libs.json.JsString(obj.routingNumber),
        "last4" -> play.api.libs.json.JsString(obj.last4)
      )
    }

    implicit def jsonReadsPaymentExpiration: play.api.libs.json.Reads[Expiration] = {
      for {
        month <- (__ \ "month").read[Int]
        year <- (__ \ "year").read[Int]
      } yield Expiration(month, year)
    }

    def jsObjectExpiration(obj: io.flow.payment.v0.models.Expiration): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "month" -> play.api.libs.json.JsNumber(obj.month),
        "year" -> play.api.libs.json.JsNumber(obj.year)
      )
    }

    implicit def jsonWritesPaymentExpiration: play.api.libs.json.Writes[Expiration] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.Expiration] {
        def writes(obj: io.flow.payment.v0.models.Expiration) = {
          jsObjectExpiration(obj)
        }
      }
    }

    implicit def jsonReadsPaymentGooglePayAuthorizationPayload: play.api.libs.json.Reads[GooglePayAuthorizationPayload] = {
      (__ \ "payload").read[_root_.play.api.libs.json.JsObject].map { x => new GooglePayAuthorizationPayload(payload = x) }
    }

    def jsObjectGooglePayAuthorizationPayload(obj: io.flow.payment.v0.models.GooglePayAuthorizationPayload): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "payload" -> obj.payload
      )
    }

    implicit def jsonReadsPaymentIdentifierForm: play.api.libs.json.Reads[IdentifierForm] = {
      (__ \ "primary").readNullable[Boolean].map { x => new IdentifierForm(primary = x) }
    }

    def jsObjectIdentifierForm(obj: io.flow.payment.v0.models.IdentifierForm): play.api.libs.json.JsObject = {
      (obj.primary match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("primary" -> play.api.libs.json.JsBoolean(x))
      })
    }

    implicit def jsonWritesPaymentIdentifierForm: play.api.libs.json.Writes[IdentifierForm] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.IdentifierForm] {
        def writes(obj: io.flow.payment.v0.models.IdentifierForm) = {
          jsObjectIdentifierForm(obj)
        }
      }
    }

    implicit def jsonReadsPaymentInlineAuthorizationDetails: play.api.libs.json.Reads[InlineAuthorizationDetails] = {
      for {
        id <- (__ \ "id").read[String]
        clientToken <- (__ \ "client_token").readNullable[String]
        parameters <- (__ \ "parameters").readNullable[_root_.play.api.libs.json.JsObject]
      } yield InlineAuthorizationDetails(id, clientToken, parameters)
    }

    def jsObjectInlineAuthorizationDetails(obj: io.flow.payment.v0.models.InlineAuthorizationDetails): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id)
      ) ++ (obj.clientToken match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("client_token" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.parameters match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("parameters" -> x)
      })
    }

    implicit def jsonReadsPaymentInlineAuthorizationForm: play.api.libs.json.Reads[InlineAuthorizationForm] = {
      for {
        method <- (__ \ "method").read[String]
        issuer <- (__ \ "issuer").readNullable[io.flow.payment.v0.models.IssuerReference]
        orderNumber <- (__ \ "order_number").read[String]
        amount <- (__ \ "amount").read[BigDecimal]
        currency <- (__ \ "currency").read[String]
        billingAddress <- (__ \ "billing_address").readNullable[io.flow.common.v0.models.BillingAddress]
        key <- (__ \ "key").readNullable[String]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
        ip <- (__ \ "ip").readNullable[String]
        payload <- (__ \ "payload").readNullable[io.flow.payment.v0.models.AuthorizationPayload]
      } yield InlineAuthorizationForm(method, issuer, orderNumber, amount, currency, billingAddress, key, attributes, ip, payload)
    }

    def jsObjectInlineAuthorizationForm(obj: io.flow.payment.v0.models.InlineAuthorizationForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "method" -> play.api.libs.json.JsString(obj.method),
        "order_number" -> play.api.libs.json.JsString(obj.orderNumber),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "currency" -> play.api.libs.json.JsString(obj.currency)
      ) ++ (obj.issuer match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("issuer" -> jsObjectIssuerReference(x))
      }) ++
      (obj.billingAddress match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("billing_address" -> io.flow.common.v0.models.json.jsObjectBillingAddress(x))
      }) ++
      (obj.key match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("key" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.ip match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("ip" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.payload match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("payload" -> jsObjectAuthorizationPayload(x))
      })
    }

    implicit def jsonReadsPaymentIssuerReference: play.api.libs.json.Reads[IssuerReference] = {
      (__ \ "id").read[String].map { x => new IssuerReference(id = x) }
    }

    def jsObjectIssuerReference(obj: io.flow.payment.v0.models.IssuerReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id)
      )
    }

    implicit def jsonWritesPaymentIssuerReference: play.api.libs.json.Writes[IssuerReference] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.IssuerReference] {
        def writes(obj: io.flow.payment.v0.models.IssuerReference) = {
          jsObjectIssuerReference(obj)
        }
      }
    }

    implicit def jsonReadsPaymentIssuerSummary: play.api.libs.json.Reads[IssuerSummary] = {
      for {
        iin <- (__ \ "iin").read[String]
        name <- (__ \ "name").readNullable[String]
        country <- (__ \ "country").readNullable[String]
      } yield IssuerSummary(iin, name, country)
    }

    def jsObjectIssuerSummary(obj: io.flow.payment.v0.models.IssuerSummary): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "iin" -> play.api.libs.json.JsString(obj.iin)
      ) ++ (obj.name match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("name" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.country match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("country" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesPaymentIssuerSummary: play.api.libs.json.Writes[IssuerSummary] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.IssuerSummary] {
        def writes(obj: io.flow.payment.v0.models.IssuerSummary) = {
          jsObjectIssuerSummary(obj)
        }
      }
    }

    implicit def jsonReadsPaymentIssuerV1: play.api.libs.json.Reads[IssuerV1] = {
      for {
        iin <- (__ \ "iin").read[String]
        cardBrand <- (__ \ "card_brand").read[String]
        cardType <- (__ \ "card_type").readNullable[String]
        name <- (__ \ "name").readNullable[String]
        country <- (__ \ "country").readNullable[String]
      } yield IssuerV1(iin, cardBrand, cardType, name, country)
    }

    def jsObjectIssuerV1(obj: io.flow.payment.v0.models.IssuerV1): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "iin" -> play.api.libs.json.JsString(obj.iin),
        "card_brand" -> play.api.libs.json.JsString(obj.cardBrand)
      ) ++ (obj.cardType match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("card_type" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.name match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("name" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.country match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("country" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesPaymentIssuerV1: play.api.libs.json.Writes[IssuerV1] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.IssuerV1] {
        def writes(obj: io.flow.payment.v0.models.IssuerV1) = {
          jsObjectIssuerV1(obj)
        }
      }
    }

    implicit def jsonReadsPaymentMerchantOfRecordAuthorizationForm: play.api.libs.json.Reads[MerchantOfRecordAuthorizationForm] = {
      for {
        token <- (__ \ "token").read[String]
        orderNumber <- (__ \ "order_number").read[String]
        amount <- (__ \ "amount").readNullable[BigDecimal]
        currency <- (__ \ "currency").readNullable[String]
        key <- (__ \ "key").readNullable[String]
        cvv <- (__ \ "cvv").readNullable[String]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
        ip <- (__ \ "ip").readNullable[String]
        options <- (__ \ "options").readNullable[Seq[io.flow.payment.v0.models.AuthorizationOption]]
        redirectUrls <- (__ \ "redirect_urls").readNullable[io.flow.payment.v0.models.PostPaymentRedirectUrls]
        installmentProgramId <- (__ \ "installment_program_id").readNullable[String]
      } yield MerchantOfRecordAuthorizationForm(token, orderNumber, amount, currency, key, cvv, attributes, ip, options, redirectUrls, installmentProgramId)
    }

    def jsObjectMerchantOfRecordAuthorizationForm(obj: io.flow.payment.v0.models.MerchantOfRecordAuthorizationForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "token" -> play.api.libs.json.JsString(obj.token),
        "order_number" -> play.api.libs.json.JsString(obj.orderNumber)
      ) ++ (obj.amount match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("amount" -> play.api.libs.json.JsNumber(x))
      }) ++
      (obj.currency match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("currency" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.key match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("key" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.cvv match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("cvv" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.ip match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("ip" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.options match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("options" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.redirectUrls match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("redirect_urls" -> jsObjectPostPaymentRedirectUrls(x))
      }) ++
      (obj.installmentProgramId match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("installment_program_id" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonReadsPaymentMerchantOfRecordPaymentForm: play.api.libs.json.Reads[MerchantOfRecordPaymentForm] = {
      for {
        method <- (__ \ "method").read[String]
        orderNumber <- (__ \ "order_number").read[String]
        amount <- (__ \ "amount").read[BigDecimal]
        currency <- (__ \ "currency").read[String]
      } yield MerchantOfRecordPaymentForm(method, orderNumber, amount, currency)
    }

    def jsObjectMerchantOfRecordPaymentForm(obj: io.flow.payment.v0.models.MerchantOfRecordPaymentForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "method" -> play.api.libs.json.JsString(obj.method),
        "order_number" -> play.api.libs.json.JsString(obj.orderNumber),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "currency" -> play.api.libs.json.JsString(obj.currency)
      )
    }

    implicit def jsonReadsPaymentOnlineAuthorization: play.api.libs.json.Reads[OnlineAuthorization] = {
      for {
        id <- (__ \ "id").read[String]
        key <- (__ \ "key").read[String]
        method <- (__ \ "method").readNullable[io.flow.reference.v0.models.PaymentMethod]
        merchantOfRecord <- (__ \ "merchant_of_record").readWithDefault[io.flow.common.v0.models.MerchantOfRecord](io.flow.common.v0.models.MerchantOfRecord.Flow)
        details <- (__ \ "details").readNullable[io.flow.payment.v0.models.OnlineAuthorizationDetails]
        payment <- (__ \ "payment").readNullable[_root_.play.api.libs.json.JsObject]
        amount <- (__ \ "amount").read[BigDecimal]
        currency <- (__ \ "currency").read[String]
        requested <- (__ \ "requested").readNullable[io.flow.common.v0.models.Money]
        customer <- (__ \ "customer").read[io.flow.common.v0.models.OrderCustomer]
        attributes <- (__ \ "attributes").read[Map[String, String]]
        destination <- (__ \ "destination").readNullable[io.flow.common.v0.models.Address]
        billingAddress <- (__ \ "billing_address").readNullable[io.flow.common.v0.models.BillingAddress]
        order <- (__ \ "order").readNullable[io.flow.payment.v0.models.AuthorizationOrderReference]
        ip <- (__ \ "ip").readNullable[String]
        result <- (__ \ "result").read[io.flow.payment.v0.models.AuthorizationResult]
        createdAt <- (__ \ "created_at").read[_root_.org.joda.time.DateTime]
        expiresAt <- (__ \ "expires_at").readNullable[_root_.org.joda.time.DateTime]
        base <- (__ \ "base").readNullable[io.flow.common.v0.models.Money]
      } yield OnlineAuthorization(id, key, method, merchantOfRecord, details, payment, amount, currency, requested, customer, attributes, destination, billingAddress, order, ip, result, createdAt, expiresAt, base)
    }

    def jsObjectOnlineAuthorization(obj: io.flow.payment.v0.models.OnlineAuthorization): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "key" -> play.api.libs.json.JsString(obj.key),
        "merchant_of_record" -> play.api.libs.json.JsString(obj.merchantOfRecord.toString),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "customer" -> io.flow.common.v0.models.json.jsObjectOrderCustomer(obj.customer),
        "attributes" -> play.api.libs.json.Json.toJson(obj.attributes),
        "result" -> jsObjectAuthorizationResult(obj.result),
        "created_at" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.createdAt))
      ) ++ (obj.method match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("method" -> io.flow.reference.v0.models.json.jsObjectPaymentMethod(x))
      }) ++
      (obj.details match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("details" -> jsObjectOnlineAuthorizationDetails(x))
      }) ++
      (obj.payment match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("payment" -> x)
      }) ++
      (obj.requested match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("requested" -> io.flow.common.v0.models.json.jsObjectMoney(x))
      }) ++
      (obj.destination match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("destination" -> io.flow.common.v0.models.json.jsObjectAddress(x))
      }) ++
      (obj.billingAddress match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("billing_address" -> io.flow.common.v0.models.json.jsObjectBillingAddress(x))
      }) ++
      (obj.order match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("order" -> jsObjectAuthorizationOrderReference(x))
      }) ++
      (obj.ip match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("ip" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.expiresAt match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("expires_at" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(x)))
      }) ++
      (obj.base match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("base" -> io.flow.common.v0.models.json.jsObjectMoney(x))
      })
    }

    implicit def jsonReadsPaymentPaymentError: play.api.libs.json.Reads[PaymentError] = {
      for {
        code <- (__ \ "code").read[String]
        messages <- (__ \ "messages").read[Seq[String]]
        codes <- (__ \ "codes").read[Seq[io.flow.payment.v0.models.PaymentErrorCode]]
      } yield PaymentError(code, messages, codes)
    }

    def jsObjectPaymentError(obj: io.flow.payment.v0.models.PaymentError): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "code" -> play.api.libs.json.JsString(obj.code),
        "messages" -> play.api.libs.json.Json.toJson(obj.messages),
        "codes" -> play.api.libs.json.Json.toJson(obj.codes)
      )
    }

    implicit def jsonWritesPaymentPaymentError: play.api.libs.json.Writes[PaymentError] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.PaymentError] {
        def writes(obj: io.flow.payment.v0.models.PaymentError) = {
          jsObjectPaymentError(obj)
        }
      }
    }

    implicit def jsonReadsPaymentPaymentPaypal: play.api.libs.json.Reads[PaymentPaypal] = {
      for {
        id <- (__ \ "id").read[String]
        order <- (__ \ "order").readNullable[io.flow.payment.v0.models.AuthorizationOrderReference]
        amount <- (__ \ "amount").read[BigDecimal]
        currency <- (__ \ "currency").read[String]
        paypal <- (__ \ "paypal").read[io.flow.payment.v0.models.PaymentPaypalData]
      } yield PaymentPaypal(id, order, amount, currency, paypal)
    }

    def jsObjectPaymentPaypal(obj: io.flow.payment.v0.models.PaymentPaypal): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "paypal" -> jsObjectPaymentPaypalData(obj.paypal)
      ) ++ (obj.order match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("order" -> jsObjectAuthorizationOrderReference(x))
      })
    }

    implicit def jsonReadsPaymentPaymentPaypalData: play.api.libs.json.Reads[PaymentPaypalData] = {
      (__ \ "payment_id").read[String].map { x => new PaymentPaypalData(paymentId = x) }
    }

    def jsObjectPaymentPaypalData(obj: io.flow.payment.v0.models.PaymentPaypalData): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "payment_id" -> play.api.libs.json.JsString(obj.paymentId)
      )
    }

    implicit def jsonWritesPaymentPaymentPaypalData: play.api.libs.json.Writes[PaymentPaypalData] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.PaymentPaypalData] {
        def writes(obj: io.flow.payment.v0.models.PaymentPaypalData) = {
          jsObjectPaymentPaypalData(obj)
        }
      }
    }

    implicit def jsonReadsPaymentPaymentReference: play.api.libs.json.Reads[PaymentReference] = {
      (__ \ "id").read[String].map { x => new PaymentReference(id = x) }
    }

    def jsObjectPaymentReference(obj: io.flow.payment.v0.models.PaymentReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id)
      )
    }

    implicit def jsonWritesPaymentPaymentReference: play.api.libs.json.Writes[PaymentReference] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.PaymentReference] {
        def writes(obj: io.flow.payment.v0.models.PaymentReference) = {
          jsObjectPaymentReference(obj)
        }
      }
    }

    implicit def jsonReadsPaymentPaymentVersion: play.api.libs.json.Reads[PaymentVersion] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        payment <- (__ \ "payment").read[io.flow.payment.v0.models.Payment]
      } yield PaymentVersion(id, timestamp, `type`, payment)
    }

    def jsObjectPaymentVersion(obj: io.flow.payment.v0.models.PaymentVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "payment" -> jsObjectPayment(obj.payment)
      )
    }

    implicit def jsonWritesPaymentPaymentVersion: play.api.libs.json.Writes[PaymentVersion] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.PaymentVersion] {
        def writes(obj: io.flow.payment.v0.models.PaymentVersion) = {
          jsObjectPaymentVersion(obj)
        }
      }
    }

    implicit def jsonReadsPaymentPaypalAuthorizationDetails: play.api.libs.json.Reads[PaypalAuthorizationDetails] = {
      (__ \ "payment_id").read[String].map { x => new PaypalAuthorizationDetails(paymentId = x) }
    }

    def jsObjectPaypalAuthorizationDetails(obj: io.flow.payment.v0.models.PaypalAuthorizationDetails): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "payment_id" -> play.api.libs.json.JsString(obj.paymentId)
      )
    }

    implicit def jsonReadsPaymentPaypalAuthorizationForm: play.api.libs.json.Reads[PaypalAuthorizationForm] = {
      for {
        paypalPaymentId <- (__ \ "paypal_payment_id").read[String]
        paypalPayerId <- (__ \ "paypal_payer_id").read[String]
        key <- (__ \ "key").readNullable[String]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
        ip <- (__ \ "ip").readNullable[String]
      } yield PaypalAuthorizationForm(paypalPaymentId, paypalPayerId, key, attributes, ip)
    }

    def jsObjectPaypalAuthorizationForm(obj: io.flow.payment.v0.models.PaypalAuthorizationForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "paypal_payment_id" -> play.api.libs.json.JsString(obj.paypalPaymentId),
        "paypal_payer_id" -> play.api.libs.json.JsString(obj.paypalPayerId)
      ) ++ (obj.key match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("key" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.ip match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("ip" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonReadsPaymentPostPaymentRedirectUrls: play.api.libs.json.Reads[PostPaymentRedirectUrls] = {
      for {
        success <- (__ \ "success").read[String]
        failure <- (__ \ "failure").readNullable[String]
      } yield PostPaymentRedirectUrls(success, failure)
    }

    def jsObjectPostPaymentRedirectUrls(obj: io.flow.payment.v0.models.PostPaymentRedirectUrls): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "success" -> play.api.libs.json.JsString(obj.success)
      ) ++ (obj.failure match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("failure" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesPaymentPostPaymentRedirectUrls: play.api.libs.json.Writes[PostPaymentRedirectUrls] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.PostPaymentRedirectUrls] {
        def writes(obj: io.flow.payment.v0.models.PostPaymentRedirectUrls) = {
          jsObjectPostPaymentRedirectUrls(obj)
        }
      }
    }

    implicit def jsonReadsPaymentPublicKey: play.api.libs.json.Reads[PublicKey] = {
      (__ \ "id").read[String].map { x => new PublicKey(id = x) }
    }

    def jsObjectPublicKey(obj: io.flow.payment.v0.models.PublicKey): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id)
      )
    }

    implicit def jsonWritesPaymentPublicKey: play.api.libs.json.Writes[PublicKey] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.PublicKey] {
        def writes(obj: io.flow.payment.v0.models.PublicKey) = {
          jsObjectPublicKey(obj)
        }
      }
    }

    implicit def jsonReadsPaymentRedirectAuthorizationDetails: play.api.libs.json.Reads[RedirectAuthorizationDetails] = {
      for {
        id <- (__ \ "id").read[String]
        paymentRedirectUrl <- (__ \ "payment_redirect_url").read[String]
        confirmationDetails <- (__ \ "confirmation_details").readNullable[io.flow.payment.v0.models.ConfirmationDetails]
      } yield RedirectAuthorizationDetails(id, paymentRedirectUrl, confirmationDetails)
    }

    def jsObjectRedirectAuthorizationDetails(obj: io.flow.payment.v0.models.RedirectAuthorizationDetails): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "payment_redirect_url" -> play.api.libs.json.JsString(obj.paymentRedirectUrl)
      ) ++ (obj.confirmationDetails match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("confirmation_details" -> jsObjectConfirmationDetails(x))
      })
    }

    implicit def jsonReadsPaymentRedirectAuthorizationForm: play.api.libs.json.Reads[RedirectAuthorizationForm] = {
      for {
        method <- (__ \ "method").read[String]
        issuer <- (__ \ "issuer").readNullable[io.flow.payment.v0.models.IssuerReference]
        orderNumber <- (__ \ "order_number").read[String]
        amount <- (__ \ "amount").read[BigDecimal]
        currency <- (__ \ "currency").read[String]
        redirectUrls <- (__ \ "redirect_urls").read[io.flow.payment.v0.models.PostPaymentRedirectUrls]
        key <- (__ \ "key").readNullable[String]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
        ip <- (__ \ "ip").readNullable[String]
      } yield RedirectAuthorizationForm(method, issuer, orderNumber, amount, currency, redirectUrls, key, attributes, ip)
    }

    def jsObjectRedirectAuthorizationForm(obj: io.flow.payment.v0.models.RedirectAuthorizationForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "method" -> play.api.libs.json.JsString(obj.method),
        "order_number" -> play.api.libs.json.JsString(obj.orderNumber),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "redirect_urls" -> jsObjectPostPaymentRedirectUrls(obj.redirectUrls)
      ) ++ (obj.issuer match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("issuer" -> jsObjectIssuerReference(x))
      }) ++
      (obj.key match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("key" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.ip match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("ip" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonReadsPaymentRefund: play.api.libs.json.Reads[Refund] = {
      for {
        id <- (__ \ "id").read[String]
        key <- (__ \ "key").read[String]
        authorization <- (__ \ "authorization").read[io.flow.payment.v0.models.AuthorizationReference]
        amount <- (__ \ "amount").read[BigDecimal]
        currency <- (__ \ "currency").read[String]
        requested <- (__ \ "requested").readNullable[io.flow.common.v0.models.Money]
        captures <- (__ \ "captures").read[Seq[io.flow.payment.v0.models.RefundCaptureSummary]]
        createdAt <- (__ \ "created_at").read[_root_.org.joda.time.DateTime]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
        status <- (__ \ "status").readWithDefault[io.flow.payment.v0.models.RefundStatus](io.flow.payment.v0.models.RefundStatus.Succeeded)
        base <- (__ \ "base").readNullable[io.flow.common.v0.models.Money]
      } yield Refund(id, key, authorization, amount, currency, requested, captures, createdAt, attributes, status, base)
    }

    def jsObjectRefund(obj: io.flow.payment.v0.models.Refund): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "key" -> play.api.libs.json.JsString(obj.key),
        "authorization" -> jsObjectAuthorizationReference(obj.authorization),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "captures" -> play.api.libs.json.Json.toJson(obj.captures),
        "created_at" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.createdAt)),
        "status" -> play.api.libs.json.JsString(obj.status.toString)
      ) ++ (obj.requested match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("requested" -> io.flow.common.v0.models.json.jsObjectMoney(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.base match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("base" -> io.flow.common.v0.models.json.jsObjectMoney(x))
      })
    }

    implicit def jsonWritesPaymentRefund: play.api.libs.json.Writes[Refund] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.Refund] {
        def writes(obj: io.flow.payment.v0.models.Refund) = {
          jsObjectRefund(obj)
        }
      }
    }

    implicit def jsonReadsPaymentRefundCapture: play.api.libs.json.Reads[RefundCapture] = {
      for {
        id <- (__ \ "id").read[String]
        refund <- (__ \ "refund").read[io.flow.payment.v0.models.Refund]
        capture <- (__ \ "capture").read[io.flow.payment.v0.models.Capture]
        amount <- (__ \ "amount").read[BigDecimal]
        currency <- (__ \ "currency").read[String]
        base <- (__ \ "base").read[io.flow.common.v0.models.Money]
        status <- (__ \ "status").readWithDefault[io.flow.payment.v0.models.RefundStatus](io.flow.payment.v0.models.RefundStatus.Succeeded)
      } yield RefundCapture(id, refund, capture, amount, currency, base, status)
    }

    def jsObjectRefundCapture(obj: io.flow.payment.v0.models.RefundCapture): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "refund" -> jsObjectRefund(obj.refund),
        "capture" -> jsObjectCapture(obj.capture),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "base" -> io.flow.common.v0.models.json.jsObjectMoney(obj.base),
        "status" -> play.api.libs.json.JsString(obj.status.toString)
      )
    }

    implicit def jsonWritesPaymentRefundCapture: play.api.libs.json.Writes[RefundCapture] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.RefundCapture] {
        def writes(obj: io.flow.payment.v0.models.RefundCapture) = {
          jsObjectRefundCapture(obj)
        }
      }
    }

    implicit def jsonReadsPaymentRefundCaptureSummary: play.api.libs.json.Reads[RefundCaptureSummary] = {
      for {
        capture <- (__ \ "capture").read[io.flow.payment.v0.models.Capture]
        amount <- (__ \ "amount").read[BigDecimal]
      } yield RefundCaptureSummary(capture, amount)
    }

    def jsObjectRefundCaptureSummary(obj: io.flow.payment.v0.models.RefundCaptureSummary): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "capture" -> jsObjectCapture(obj.capture),
        "amount" -> play.api.libs.json.JsNumber(obj.amount)
      )
    }

    implicit def jsonWritesPaymentRefundCaptureSummary: play.api.libs.json.Writes[RefundCaptureSummary] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.RefundCaptureSummary] {
        def writes(obj: io.flow.payment.v0.models.RefundCaptureSummary) = {
          jsObjectRefundCaptureSummary(obj)
        }
      }
    }

    implicit def jsonReadsPaymentRefundError: play.api.libs.json.Reads[RefundError] = {
      for {
        code <- (__ \ "code").read[io.flow.error.v0.models.GenericErrorCode]
        messages <- (__ \ "messages").read[Seq[String]]
        declineCode <- (__ \ "decline_code").read[io.flow.payment.v0.models.RefundDeclineCode]
      } yield RefundError(code, messages, declineCode)
    }

    def jsObjectRefundError(obj: io.flow.payment.v0.models.RefundError): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "code" -> play.api.libs.json.JsString(obj.code.toString),
        "messages" -> play.api.libs.json.Json.toJson(obj.messages),
        "decline_code" -> play.api.libs.json.JsString(obj.declineCode.toString)
      )
    }

    implicit def jsonWritesPaymentRefundError: play.api.libs.json.Writes[RefundError] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.RefundError] {
        def writes(obj: io.flow.payment.v0.models.RefundError) = {
          jsObjectRefundError(obj)
        }
      }
    }

    implicit def jsonReadsPaymentRefundForm: play.api.libs.json.Reads[RefundForm] = {
      for {
        authorizationId <- (__ \ "authorization_id").readNullable[String]
        captureId <- (__ \ "capture_id").readNullable[String]
        orderNumber <- (__ \ "order_number").readNullable[String]
        key <- (__ \ "key").readNullable[String]
        amount <- (__ \ "amount").readNullable[BigDecimal]
        currency <- (__ \ "currency").readNullable[String]
        rmaKey <- (__ \ "rma_key").readNullable[String]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
      } yield RefundForm(authorizationId, captureId, orderNumber, key, amount, currency, rmaKey, attributes)
    }

    def jsObjectRefundForm(obj: io.flow.payment.v0.models.RefundForm): play.api.libs.json.JsObject = {
      (obj.authorizationId match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("authorization_id" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.captureId match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("capture_id" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.orderNumber match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("order_number" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.key match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("key" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.amount match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("amount" -> play.api.libs.json.JsNumber(x))
      }) ++
      (obj.currency match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("currency" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.rmaKey match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("rma_key" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesPaymentRefundForm: play.api.libs.json.Writes[RefundForm] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.RefundForm] {
        def writes(obj: io.flow.payment.v0.models.RefundForm) = {
          jsObjectRefundForm(obj)
        }
      }
    }

    implicit def jsonReadsPaymentRefundIdentifier: play.api.libs.json.Reads[RefundIdentifier] = {
      for {
        id <- (__ \ "id").read[String]
        refund <- (__ \ "refund").read[io.flow.payment.v0.models.RefundReference]
        identifier <- (__ \ "identifier").read[String]
        primary <- (__ \ "primary").read[Boolean]
      } yield RefundIdentifier(id, refund, identifier, primary)
    }

    def jsObjectRefundIdentifier(obj: io.flow.payment.v0.models.RefundIdentifier): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "refund" -> jsObjectRefundReference(obj.refund),
        "identifier" -> play.api.libs.json.JsString(obj.identifier),
        "primary" -> play.api.libs.json.JsBoolean(obj.primary)
      )
    }

    implicit def jsonWritesPaymentRefundIdentifier: play.api.libs.json.Writes[RefundIdentifier] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.RefundIdentifier] {
        def writes(obj: io.flow.payment.v0.models.RefundIdentifier) = {
          jsObjectRefundIdentifier(obj)
        }
      }
    }

    implicit def jsonReadsPaymentRefundOrderSummary: play.api.libs.json.Reads[RefundOrderSummary] = {
      for {
        orderNumber <- (__ \ "order_number").read[String]
        currency <- (__ \ "currency").read[String]
        captured <- (__ \ "captured").read[BigDecimal]
        refunded <- (__ \ "refunded").read[BigDecimal]
        amounts <- (__ \ "amounts").read[io.flow.payment.v0.models.RefundOrderSummaryAmounts]
      } yield RefundOrderSummary(orderNumber, currency, captured, refunded, amounts)
    }

    def jsObjectRefundOrderSummary(obj: io.flow.payment.v0.models.RefundOrderSummary): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "order_number" -> play.api.libs.json.JsString(obj.orderNumber),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "captured" -> play.api.libs.json.JsNumber(obj.captured),
        "refunded" -> play.api.libs.json.JsNumber(obj.refunded),
        "amounts" -> jsObjectRefundOrderSummaryAmounts(obj.amounts)
      )
    }

    implicit def jsonWritesPaymentRefundOrderSummary: play.api.libs.json.Writes[RefundOrderSummary] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.RefundOrderSummary] {
        def writes(obj: io.flow.payment.v0.models.RefundOrderSummary) = {
          jsObjectRefundOrderSummary(obj)
        }
      }
    }

    implicit def jsonReadsPaymentRefundOrderSummaryAmounts: play.api.libs.json.Reads[RefundOrderSummaryAmounts] = {
      for {
        balance <- (__ \ "balance").read[BigDecimal]
        balanceExcludingShipping <- (__ \ "balance_excluding_shipping").readNullable[BigDecimal]
        shipping <- (__ \ "shipping").readNullable[BigDecimal]
      } yield RefundOrderSummaryAmounts(balance, balanceExcludingShipping, shipping)
    }

    def jsObjectRefundOrderSummaryAmounts(obj: io.flow.payment.v0.models.RefundOrderSummaryAmounts): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "balance" -> play.api.libs.json.JsNumber(obj.balance)
      ) ++ (obj.balanceExcludingShipping match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("balance_excluding_shipping" -> play.api.libs.json.JsNumber(x))
      }) ++
      (obj.shipping match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("shipping" -> play.api.libs.json.JsNumber(x))
      })
    }

    implicit def jsonWritesPaymentRefundOrderSummaryAmounts: play.api.libs.json.Writes[RefundOrderSummaryAmounts] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.RefundOrderSummaryAmounts] {
        def writes(obj: io.flow.payment.v0.models.RefundOrderSummaryAmounts) = {
          jsObjectRefundOrderSummaryAmounts(obj)
        }
      }
    }

    implicit def jsonReadsPaymentRefundReference: play.api.libs.json.Reads[RefundReference] = {
      for {
        id <- (__ \ "id").read[String]
        key <- (__ \ "key").read[String]
      } yield RefundReference(id, key)
    }

    def jsObjectRefundReference(obj: io.flow.payment.v0.models.RefundReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "key" -> play.api.libs.json.JsString(obj.key)
      )
    }

    implicit def jsonWritesPaymentRefundReference: play.api.libs.json.Writes[RefundReference] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.RefundReference] {
        def writes(obj: io.flow.payment.v0.models.RefundReference) = {
          jsObjectRefundReference(obj)
        }
      }
    }

    implicit def jsonReadsPaymentRefundVersion: play.api.libs.json.Reads[RefundVersion] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        refund <- (__ \ "refund").read[io.flow.payment.v0.models.Refund]
      } yield RefundVersion(id, timestamp, `type`, refund)
    }

    def jsObjectRefundVersion(obj: io.flow.payment.v0.models.RefundVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "refund" -> jsObjectRefund(obj.refund)
      )
    }

    implicit def jsonWritesPaymentRefundVersion: play.api.libs.json.Writes[RefundVersion] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.RefundVersion] {
        def writes(obj: io.flow.payment.v0.models.RefundVersion) = {
          jsObjectRefundVersion(obj)
        }
      }
    }

    implicit def jsonReadsPaymentReversal: play.api.libs.json.Reads[Reversal] = {
      for {
        id <- (__ \ "id").read[String]
        key <- (__ \ "key").read[String]
        authorization <- (__ \ "authorization").read[io.flow.payment.v0.models.AuthorizationReference]
        status <- (__ \ "status").read[io.flow.payment.v0.models.ReversalStatus]
        amount <- (__ \ "amount").read[BigDecimal]
        currency <- (__ \ "currency").read[String]
        requested <- (__ \ "requested").read[io.flow.common.v0.models.Money]
        createdAt <- (__ \ "created_at").read[_root_.org.joda.time.DateTime]
        attributes <- (__ \ "attributes").read[Map[String, String]]
        base <- (__ \ "base").readNullable[io.flow.common.v0.models.Money]
      } yield Reversal(id, key, authorization, status, amount, currency, requested, createdAt, attributes, base)
    }

    def jsObjectReversal(obj: io.flow.payment.v0.models.Reversal): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "key" -> play.api.libs.json.JsString(obj.key),
        "authorization" -> jsObjectAuthorizationReference(obj.authorization),
        "status" -> play.api.libs.json.JsString(obj.status.toString),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "requested" -> io.flow.common.v0.models.json.jsObjectMoney(obj.requested),
        "created_at" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.createdAt)),
        "attributes" -> play.api.libs.json.Json.toJson(obj.attributes)
      ) ++ (obj.base match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("base" -> io.flow.common.v0.models.json.jsObjectMoney(x))
      })
    }

    implicit def jsonWritesPaymentReversal: play.api.libs.json.Writes[Reversal] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.Reversal] {
        def writes(obj: io.flow.payment.v0.models.Reversal) = {
          jsObjectReversal(obj)
        }
      }
    }

    implicit def jsonReadsPaymentReversalError: play.api.libs.json.Reads[ReversalError] = {
      for {
        code <- (__ \ "code").read[String]
        messages <- (__ \ "messages").read[Seq[String]]
        codes <- (__ \ "codes").read[Seq[io.flow.payment.v0.models.ReversalErrorCode]]
      } yield ReversalError(code, messages, codes)
    }

    def jsObjectReversalError(obj: io.flow.payment.v0.models.ReversalError): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "code" -> play.api.libs.json.JsString(obj.code),
        "messages" -> play.api.libs.json.Json.toJson(obj.messages),
        "codes" -> play.api.libs.json.Json.toJson(obj.codes)
      )
    }

    implicit def jsonWritesPaymentReversalError: play.api.libs.json.Writes[ReversalError] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.ReversalError] {
        def writes(obj: io.flow.payment.v0.models.ReversalError) = {
          jsObjectReversalError(obj)
        }
      }
    }

    implicit def jsonReadsPaymentReversalForm: play.api.libs.json.Reads[ReversalForm] = {
      for {
        key <- (__ \ "key").readNullable[String]
        authorizationId <- (__ \ "authorization_id").read[String]
        amount <- (__ \ "amount").readNullable[BigDecimal]
        currency <- (__ \ "currency").readNullable[String]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
      } yield ReversalForm(key, authorizationId, amount, currency, attributes)
    }

    def jsObjectReversalForm(obj: io.flow.payment.v0.models.ReversalForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "authorization_id" -> play.api.libs.json.JsString(obj.authorizationId)
      ) ++ (obj.key match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("key" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.amount match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("amount" -> play.api.libs.json.JsNumber(x))
      }) ++
      (obj.currency match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("currency" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesPaymentReversalForm: play.api.libs.json.Writes[ReversalForm] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.ReversalForm] {
        def writes(obj: io.flow.payment.v0.models.ReversalForm) = {
          jsObjectReversalForm(obj)
        }
      }
    }

    implicit def jsonReadsPaymentReversalPutForm: play.api.libs.json.Reads[ReversalPutForm] = {
      for {
        authorizationId <- (__ \ "authorization_id").read[String]
        amount <- (__ \ "amount").readNullable[BigDecimal]
        currency <- (__ \ "currency").readNullable[String]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
      } yield ReversalPutForm(authorizationId, amount, currency, attributes)
    }

    def jsObjectReversalPutForm(obj: io.flow.payment.v0.models.ReversalPutForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "authorization_id" -> play.api.libs.json.JsString(obj.authorizationId)
      ) ++ (obj.amount match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("amount" -> play.api.libs.json.JsNumber(x))
      }) ++
      (obj.currency match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("currency" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesPaymentReversalPutForm: play.api.libs.json.Writes[ReversalPutForm] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.ReversalPutForm] {
        def writes(obj: io.flow.payment.v0.models.ReversalPutForm) = {
          jsObjectReversalPutForm(obj)
        }
      }
    }

    implicit def jsonReadsPaymentReversalVersion: play.api.libs.json.Reads[ReversalVersion] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        reversal <- (__ \ "reversal").read[io.flow.payment.v0.models.Reversal]
      } yield ReversalVersion(id, timestamp, `type`, reversal)
    }

    def jsObjectReversalVersion(obj: io.flow.payment.v0.models.ReversalVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "reversal" -> jsObjectReversal(obj.reversal)
      )
    }

    implicit def jsonWritesPaymentReversalVersion: play.api.libs.json.Writes[ReversalVersion] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.ReversalVersion] {
        def writes(obj: io.flow.payment.v0.models.ReversalVersion) = {
          jsObjectReversalVersion(obj)
        }
      }
    }

    implicit def jsonReadsPaymentStripeAuthenticationData: play.api.libs.json.Reads[StripeAuthenticationData] = {
      (__ \ "secret_key_reference").read[String].map { x => new StripeAuthenticationData(secretKeyReference = x) }
    }

    def jsObjectStripeAuthenticationData(obj: io.flow.payment.v0.models.StripeAuthenticationData): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "secret_key_reference" -> play.api.libs.json.JsString(obj.secretKeyReference)
      )
    }

    implicit def jsonReadsPaymentStripeAuthenticationDataForm: play.api.libs.json.Reads[StripeAuthenticationDataForm] = {
      for {
        accountId <- (__ \ "account_id").read[String]
        secretKey <- (__ \ "secret_key").read[String]
      } yield StripeAuthenticationDataForm(accountId, secretKey)
    }

    def jsObjectStripeAuthenticationDataForm(obj: io.flow.payment.v0.models.StripeAuthenticationDataForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "account_id" -> play.api.libs.json.JsString(obj.accountId),
        "secret_key" -> play.api.libs.json.JsString(obj.secretKey)
      )
    }

    implicit def jsonReadsPaymentThreeDSecure: play.api.libs.json.Reads[ThreeDSecure] = {
      for {
        code <- (__ \ "code").read[io.flow.payment.v0.models.ThreeDSecureCode]
        description <- (__ \ "description").readNullable[String]
      } yield ThreeDSecure(code, description)
    }

    def jsObjectThreeDSecure(obj: io.flow.payment.v0.models.ThreeDSecure): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "code" -> play.api.libs.json.JsString(obj.code.toString)
      ) ++ (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesPaymentThreeDSecure: play.api.libs.json.Writes[ThreeDSecure] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.ThreeDSecure] {
        def writes(obj: io.flow.payment.v0.models.ThreeDSecure) = {
          jsObjectThreeDSecure(obj)
        }
      }
    }

    implicit def jsonReadsPaymentVirtualCard: play.api.libs.json.Reads[VirtualCard] = {
      for {
        id <- (__ \ "id").read[String]
        key <- (__ \ "key").read[String]
        number <- (__ \ "number").readNullable[String]
        cvv <- (__ \ "cvv").readNullable[String]
        limit <- (__ \ "limit").read[io.flow.common.v0.models.Price]
        `type` <- (__ \ "type").read[io.flow.payment.v0.models.CardType]
        expiration <- (__ \ "expiration").read[io.flow.payment.v0.models.Expiration]
        iin <- (__ \ "iin").read[String]
        last4 <- (__ \ "last4").read[String]
        name <- (__ \ "name").read[String]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
      } yield VirtualCard(id, key, number, cvv, limit, `type`, expiration, iin, last4, name, attributes)
    }

    def jsObjectVirtualCard(obj: io.flow.payment.v0.models.VirtualCard): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "key" -> play.api.libs.json.JsString(obj.key),
        "limit" -> io.flow.common.v0.models.json.jsObjectPrice(obj.limit),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "expiration" -> jsObjectExpiration(obj.expiration),
        "iin" -> play.api.libs.json.JsString(obj.iin),
        "last4" -> play.api.libs.json.JsString(obj.last4),
        "name" -> play.api.libs.json.JsString(obj.name)
      ) ++ (obj.number match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("number" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.cvv match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("cvv" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesPaymentVirtualCard: play.api.libs.json.Writes[VirtualCard] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.VirtualCard] {
        def writes(obj: io.flow.payment.v0.models.VirtualCard) = {
          jsObjectVirtualCard(obj)
        }
      }
    }

    implicit def jsonReadsPaymentVirtualCardCapture: play.api.libs.json.Reads[VirtualCardCapture] = {
      for {
        id <- (__ \ "id").read[String]
        issuer <- (__ \ "issuer").read[io.flow.payment.v0.models.IssuerV1]
        virtualCard <- (__ \ "virtual_card").read[io.flow.payment.v0.models.VirtualCardReference]
        authorization <- (__ \ "authorization").read[io.flow.payment.v0.models.AuthorizationReference]
        amount <- (__ \ "amount").read[BigDecimal]
        currency <- (__ \ "currency").read[String]
        createdAt <- (__ \ "created_at").read[_root_.org.joda.time.DateTime]
      } yield VirtualCardCapture(id, issuer, virtualCard, authorization, amount, currency, createdAt)
    }

    def jsObjectVirtualCardCapture(obj: io.flow.payment.v0.models.VirtualCardCapture): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "issuer" -> jsObjectIssuerV1(obj.issuer),
        "virtual_card" -> jsObjectVirtualCardReference(obj.virtualCard),
        "authorization" -> jsObjectAuthorizationReference(obj.authorization),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "created_at" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.createdAt))
      )
    }

    implicit def jsonWritesPaymentVirtualCardCapture: play.api.libs.json.Writes[VirtualCardCapture] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.VirtualCardCapture] {
        def writes(obj: io.flow.payment.v0.models.VirtualCardCapture) = {
          jsObjectVirtualCardCapture(obj)
        }
      }
    }

    implicit def jsonReadsPaymentVirtualCardCaptureVersion: play.api.libs.json.Reads[VirtualCardCaptureVersion] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        virtualCardCapture <- (__ \ "virtual_card_capture").read[io.flow.payment.v0.models.VirtualCardCapture]
      } yield VirtualCardCaptureVersion(id, timestamp, `type`, virtualCardCapture)
    }

    def jsObjectVirtualCardCaptureVersion(obj: io.flow.payment.v0.models.VirtualCardCaptureVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "virtual_card_capture" -> jsObjectVirtualCardCapture(obj.virtualCardCapture)
      )
    }

    implicit def jsonWritesPaymentVirtualCardCaptureVersion: play.api.libs.json.Writes[VirtualCardCaptureVersion] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.VirtualCardCaptureVersion] {
        def writes(obj: io.flow.payment.v0.models.VirtualCardCaptureVersion) = {
          jsObjectVirtualCardCaptureVersion(obj)
        }
      }
    }

    implicit def jsonReadsPaymentVirtualCardForm: play.api.libs.json.Reads[VirtualCardForm] = {
      for {
        limit <- (__ \ "limit").read[io.flow.common.v0.models.Money]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
      } yield VirtualCardForm(limit, attributes)
    }

    def jsObjectVirtualCardForm(obj: io.flow.payment.v0.models.VirtualCardForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "limit" -> io.flow.common.v0.models.json.jsObjectMoney(obj.limit)
      ) ++ (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesPaymentVirtualCardForm: play.api.libs.json.Writes[VirtualCardForm] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.VirtualCardForm] {
        def writes(obj: io.flow.payment.v0.models.VirtualCardForm) = {
          jsObjectVirtualCardForm(obj)
        }
      }
    }

    implicit def jsonReadsPaymentVirtualCardReference: play.api.libs.json.Reads[VirtualCardReference] = {
      (__ \ "id").read[String].map { x => new VirtualCardReference(id = x) }
    }

    def jsObjectVirtualCardReference(obj: io.flow.payment.v0.models.VirtualCardReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id)
      )
    }

    implicit def jsonWritesPaymentVirtualCardReference: play.api.libs.json.Writes[VirtualCardReference] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.VirtualCardReference] {
        def writes(obj: io.flow.payment.v0.models.VirtualCardReference) = {
          jsObjectVirtualCardReference(obj)
        }
      }
    }

    implicit def jsonReadsPaymentVirtualCardRefund: play.api.libs.json.Reads[VirtualCardRefund] = {
      for {
        id <- (__ \ "id").read[String]
        issuer <- (__ \ "issuer").read[io.flow.payment.v0.models.IssuerV1]
        virtualCard <- (__ \ "virtual_card").read[io.flow.payment.v0.models.VirtualCardReference]
        authorization <- (__ \ "authorization").read[io.flow.payment.v0.models.AuthorizationReference]
        amount <- (__ \ "amount").read[BigDecimal]
        currency <- (__ \ "currency").read[String]
        createdAt <- (__ \ "created_at").read[_root_.org.joda.time.DateTime]
      } yield VirtualCardRefund(id, issuer, virtualCard, authorization, amount, currency, createdAt)
    }

    def jsObjectVirtualCardRefund(obj: io.flow.payment.v0.models.VirtualCardRefund): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "issuer" -> jsObjectIssuerV1(obj.issuer),
        "virtual_card" -> jsObjectVirtualCardReference(obj.virtualCard),
        "authorization" -> jsObjectAuthorizationReference(obj.authorization),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "created_at" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.createdAt))
      )
    }

    implicit def jsonWritesPaymentVirtualCardRefund: play.api.libs.json.Writes[VirtualCardRefund] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.VirtualCardRefund] {
        def writes(obj: io.flow.payment.v0.models.VirtualCardRefund) = {
          jsObjectVirtualCardRefund(obj)
        }
      }
    }

    implicit def jsonReadsPaymentVirtualCardRefundVersion: play.api.libs.json.Reads[VirtualCardRefundVersion] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        virtualCardRefund <- (__ \ "virtual_card_refund").read[io.flow.payment.v0.models.VirtualCardRefund]
      } yield VirtualCardRefundVersion(id, timestamp, `type`, virtualCardRefund)
    }

    def jsObjectVirtualCardRefundVersion(obj: io.flow.payment.v0.models.VirtualCardRefundVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "virtual_card_refund" -> jsObjectVirtualCardRefund(obj.virtualCardRefund)
      )
    }

    implicit def jsonWritesPaymentVirtualCardRefundVersion: play.api.libs.json.Writes[VirtualCardRefundVersion] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.VirtualCardRefundVersion] {
        def writes(obj: io.flow.payment.v0.models.VirtualCardRefundVersion) = {
          jsObjectVirtualCardRefundVersion(obj)
        }
      }
    }

    implicit def jsonReadsPaymentVirtualCardVersion: play.api.libs.json.Reads[VirtualCardVersion] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        virtualCard <- (__ \ "virtual_card").read[io.flow.payment.v0.models.VirtualCard]
      } yield VirtualCardVersion(id, timestamp, `type`, virtualCard)
    }

    def jsObjectVirtualCardVersion(obj: io.flow.payment.v0.models.VirtualCardVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "virtual_card" -> jsObjectVirtualCard(obj.virtualCard)
      )
    }

    implicit def jsonWritesPaymentVirtualCardVersion: play.api.libs.json.Writes[VirtualCardVersion] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.VirtualCardVersion] {
        def writes(obj: io.flow.payment.v0.models.VirtualCardVersion) = {
          jsObjectVirtualCardVersion(obj)
        }
      }
    }

    implicit def jsonReadsPaymentAuthorization: play.api.libs.json.Reads[Authorization] = new play.api.libs.json.Reads[Authorization] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[Authorization] = {
        (js \ "discriminator").asOpt[String].getOrElse { sys.error("Union[Authorization] requires a discriminator named 'discriminator' - this field was not found in the Json Value") } match {
          case "card_authorization" => js.validate[io.flow.payment.v0.models.CardAuthorization]
          case "online_authorization" => js.validate[io.flow.payment.v0.models.OnlineAuthorization]
          case other => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.AuthorizationUndefinedType(other))
        }
      }
    }

    def jsObjectAuthorization(obj: io.flow.payment.v0.models.Authorization): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.payment.v0.models.CardAuthorization => jsObjectCardAuthorization(x) ++ play.api.libs.json.Json.obj("discriminator" -> "card_authorization")
        case x: io.flow.payment.v0.models.OnlineAuthorization => jsObjectOnlineAuthorization(x) ++ play.api.libs.json.Json.obj("discriminator" -> "online_authorization")
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesPaymentAuthorization: play.api.libs.json.Writes[Authorization] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.Authorization] {
        def writes(obj: io.flow.payment.v0.models.Authorization) = {
          jsObjectAuthorization(obj)
        }
      }
    }

    implicit def jsonReadsPaymentAuthorizationForm: play.api.libs.json.Reads[AuthorizationForm] = new play.api.libs.json.Reads[AuthorizationForm] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[AuthorizationForm] = {
        (js \ "discriminator").asOpt[String].getOrElse { sys.error("Union[AuthorizationForm] requires a discriminator named 'discriminator' - this field was not found in the Json Value") } match {
          case "authorization_copy_form" => js.validate[io.flow.payment.v0.models.AuthorizationCopyForm]
          case "direct_authorization_form" => js.validate[io.flow.payment.v0.models.DirectAuthorizationForm]
          case "merchant_of_record_authorization_form" => js.validate[io.flow.payment.v0.models.MerchantOfRecordAuthorizationForm]
          case "paypal_authorization_form" => js.validate[io.flow.payment.v0.models.PaypalAuthorizationForm]
          case "redirect_authorization_form" => js.validate[io.flow.payment.v0.models.RedirectAuthorizationForm]
          case "inline_authorization_form" => js.validate[io.flow.payment.v0.models.InlineAuthorizationForm]
          case "ach_authorization_form" => js.validate[io.flow.payment.v0.models.AchAuthorizationForm]
          case other => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.AuthorizationFormUndefinedType(other))
        }
      }
    }

    def jsObjectAuthorizationForm(obj: io.flow.payment.v0.models.AuthorizationForm): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.payment.v0.models.AuthorizationCopyForm => jsObjectAuthorizationCopyForm(x) ++ play.api.libs.json.Json.obj("discriminator" -> "authorization_copy_form")
        case x: io.flow.payment.v0.models.DirectAuthorizationForm => jsObjectDirectAuthorizationForm(x) ++ play.api.libs.json.Json.obj("discriminator" -> "direct_authorization_form")
        case x: io.flow.payment.v0.models.MerchantOfRecordAuthorizationForm => jsObjectMerchantOfRecordAuthorizationForm(x) ++ play.api.libs.json.Json.obj("discriminator" -> "merchant_of_record_authorization_form")
        case x: io.flow.payment.v0.models.PaypalAuthorizationForm => jsObjectPaypalAuthorizationForm(x) ++ play.api.libs.json.Json.obj("discriminator" -> "paypal_authorization_form")
        case x: io.flow.payment.v0.models.RedirectAuthorizationForm => jsObjectRedirectAuthorizationForm(x) ++ play.api.libs.json.Json.obj("discriminator" -> "redirect_authorization_form")
        case x: io.flow.payment.v0.models.InlineAuthorizationForm => jsObjectInlineAuthorizationForm(x) ++ play.api.libs.json.Json.obj("discriminator" -> "inline_authorization_form")
        case x: io.flow.payment.v0.models.AchAuthorizationForm => jsObjectAchAuthorizationForm(x) ++ play.api.libs.json.Json.obj("discriminator" -> "ach_authorization_form")
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesPaymentAuthorizationForm: play.api.libs.json.Writes[AuthorizationForm] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.AuthorizationForm] {
        def writes(obj: io.flow.payment.v0.models.AuthorizationForm) = {
          jsObjectAuthorizationForm(obj)
        }
      }
    }

    implicit def jsonReadsPaymentAuthorizationPayloadParameters: play.api.libs.json.Reads[AuthorizationPayloadParameters] = new play.api.libs.json.Reads[AuthorizationPayloadParameters] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[AuthorizationPayloadParameters] = {
        (js \ "discriminator").asOpt[String].getOrElse { sys.error("Union[AuthorizationPayloadParameters] requires a discriminator named 'discriminator' - this field was not found in the Json Value") } match {
          case "google_pay_authorization_payload" => js.validate[io.flow.payment.v0.models.GooglePayAuthorizationPayload]
          case "apple_pay_merchant_validation_payload" => js.validate[io.flow.payment.v0.models.ApplePayMerchantValidationPayload]
          case other => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.AuthorizationPayloadParametersUndefinedType(other))
        }
      }
    }

    def jsObjectAuthorizationPayloadParameters(obj: io.flow.payment.v0.models.AuthorizationPayloadParameters): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.payment.v0.models.GooglePayAuthorizationPayload => jsObjectGooglePayAuthorizationPayload(x) ++ play.api.libs.json.Json.obj("discriminator" -> "google_pay_authorization_payload")
        case x: io.flow.payment.v0.models.ApplePayMerchantValidationPayload => jsObjectApplePayMerchantValidationPayload(x) ++ play.api.libs.json.Json.obj("discriminator" -> "apple_pay_merchant_validation_payload")
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesPaymentAuthorizationPayloadParameters: play.api.libs.json.Writes[AuthorizationPayloadParameters] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.AuthorizationPayloadParameters] {
        def writes(obj: io.flow.payment.v0.models.AuthorizationPayloadParameters) = {
          jsObjectAuthorizationPayloadParameters(obj)
        }
      }
    }

    implicit def jsonReadsPaymentAuthorizationResultAction: play.api.libs.json.Reads[AuthorizationResultAction] = new play.api.libs.json.Reads[AuthorizationResultAction] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[AuthorizationResultAction] = {
        (js \ "discriminator").asOpt[String].getOrElse { sys.error("Union[AuthorizationResultAction] requires a discriminator named 'discriminator' - this field was not found in the Json Value") } match {
          case "authorization_result_action_get" => js.validate[io.flow.payment.v0.models.AuthorizationResultActionGet]
          case "authorization_result_action_post" => js.validate[io.flow.payment.v0.models.AuthorizationResultActionPost]
          case "authorization_result_action_wait" => js.validate[io.flow.payment.v0.models.AuthorizationResultActionWait]
          case other => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.AuthorizationResultActionUndefinedType(other))
        }
      }
    }

    def jsObjectAuthorizationResultAction(obj: io.flow.payment.v0.models.AuthorizationResultAction): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.payment.v0.models.AuthorizationResultActionGet => jsObjectAuthorizationResultActionGet(x) ++ play.api.libs.json.Json.obj("discriminator" -> "authorization_result_action_get")
        case x: io.flow.payment.v0.models.AuthorizationResultActionPost => jsObjectAuthorizationResultActionPost(x) ++ play.api.libs.json.Json.obj("discriminator" -> "authorization_result_action_post")
        case x: io.flow.payment.v0.models.AuthorizationResultActionWait => jsObjectAuthorizationResultActionWait(x) ++ play.api.libs.json.Json.obj("discriminator" -> "authorization_result_action_wait")
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesPaymentAuthorizationResultAction: play.api.libs.json.Writes[AuthorizationResultAction] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.AuthorizationResultAction] {
        def writes(obj: io.flow.payment.v0.models.AuthorizationResultAction) = {
          jsObjectAuthorizationResultAction(obj)
        }
      }
    }

    implicit def jsonReadsPaymentConfirmationDetails: play.api.libs.json.Reads[ConfirmationDetails] = new play.api.libs.json.Reads[ConfirmationDetails] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[ConfirmationDetails] = {
        (js \ "discriminator").asOpt[String].getOrElse { sys.error("Union[ConfirmationDetails] requires a discriminator named 'discriminator' - this field was not found in the Json Value") } match {
          case "direct_debit" => js.validate[io.flow.payment.v0.models.DirectDebit]
          case other => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.ConfirmationDetailsUndefinedType(other))
        }
      }
    }

    def jsObjectConfirmationDetails(obj: io.flow.payment.v0.models.ConfirmationDetails): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.payment.v0.models.DirectDebit => jsObjectDirectDebit(x) ++ play.api.libs.json.Json.obj("discriminator" -> "direct_debit")
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesPaymentConfirmationDetails: play.api.libs.json.Writes[ConfirmationDetails] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.ConfirmationDetails] {
        def writes(obj: io.flow.payment.v0.models.ConfirmationDetails) = {
          jsObjectConfirmationDetails(obj)
        }
      }
    }

    implicit def jsonReadsPaymentExpandableCard: play.api.libs.json.Reads[ExpandableCard] = new play.api.libs.json.Reads[ExpandableCard] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[ExpandableCard] = {
        (js \ "discriminator").asOpt[String].getOrElse { sys.error("Union[ExpandableCard] requires a discriminator named 'discriminator' - this field was not found in the Json Value") } match {
          case "card" => js.validate[io.flow.payment.v0.models.Card]
          case "card_reference" => js.validate[io.flow.payment.v0.models.CardReference]
          case "card_summary" => js.validate[io.flow.payment.v0.models.CardSummary]
          case other => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.ExpandableCardUndefinedType(other))
        }
      }
    }

    def jsObjectExpandableCard(obj: io.flow.payment.v0.models.ExpandableCard): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.payment.v0.models.Card => jsObjectCard(x) ++ play.api.libs.json.Json.obj("discriminator" -> "card")
        case x: io.flow.payment.v0.models.CardReference => jsObjectCardReference(x) ++ play.api.libs.json.Json.obj("discriminator" -> "card_reference")
        case x: io.flow.payment.v0.models.CardSummary => jsObjectCardSummary(x) ++ play.api.libs.json.Json.obj("discriminator" -> "card_summary")
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesPaymentExpandableCard: play.api.libs.json.Writes[ExpandableCard] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.ExpandableCard] {
        def writes(obj: io.flow.payment.v0.models.ExpandableCard) = {
          jsObjectExpandableCard(obj)
        }
      }
    }

    implicit def jsonReadsPaymentGatewayAuthenticationData: play.api.libs.json.Reads[GatewayAuthenticationData] = new play.api.libs.json.Reads[GatewayAuthenticationData] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[GatewayAuthenticationData] = {
        (js \ "discriminator").asOpt[String].getOrElse { sys.error("Union[GatewayAuthenticationData] requires a discriminator named 'discriminator' - this field was not found in the Json Value") } match {
          case "stripe_authentication_data" => js.validate[io.flow.payment.v0.models.StripeAuthenticationData]
          case other => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.GatewayAuthenticationDataUndefinedType(other))
        }
      }
    }

    def jsObjectGatewayAuthenticationData(obj: io.flow.payment.v0.models.GatewayAuthenticationData): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.payment.v0.models.StripeAuthenticationData => jsObjectStripeAuthenticationData(x) ++ play.api.libs.json.Json.obj("discriminator" -> "stripe_authentication_data")
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesPaymentGatewayAuthenticationData: play.api.libs.json.Writes[GatewayAuthenticationData] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.GatewayAuthenticationData] {
        def writes(obj: io.flow.payment.v0.models.GatewayAuthenticationData) = {
          jsObjectGatewayAuthenticationData(obj)
        }
      }
    }

    implicit def jsonReadsPaymentGatewayAuthenticationDataForm: play.api.libs.json.Reads[GatewayAuthenticationDataForm] = new play.api.libs.json.Reads[GatewayAuthenticationDataForm] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[GatewayAuthenticationDataForm] = {
        (js \ "discriminator").asOpt[String].getOrElse { sys.error("Union[GatewayAuthenticationDataForm] requires a discriminator named 'discriminator' - this field was not found in the Json Value") } match {
          case "stripe_authentication_data_form" => js.validate[io.flow.payment.v0.models.StripeAuthenticationDataForm]
          case other => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.GatewayAuthenticationDataFormUndefinedType(other))
        }
      }
    }

    def jsObjectGatewayAuthenticationDataForm(obj: io.flow.payment.v0.models.GatewayAuthenticationDataForm): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.payment.v0.models.StripeAuthenticationDataForm => jsObjectStripeAuthenticationDataForm(x) ++ play.api.libs.json.Json.obj("discriminator" -> "stripe_authentication_data_form")
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesPaymentGatewayAuthenticationDataForm: play.api.libs.json.Writes[GatewayAuthenticationDataForm] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.GatewayAuthenticationDataForm] {
        def writes(obj: io.flow.payment.v0.models.GatewayAuthenticationDataForm) = {
          jsObjectGatewayAuthenticationDataForm(obj)
        }
      }
    }

    implicit def jsonReadsPaymentOnlineAuthorizationDetails: play.api.libs.json.Reads[OnlineAuthorizationDetails] = new play.api.libs.json.Reads[OnlineAuthorizationDetails] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[OnlineAuthorizationDetails] = {
        (js \ "discriminator").asOpt[String].getOrElse { sys.error("Union[OnlineAuthorizationDetails] requires a discriminator named 'discriminator' - this field was not found in the Json Value") } match {
          case "paypal_authorization_details" => js.validate[io.flow.payment.v0.models.PaypalAuthorizationDetails]
          case "redirect_authorization_details" => js.validate[io.flow.payment.v0.models.RedirectAuthorizationDetails]
          case "inline_authorization_details" => js.validate[io.flow.payment.v0.models.InlineAuthorizationDetails]
          case other => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.OnlineAuthorizationDetailsUndefinedType(other))
        }
      }
    }

    def jsObjectOnlineAuthorizationDetails(obj: io.flow.payment.v0.models.OnlineAuthorizationDetails): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.payment.v0.models.PaypalAuthorizationDetails => jsObjectPaypalAuthorizationDetails(x) ++ play.api.libs.json.Json.obj("discriminator" -> "paypal_authorization_details")
        case x: io.flow.payment.v0.models.RedirectAuthorizationDetails => jsObjectRedirectAuthorizationDetails(x) ++ play.api.libs.json.Json.obj("discriminator" -> "redirect_authorization_details")
        case x: io.flow.payment.v0.models.InlineAuthorizationDetails => jsObjectInlineAuthorizationDetails(x) ++ play.api.libs.json.Json.obj("discriminator" -> "inline_authorization_details")
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesPaymentOnlineAuthorizationDetails: play.api.libs.json.Writes[OnlineAuthorizationDetails] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.OnlineAuthorizationDetails] {
        def writes(obj: io.flow.payment.v0.models.OnlineAuthorizationDetails) = {
          jsObjectOnlineAuthorizationDetails(obj)
        }
      }
    }

    implicit def jsonReadsPaymentPayment: play.api.libs.json.Reads[Payment] = new play.api.libs.json.Reads[Payment] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[Payment] = {
        (js \ "discriminator").asOpt[String].getOrElse { sys.error("Union[Payment] requires a discriminator named 'discriminator' - this field was not found in the Json Value") } match {
          case "payment_paypal" => js.validate[io.flow.payment.v0.models.PaymentPaypal]
          case other => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.PaymentUndefinedType(other))
        }
      }
    }

    def jsObjectPayment(obj: io.flow.payment.v0.models.Payment): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.payment.v0.models.PaymentPaypal => jsObjectPaymentPaypal(x) ++ play.api.libs.json.Json.obj("discriminator" -> "payment_paypal")
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesPaymentPayment: play.api.libs.json.Writes[Payment] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.Payment] {
        def writes(obj: io.flow.payment.v0.models.Payment) = {
          jsObjectPayment(obj)
        }
      }
    }

    implicit def jsonReadsPaymentPaymentForm: play.api.libs.json.Reads[PaymentForm] = new play.api.libs.json.Reads[PaymentForm] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[PaymentForm] = {
        (js \ "discriminator").asOpt[String].getOrElse { sys.error("Union[PaymentForm] requires a discriminator named 'discriminator' - this field was not found in the Json Value") } match {
          case "merchant_of_record_payment_form" => js.validate[io.flow.payment.v0.models.MerchantOfRecordPaymentForm]
          case other => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.PaymentFormUndefinedType(other))
        }
      }
    }

    def jsObjectPaymentForm(obj: io.flow.payment.v0.models.PaymentForm): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.payment.v0.models.MerchantOfRecordPaymentForm => jsObjectMerchantOfRecordPaymentForm(x) ++ play.api.libs.json.Json.obj("discriminator" -> "merchant_of_record_payment_form")
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesPaymentPaymentForm: play.api.libs.json.Writes[PaymentForm] = {
      new play.api.libs.json.Writes[io.flow.payment.v0.models.PaymentForm] {
        def writes(obj: io.flow.payment.v0.models.PaymentForm) = {
          jsObjectPaymentForm(obj)
        }
      }
    }
  }
}

package io.flow.payment.v0 {

  object Bindables {

    import play.api.mvc.{PathBindable, QueryStringBindable}

    // import models directly for backwards compatibility with prior versions of the generator
    import Core._
    import Models._

    object Core {
      implicit def pathBindableDateTimeIso8601(implicit stringBinder: QueryStringBindable[String]): PathBindable[_root_.org.joda.time.DateTime] = ApibuilderPathBindable(ApibuilderTypes.dateTimeIso8601)
      implicit def queryStringBindableDateTimeIso8601(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[_root_.org.joda.time.DateTime] = ApibuilderQueryStringBindable(ApibuilderTypes.dateTimeIso8601)

      implicit def pathBindableDateIso8601(implicit stringBinder: QueryStringBindable[String]): PathBindable[_root_.org.joda.time.LocalDate] = ApibuilderPathBindable(ApibuilderTypes.dateIso8601)
      implicit def queryStringBindableDateIso8601(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[_root_.org.joda.time.LocalDate] = ApibuilderQueryStringBindable(ApibuilderTypes.dateIso8601)
    }

    object Models {
      import io.flow.payment.v0.models._

      val authorizationDeclineCodeConverter: ApibuilderTypeConverter[io.flow.payment.v0.models.AuthorizationDeclineCode] = new ApibuilderTypeConverter[io.flow.payment.v0.models.AuthorizationDeclineCode] {
        override def convert(value: String): io.flow.payment.v0.models.AuthorizationDeclineCode = io.flow.payment.v0.models.AuthorizationDeclineCode(value)
        override def convert(value: io.flow.payment.v0.models.AuthorizationDeclineCode): String = value.toString
        override def example: io.flow.payment.v0.models.AuthorizationDeclineCode = io.flow.payment.v0.models.AuthorizationDeclineCode.Expired
        override def validValues: Seq[io.flow.payment.v0.models.AuthorizationDeclineCode] = io.flow.payment.v0.models.AuthorizationDeclineCode.all
      }
      implicit def pathBindableAuthorizationDeclineCode(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.payment.v0.models.AuthorizationDeclineCode] = ApibuilderPathBindable(authorizationDeclineCodeConverter)
      implicit def queryStringBindableAuthorizationDeclineCode(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.payment.v0.models.AuthorizationDeclineCode] = ApibuilderQueryStringBindable(authorizationDeclineCodeConverter)

      val authorizationOptionConverter: ApibuilderTypeConverter[io.flow.payment.v0.models.AuthorizationOption] = new ApibuilderTypeConverter[io.flow.payment.v0.models.AuthorizationOption] {
        override def convert(value: String): io.flow.payment.v0.models.AuthorizationOption = io.flow.payment.v0.models.AuthorizationOption(value)
        override def convert(value: io.flow.payment.v0.models.AuthorizationOption): String = value.toString
        override def example: io.flow.payment.v0.models.AuthorizationOption = io.flow.payment.v0.models.AuthorizationOption.StoreCard
        override def validValues: Seq[io.flow.payment.v0.models.AuthorizationOption] = io.flow.payment.v0.models.AuthorizationOption.all
      }
      implicit def pathBindableAuthorizationOption(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.payment.v0.models.AuthorizationOption] = ApibuilderPathBindable(authorizationOptionConverter)
      implicit def queryStringBindableAuthorizationOption(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.payment.v0.models.AuthorizationOption] = ApibuilderQueryStringBindable(authorizationOptionConverter)

      val authorizationResultActionTypeConverter: ApibuilderTypeConverter[io.flow.payment.v0.models.AuthorizationResultActionType] = new ApibuilderTypeConverter[io.flow.payment.v0.models.AuthorizationResultActionType] {
        override def convert(value: String): io.flow.payment.v0.models.AuthorizationResultActionType = io.flow.payment.v0.models.AuthorizationResultActionType(value)
        override def convert(value: io.flow.payment.v0.models.AuthorizationResultActionType): String = value.toString
        override def example: io.flow.payment.v0.models.AuthorizationResultActionType = io.flow.payment.v0.models.AuthorizationResultActionType.Redirect
        override def validValues: Seq[io.flow.payment.v0.models.AuthorizationResultActionType] = io.flow.payment.v0.models.AuthorizationResultActionType.all
      }
      implicit def pathBindableAuthorizationResultActionType(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.payment.v0.models.AuthorizationResultActionType] = ApibuilderPathBindable(authorizationResultActionTypeConverter)
      implicit def queryStringBindableAuthorizationResultActionType(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.payment.v0.models.AuthorizationResultActionType] = ApibuilderQueryStringBindable(authorizationResultActionTypeConverter)

      val authorizationStatusConverter: ApibuilderTypeConverter[io.flow.payment.v0.models.AuthorizationStatus] = new ApibuilderTypeConverter[io.flow.payment.v0.models.AuthorizationStatus] {
        override def convert(value: String): io.flow.payment.v0.models.AuthorizationStatus = io.flow.payment.v0.models.AuthorizationStatus(value)
        override def convert(value: io.flow.payment.v0.models.AuthorizationStatus): String = value.toString
        override def example: io.flow.payment.v0.models.AuthorizationStatus = io.flow.payment.v0.models.AuthorizationStatus.Pending
        override def validValues: Seq[io.flow.payment.v0.models.AuthorizationStatus] = io.flow.payment.v0.models.AuthorizationStatus.all
      }
      implicit def pathBindableAuthorizationStatus(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.payment.v0.models.AuthorizationStatus] = ApibuilderPathBindable(authorizationStatusConverter)
      implicit def queryStringBindableAuthorizationStatus(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.payment.v0.models.AuthorizationStatus] = ApibuilderQueryStringBindable(authorizationStatusConverter)

      val avsCodeConverter: ApibuilderTypeConverter[io.flow.payment.v0.models.AvsCode] = new ApibuilderTypeConverter[io.flow.payment.v0.models.AvsCode] {
        override def convert(value: String): io.flow.payment.v0.models.AvsCode = io.flow.payment.v0.models.AvsCode(value)
        override def convert(value: io.flow.payment.v0.models.AvsCode): String = value.toString
        override def example: io.flow.payment.v0.models.AvsCode = io.flow.payment.v0.models.AvsCode.Match
        override def validValues: Seq[io.flow.payment.v0.models.AvsCode] = io.flow.payment.v0.models.AvsCode.all
      }
      implicit def pathBindableAvsCode(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.payment.v0.models.AvsCode] = ApibuilderPathBindable(avsCodeConverter)
      implicit def queryStringBindableAvsCode(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.payment.v0.models.AvsCode] = ApibuilderQueryStringBindable(avsCodeConverter)

      val captureDeclineCodeConverter: ApibuilderTypeConverter[io.flow.payment.v0.models.CaptureDeclineCode] = new ApibuilderTypeConverter[io.flow.payment.v0.models.CaptureDeclineCode] {
        override def convert(value: String): io.flow.payment.v0.models.CaptureDeclineCode = io.flow.payment.v0.models.CaptureDeclineCode(value)
        override def convert(value: io.flow.payment.v0.models.CaptureDeclineCode): String = value.toString
        override def example: io.flow.payment.v0.models.CaptureDeclineCode = io.flow.payment.v0.models.CaptureDeclineCode.Expired
        override def validValues: Seq[io.flow.payment.v0.models.CaptureDeclineCode] = io.flow.payment.v0.models.CaptureDeclineCode.all
      }
      implicit def pathBindableCaptureDeclineCode(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.payment.v0.models.CaptureDeclineCode] = ApibuilderPathBindable(captureDeclineCodeConverter)
      implicit def queryStringBindableCaptureDeclineCode(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.payment.v0.models.CaptureDeclineCode] = ApibuilderQueryStringBindable(captureDeclineCodeConverter)

      val captureStatusConverter: ApibuilderTypeConverter[io.flow.payment.v0.models.CaptureStatus] = new ApibuilderTypeConverter[io.flow.payment.v0.models.CaptureStatus] {
        override def convert(value: String): io.flow.payment.v0.models.CaptureStatus = io.flow.payment.v0.models.CaptureStatus(value)
        override def convert(value: io.flow.payment.v0.models.CaptureStatus): String = value.toString
        override def example: io.flow.payment.v0.models.CaptureStatus = io.flow.payment.v0.models.CaptureStatus.Pending
        override def validValues: Seq[io.flow.payment.v0.models.CaptureStatus] = io.flow.payment.v0.models.CaptureStatus.all
      }
      implicit def pathBindableCaptureStatus(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.payment.v0.models.CaptureStatus] = ApibuilderPathBindable(captureStatusConverter)
      implicit def queryStringBindableCaptureStatus(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.payment.v0.models.CaptureStatus] = ApibuilderQueryStringBindable(captureStatusConverter)

      val cardErrorCodeConverter: ApibuilderTypeConverter[io.flow.payment.v0.models.CardErrorCode] = new ApibuilderTypeConverter[io.flow.payment.v0.models.CardErrorCode] {
        override def convert(value: String): io.flow.payment.v0.models.CardErrorCode = io.flow.payment.v0.models.CardErrorCode(value)
        override def convert(value: io.flow.payment.v0.models.CardErrorCode): String = value.toString
        override def example: io.flow.payment.v0.models.CardErrorCode = io.flow.payment.v0.models.CardErrorCode.InvalidAddress
        override def validValues: Seq[io.flow.payment.v0.models.CardErrorCode] = io.flow.payment.v0.models.CardErrorCode.all
      }
      implicit def pathBindableCardErrorCode(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.payment.v0.models.CardErrorCode] = ApibuilderPathBindable(cardErrorCodeConverter)
      implicit def queryStringBindableCardErrorCode(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.payment.v0.models.CardErrorCode] = ApibuilderQueryStringBindable(cardErrorCodeConverter)

      val cardTypeConverter: ApibuilderTypeConverter[io.flow.payment.v0.models.CardType] = new ApibuilderTypeConverter[io.flow.payment.v0.models.CardType] {
        override def convert(value: String): io.flow.payment.v0.models.CardType = io.flow.payment.v0.models.CardType(value)
        override def convert(value: io.flow.payment.v0.models.CardType): String = value.toString
        override def example: io.flow.payment.v0.models.CardType = io.flow.payment.v0.models.CardType.AmericanExpress
        override def validValues: Seq[io.flow.payment.v0.models.CardType] = io.flow.payment.v0.models.CardType.all
      }
      implicit def pathBindableCardType(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.payment.v0.models.CardType] = ApibuilderPathBindable(cardTypeConverter)
      implicit def queryStringBindableCardType(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.payment.v0.models.CardType] = ApibuilderQueryStringBindable(cardTypeConverter)

      val cvvCodeConverter: ApibuilderTypeConverter[io.flow.payment.v0.models.CvvCode] = new ApibuilderTypeConverter[io.flow.payment.v0.models.CvvCode] {
        override def convert(value: String): io.flow.payment.v0.models.CvvCode = io.flow.payment.v0.models.CvvCode(value)
        override def convert(value: io.flow.payment.v0.models.CvvCode): String = value.toString
        override def example: io.flow.payment.v0.models.CvvCode = io.flow.payment.v0.models.CvvCode.Match
        override def validValues: Seq[io.flow.payment.v0.models.CvvCode] = io.flow.payment.v0.models.CvvCode.all
      }
      implicit def pathBindableCvvCode(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.payment.v0.models.CvvCode] = ApibuilderPathBindable(cvvCodeConverter)
      implicit def queryStringBindableCvvCode(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.payment.v0.models.CvvCode] = ApibuilderQueryStringBindable(cvvCodeConverter)

      val paymentErrorCodeConverter: ApibuilderTypeConverter[io.flow.payment.v0.models.PaymentErrorCode] = new ApibuilderTypeConverter[io.flow.payment.v0.models.PaymentErrorCode] {
        override def convert(value: String): io.flow.payment.v0.models.PaymentErrorCode = io.flow.payment.v0.models.PaymentErrorCode(value)
        override def convert(value: io.flow.payment.v0.models.PaymentErrorCode): String = value.toString
        override def example: io.flow.payment.v0.models.PaymentErrorCode = io.flow.payment.v0.models.PaymentErrorCode.Duplicate
        override def validValues: Seq[io.flow.payment.v0.models.PaymentErrorCode] = io.flow.payment.v0.models.PaymentErrorCode.all
      }
      implicit def pathBindablePaymentErrorCode(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.payment.v0.models.PaymentErrorCode] = ApibuilderPathBindable(paymentErrorCodeConverter)
      implicit def queryStringBindablePaymentErrorCode(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.payment.v0.models.PaymentErrorCode] = ApibuilderQueryStringBindable(paymentErrorCodeConverter)

      val refundDeclineCodeConverter: ApibuilderTypeConverter[io.flow.payment.v0.models.RefundDeclineCode] = new ApibuilderTypeConverter[io.flow.payment.v0.models.RefundDeclineCode] {
        override def convert(value: String): io.flow.payment.v0.models.RefundDeclineCode = io.flow.payment.v0.models.RefundDeclineCode(value)
        override def convert(value: io.flow.payment.v0.models.RefundDeclineCode): String = value.toString
        override def example: io.flow.payment.v0.models.RefundDeclineCode = io.flow.payment.v0.models.RefundDeclineCode.Expired
        override def validValues: Seq[io.flow.payment.v0.models.RefundDeclineCode] = io.flow.payment.v0.models.RefundDeclineCode.all
      }
      implicit def pathBindableRefundDeclineCode(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.payment.v0.models.RefundDeclineCode] = ApibuilderPathBindable(refundDeclineCodeConverter)
      implicit def queryStringBindableRefundDeclineCode(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.payment.v0.models.RefundDeclineCode] = ApibuilderQueryStringBindable(refundDeclineCodeConverter)

      val refundStatusConverter: ApibuilderTypeConverter[io.flow.payment.v0.models.RefundStatus] = new ApibuilderTypeConverter[io.flow.payment.v0.models.RefundStatus] {
        override def convert(value: String): io.flow.payment.v0.models.RefundStatus = io.flow.payment.v0.models.RefundStatus(value)
        override def convert(value: io.flow.payment.v0.models.RefundStatus): String = value.toString
        override def example: io.flow.payment.v0.models.RefundStatus = io.flow.payment.v0.models.RefundStatus.Pending
        override def validValues: Seq[io.flow.payment.v0.models.RefundStatus] = io.flow.payment.v0.models.RefundStatus.all
      }
      implicit def pathBindableRefundStatus(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.payment.v0.models.RefundStatus] = ApibuilderPathBindable(refundStatusConverter)
      implicit def queryStringBindableRefundStatus(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.payment.v0.models.RefundStatus] = ApibuilderQueryStringBindable(refundStatusConverter)

      val reversalErrorCodeConverter: ApibuilderTypeConverter[io.flow.payment.v0.models.ReversalErrorCode] = new ApibuilderTypeConverter[io.flow.payment.v0.models.ReversalErrorCode] {
        override def convert(value: String): io.flow.payment.v0.models.ReversalErrorCode = io.flow.payment.v0.models.ReversalErrorCode(value)
        override def convert(value: io.flow.payment.v0.models.ReversalErrorCode): String = value.toString
        override def example: io.flow.payment.v0.models.ReversalErrorCode = io.flow.payment.v0.models.ReversalErrorCode.AmountExceedsBalance
        override def validValues: Seq[io.flow.payment.v0.models.ReversalErrorCode] = io.flow.payment.v0.models.ReversalErrorCode.all
      }
      implicit def pathBindableReversalErrorCode(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.payment.v0.models.ReversalErrorCode] = ApibuilderPathBindable(reversalErrorCodeConverter)
      implicit def queryStringBindableReversalErrorCode(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.payment.v0.models.ReversalErrorCode] = ApibuilderQueryStringBindable(reversalErrorCodeConverter)

      val reversalStatusConverter: ApibuilderTypeConverter[io.flow.payment.v0.models.ReversalStatus] = new ApibuilderTypeConverter[io.flow.payment.v0.models.ReversalStatus] {
        override def convert(value: String): io.flow.payment.v0.models.ReversalStatus = io.flow.payment.v0.models.ReversalStatus(value)
        override def convert(value: io.flow.payment.v0.models.ReversalStatus): String = value.toString
        override def example: io.flow.payment.v0.models.ReversalStatus = io.flow.payment.v0.models.ReversalStatus.Pending
        override def validValues: Seq[io.flow.payment.v0.models.ReversalStatus] = io.flow.payment.v0.models.ReversalStatus.all
      }
      implicit def pathBindableReversalStatus(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.payment.v0.models.ReversalStatus] = ApibuilderPathBindable(reversalStatusConverter)
      implicit def queryStringBindableReversalStatus(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.payment.v0.models.ReversalStatus] = ApibuilderQueryStringBindable(reversalStatusConverter)

      val threeDSecureCodeConverter: ApibuilderTypeConverter[io.flow.payment.v0.models.ThreeDSecureCode] = new ApibuilderTypeConverter[io.flow.payment.v0.models.ThreeDSecureCode] {
        override def convert(value: String): io.flow.payment.v0.models.ThreeDSecureCode = io.flow.payment.v0.models.ThreeDSecureCode(value)
        override def convert(value: io.flow.payment.v0.models.ThreeDSecureCode): String = value.toString
        override def example: io.flow.payment.v0.models.ThreeDSecureCode = io.flow.payment.v0.models.ThreeDSecureCode.Verified
        override def validValues: Seq[io.flow.payment.v0.models.ThreeDSecureCode] = io.flow.payment.v0.models.ThreeDSecureCode.all
      }
      implicit def pathBindableThreeDSecureCode(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.payment.v0.models.ThreeDSecureCode] = ApibuilderPathBindable(threeDSecureCodeConverter)
      implicit def queryStringBindableThreeDSecureCode(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.payment.v0.models.ThreeDSecureCode] = ApibuilderQueryStringBindable(threeDSecureCodeConverter)

      val tokenTypeConverter: ApibuilderTypeConverter[io.flow.payment.v0.models.TokenType] = new ApibuilderTypeConverter[io.flow.payment.v0.models.TokenType] {
        override def convert(value: String): io.flow.payment.v0.models.TokenType = io.flow.payment.v0.models.TokenType(value)
        override def convert(value: io.flow.payment.v0.models.TokenType): String = value.toString
        override def example: io.flow.payment.v0.models.TokenType = io.flow.payment.v0.models.TokenType.Permanent
        override def validValues: Seq[io.flow.payment.v0.models.TokenType] = io.flow.payment.v0.models.TokenType.all
      }
      implicit def pathBindableTokenType(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.payment.v0.models.TokenType] = ApibuilderPathBindable(tokenTypeConverter)
      implicit def queryStringBindableTokenType(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.payment.v0.models.TokenType] = ApibuilderQueryStringBindable(tokenTypeConverter)
    }

    trait ApibuilderTypeConverter[T] {

      def convert(value: String): T

      def convert(value: T): String

      def example: T

      def validValues: Seq[T] = Nil

      def errorMessage(key: String, value: String, ex: java.lang.Exception): String = {
        val base = s"Invalid value '$value' for parameter '$key'. "
        validValues.toList match {
          case Nil => base + "Ex: " + convert(example)
          case values => base + ". Valid values are: " + values.mkString("'", "', '", "'")
        }
      }
    }

    object ApibuilderTypes {
      val dateTimeIso8601: ApibuilderTypeConverter[_root_.org.joda.time.DateTime] = new ApibuilderTypeConverter[_root_.org.joda.time.DateTime] {
        override def convert(value: String): _root_.org.joda.time.DateTime = _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseDateTime(value)
        override def convert(value: _root_.org.joda.time.DateTime): String = _root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(value)
        override def example: _root_.org.joda.time.DateTime = _root_.org.joda.time.DateTime.now
      }

      val dateIso8601: ApibuilderTypeConverter[_root_.org.joda.time.LocalDate] = new ApibuilderTypeConverter[_root_.org.joda.time.LocalDate] {
        override def convert(value: String): _root_.org.joda.time.LocalDate = _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseLocalDate(value)
        override def convert(value: _root_.org.joda.time.LocalDate): String = _root_.org.joda.time.format.ISODateTimeFormat.date.print(value)
        override def example: _root_.org.joda.time.LocalDate = _root_.org.joda.time.LocalDate.now
      }
    }

    final case class ApibuilderQueryStringBindable[T](
      converters: ApibuilderTypeConverter[T]
    ) extends QueryStringBindable[T] {

      override def bind(key: String, params: Map[String, Seq[String]]): _root_.scala.Option[_root_.scala.Either[String, T]] = {
        params.getOrElse(key, Nil).headOption.map { v =>
          try {
            Right(
              converters.convert(v)
            )
          } catch {
            case ex: java.lang.Exception => Left(
              converters.errorMessage(key, v, ex)
            )
          }
        }
      }

      override def unbind(key: String, value: T): String = {
        s"$key=${converters.convert(value)}"
      }
    }

    final case class ApibuilderPathBindable[T](
      converters: ApibuilderTypeConverter[T]
    ) extends PathBindable[T] {

      override def bind(key: String, value: String): _root_.scala.Either[String, T] = {
        try {
          Right(
            converters.convert(value)
          )
        } catch {
          case ex: java.lang.Exception => Left(
            converters.errorMessage(key, value, ex)
          )
        }
      }

      override def unbind(key: String, value: T): String = {
        converters.convert(value)
      }
    }

  }

}
