/**
 * Generated by API Builder - https://www.apibuilder.io
 * Service version: 0.7.56
 * apibuilder 0.14.75 app.apibuilder.io/flow/inventory/0.7.56/play_2_x_json
 */
package io.flow.inventory.v0.models {

  /**
   * Types of rules used to apply on inventory to calculate available quantity
   */
  sealed trait InventoryStrategy extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * Defines the valid discriminator values for the type InventoryStrategy
   */
  sealed trait InventoryStrategyDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object InventoryStrategyDiscriminator {

    /**
     * Enables backorders, setting an optional number of units that we allow for
     * backorder. For example, a backorder w/ quantity 10 will enable selling until the
     * actual inventory quantity is -10.
     */
    case object InventoryBackorder extends InventoryStrategyDiscriminator { override def toString = "inventory_backorder" }
    /**
     * Treats inventory as available as long as the actual inventory quantity is > the
     * specified quantity. A common use case is to set quantity to zero to indicate
     * availability as long as there is at least 1 unit available.
     */
    case object InventoryStock extends InventoryStrategyDiscriminator { override def toString = "inventory_stock" }
    /**
     * Items affected with rules pursuing an unlimited strategy will always be
     * available
     */
    case object InventoryUnlimited extends InventoryStrategyDiscriminator { override def toString = "inventory_unlimited" }

    final case class UNDEFINED(override val toString: String) extends InventoryStrategyDiscriminator

    val all: scala.List[InventoryStrategyDiscriminator] = scala.List(InventoryBackorder, InventoryStock, InventoryUnlimited)

    private[this] val byName: Map[String, InventoryStrategyDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): InventoryStrategyDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[InventoryStrategyDiscriminator] = byName.get(value.toLowerCase)

  }

  /**
   * Types of failed inventory reservation reasons
   */
  sealed trait ReservationError extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * Defines the valid code values for the type ReservationError
   */
  sealed trait ReservationErrorCode extends _root_.scala.Product with _root_.scala.Serializable

  object ReservationErrorCode {

    /**
     * Inventory is not available for all or subset of item quantities requested
     */
    case object NoInventoryReservationError extends ReservationErrorCode { override def toString = "no_inventory" }
    /**
     * API call to external API (ex: PFS) timed out
     */
    case object ExternalApiTimeoutReservationError extends ReservationErrorCode { override def toString = "external_api_timeout" }
    /**
     * Generic reservation error
     */
    case object GenericReservationError extends ReservationErrorCode { override def toString = "generic_reservation_error" }

    final case class UNDEFINED(override val toString: String) extends ReservationErrorCode

    val all: scala.List[ReservationErrorCode] = scala.List(NoInventoryReservationError, ExternalApiTimeoutReservationError, GenericReservationError)

    private[this] val byName: Map[String, ReservationErrorCode] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ReservationErrorCode = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ReservationErrorCode] = byName.get(value.toLowerCase)

  }

  final case class ExternalApiTimeoutReservationError(
    messages: Seq[String]
  ) extends ReservationError

  final case class GenericReservationError(
    messages: Seq[String]
  ) extends ReservationError

  /**
   * Enables backorders, setting an optional number of units that we allow for
   * backorder. For example, a backorder w/ quantity 10 will enable selling until the
   * actual inventory quantity is -10.
   */
  final case class InventoryBackorder(
    quantity: Long
  ) extends InventoryStrategy

  final case class InventoryCenterReference(
    key: String
  )

  final case class InventoryCheckResponse(
    items: Seq[io.flow.inventory.v0.models.InventoryCheckResponseItem]
  )

  final case class InventoryCheckResponseItem(
    number: String,
    quantity: Long,
    inventoryStatus: io.flow.inventory.v0.models.InventoryStatus
  )

  final case class InventoryExperienceReference(
    key: String
  )

  final case class InventoryItemReference(
    number: String
  )

  final case class InventoryRequest(
    items: Seq[io.flow.inventory.v0.models.InventoryRequestItem]
  )

  final case class InventoryRequestItem(
    number: String,
    quantity: Long
  )

  /**
   * Ordered list of rules to apply, from first to last, to get available quantity.
   * This is unique per organization
   * 
   * @param position Order in which rule applicability will be checked
   * @param query Query to be used to apply this rule. Only '*' is available for now, which will
   *        apply to all cases
   * @param strategy Type of inventory strategy to be used for this rule
   */
  final case class InventoryRule(
    id: String,
    position: Long,
    query: String,
    strategy: io.flow.inventory.v0.models.InventoryStrategy
  )

  /**
   * @param position Order in which rule applicability will be checked
   * @param query Query to be used to apply this rule. Only '*' is available for now, which will
   *        apply to all cases
   * @param strategy Type of inventory strategy to be used for this rule
   */
  final case class InventoryRuleForm(
    position: Long,
    query: String,
    strategy: io.flow.inventory.v0.models.InventoryStrategy
  )

  final case class InventoryRuleVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    inventoryRule: io.flow.inventory.v0.models.InventoryRule
  )

  /**
   * Inventory snapshot reflects the current quantity and available number of units
   * for a given center / item
   * 
   * @param available Actual available quantity for an item at a given center
   * @param center Location capable of fulfilling a shipment for item in inventory
   * @param item Client item being stored in inventory
   * @param quantity Running total of inventory update quantities provided
   */
  final case class InventorySnapshot(
    id: String,
    available: Long,
    center: io.flow.inventory.v0.models.InventoryCenterReference,
    item: io.flow.inventory.v0.models.InventoryItemReference,
    quantity: Long
  )

  final case class InventorySnapshotVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    inventorySnapshot: io.flow.inventory.v0.models.InventorySnapshot
  )

  /**
   * Treats inventory as available as long as the actual inventory quantity is > the
   * specified quantity. A common use case is to set quantity to zero to indicate
   * availability as long as there is at least 1 unit available.
   */
  final case class InventoryStock(
    quantity: Long
  ) extends InventoryStrategy

  /**
   * Items affected with rules pursuing an unlimited strategy will always be
   * available
   */
  final case class InventoryUnlimited(
    quantity: String = "unlimited"
  ) extends InventoryStrategy

  /**
   * Represents a single update on inventory quantity
   * 
   * @param center Location capable of fulfilling a shipment for item in inventory
   * @param item Client item number being stored in inventory
   * @param quantity Amount of the update made
   */
  final case class InventoryUpdate(
    id: String,
    idempotencyKey: String,
    center: io.flow.inventory.v0.models.InventoryCenterReference,
    item: io.flow.inventory.v0.models.InventoryItemReference,
    notes: _root_.play.api.libs.json.JsObject,
    quantity: Long,
    `type`: io.flow.inventory.v0.models.UpdateType
  )

  /**
   * Form used to create an update on inventory. If inventory for center/item has not
   * been previously created, a new row is created for the center/item tuple.
   * 
   * @param center Center capable of fulfilling a shipment for item in inventory
   * @param itemNumber Summary about the item being kept in inventory
   * @param quantity Amount of the update to be made
   */
  final case class InventoryUpdateForm(
    center: String,
    idempotencyKey: String,
    itemNumber: String,
    quantity: Long,
    `type`: io.flow.inventory.v0.models.UpdateType,
    notes: _root_.scala.Option[_root_.play.api.libs.json.JsObject] = None
  )

  final case class InventoryUpdateVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    inventoryUpdate: io.flow.inventory.v0.models.InventoryUpdate
  )

  final case class NoInventoryReservationError(
    messages: Seq[String],
    items: Seq[io.flow.inventory.v0.models.NoInventoryReservationErrorItem]
  ) extends ReservationError

  final case class NoInventoryReservationErrorItem(
    number: String,
    requestedQuantity: Long,
    availableQuantity: Long
  )

  final case class PfsInventoryCheckResponse(
    items: Map[String, io.flow.inventory.v0.models.PfsInventoryCheckResponseItem]
  )

  final case class PfsInventoryCheckResponseItem(
    number: String,
    ats: Long,
    inStock: Boolean
  )

  final case class PfsInventoryStatus(
    status: String
  )

  /**
   * Inventory reservation for a set of items in organization that potentially
   * expires at specified date/time
   */
  final case class Reservation(
    id: String,
    key: String,
    order: _root_.scala.Option[io.flow.inventory.v0.models.ReservationOrderReference] = None,
    items: Seq[io.flow.inventory.v0.models.ReservationItem]
  )

  final case class ReservationForm(
    orderNumber: _root_.scala.Option[String] = None,
    items: Seq[io.flow.inventory.v0.models.ReservationItemForm]
  )

  /**
   * @param quantity Number of reserved items.
   */
  final case class ReservationItem(
    item: io.flow.inventory.v0.models.ReservationItemReference,
    quantity: Long
  )

  /**
   * @param quantity Number of items to reserve.
   */
  final case class ReservationItemForm(
    itemNumber: String,
    quantity: Long
  )

  final case class ReservationItemReference(
    number: String
  )

  final case class ReservationOrderReference(
    number: String
  )

  /**
   * A unique identifier assigned to an individual item.
   * 
   * @param itemNumber The item number associated to the number.
   * @param center Indicates the Flow center where the item exists.
   */
  final case class Serial(
    id: String,
    number: String,
    itemNumber: String,
    itemPrice: io.flow.common.v0.models.Price,
    status: io.flow.inventory.v0.models.SerialStatus,
    center: io.flow.fulfillment.v0.models.CenterReference,
    attributes: Map[String, String] = Map.empty
  )

  /**
   * A unique identifier assigned to an individual item.
   * 
   * @param itemNumber The item number associated to the number.
   * @param itemCurrency ISO 4217 3 currency code as defined in https://api.flow.io/reference/currencies
   * @param centerKey Indicates the Flow center where the item exists. If not provided, it is assumed
   *        there is a single center for the organization that will be chosen.
   */
  final case class SerialForm(
    number: String,
    itemNumber: String,
    itemPrice: BigDecimal,
    itemCurrency: String,
    status: io.flow.inventory.v0.models.SerialStatus,
    centerKey: _root_.scala.Option[String] = None,
    attributes: _root_.scala.Option[Map[String, String]] = None
  )

  /**
   * Retrieve journaled history of a serial
   */
  final case class SerialVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    serial: io.flow.inventory.v0.models.Serial
  )

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union InventoryStrategy, it will need to be handled in the client code.
   * This implementation will deserialize these future types as an instance of this
   * class.
   * 
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  final case class InventoryStrategyUndefinedType(
    description: String
  ) extends InventoryStrategy

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union ReservationError, it will need to be handled in the client code.
   * This implementation will deserialize these future types as an instance of this
   * class.
   * 
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  final case class ReservationErrorUndefinedType(
    description: String
  ) extends ReservationError

  /**
   * The aggregate function to be applied
   */
  sealed trait Aggregate extends _root_.scala.Product with _root_.scala.Serializable

  object Aggregate {

    case object Maximum extends Aggregate { override def toString = "maximum" }
    case object Minimum extends Aggregate { override def toString = "minimum" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends Aggregate

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[Aggregate] = scala.List(Maximum, Minimum)

    private[this]
    val byName: Map[String, Aggregate] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): Aggregate = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[Aggregate] = byName.get(value.toLowerCase)

  }

  sealed trait InventoryStatus extends _root_.scala.Product with _root_.scala.Serializable

  object InventoryStatus {

    case object HasInventory extends InventoryStatus { override def toString = "has_inventory" }
    case object NoInventory extends InventoryStatus { override def toString = "no_inventory" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends InventoryStatus

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[InventoryStatus] = scala.List(HasInventory, NoInventory)

    private[this]
    val byName: Map[String, InventoryStatus] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): InventoryStatus = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[InventoryStatus] = byName.get(value.toLowerCase)

  }

  /**
   * The states applicable to a serial
   */
  sealed trait SerialStatus extends _root_.scala.Product with _root_.scala.Serializable

  object SerialStatus {

    case object Available extends SerialStatus { override def toString = "available" }
    case object Reserved extends SerialStatus { override def toString = "reserved" }
    case object Sold extends SerialStatus { override def toString = "sold" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends SerialStatus

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[SerialStatus] = scala.List(Available, Reserved, Sold)

    private[this]
    val byName: Map[String, SerialStatus] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): SerialStatus = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[SerialStatus] = byName.get(value.toLowerCase)

  }

  /**
   * Types of updates that can be made on quantity of inventory
   */
  sealed trait UpdateType extends _root_.scala.Product with _root_.scala.Serializable

  object UpdateType {

    /**
     * Long value to increment or decrement. Positive quantities are added to inventory
     * while negative quantities are decrement from inventory.
     */
    case object Change extends UpdateType { override def toString = "change" }
    /**
     * Set absolute quantity to new value with no regard for previous updates
     */
    case object Set extends UpdateType { override def toString = "set" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends UpdateType

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[UpdateType] = scala.List(Change, Set)

    private[this]
    val byName: Map[String, UpdateType] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): UpdateType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[UpdateType] = byName.get(value.toLowerCase)

  }

}

package io.flow.inventory.v0.models {

  package object json {
    import play.api.libs.json.__
    import play.api.libs.json.JsString
    import play.api.libs.json.Writes
    import play.api.libs.functional.syntax._
    import io.flow.common.v0.models.json._
    import io.flow.error.v0.models.json._
    import io.flow.fulfillment.v0.models.json._
    import io.flow.inventory.v0.models.json._
    import io.flow.permission.v0.models.json._

    private[v0] implicit val jsonReadsUUID = __.read[String].map { str =>
      _root_.java.util.UUID.fromString(str)
    }

    private[v0] implicit val jsonWritesUUID = new Writes[_root_.java.util.UUID] {
      def writes(x: _root_.java.util.UUID) = JsString(x.toString)
    }

    private[v0] implicit val jsonReadsJodaDateTime = __.read[String].map { str =>
      _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseDateTime(str)
    }

    private[v0] implicit val jsonWritesJodaDateTime = new Writes[_root_.org.joda.time.DateTime] {
      def writes(x: _root_.org.joda.time.DateTime) = {
        JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(x))
      }
    }

    private[v0] implicit val jsonReadsJodaLocalDate = __.read[String].map { str =>
      _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseLocalDate(str)
    }

    private[v0] implicit val jsonWritesJodaLocalDate = new Writes[_root_.org.joda.time.LocalDate] {
      def writes(x: _root_.org.joda.time.LocalDate) = {
        JsString(_root_.org.joda.time.format.ISODateTimeFormat.date.print(x))
      }
    }

    implicit val jsonReadsInventoryAggregate = new play.api.libs.json.Reads[io.flow.inventory.v0.models.Aggregate] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.inventory.v0.models.Aggregate] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.inventory.v0.models.Aggregate(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.inventory.v0.models.Aggregate(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesInventoryAggregate(obj: io.flow.inventory.v0.models.Aggregate) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectAggregate(obj: io.flow.inventory.v0.models.Aggregate) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesInventoryAggregate: play.api.libs.json.Writes[Aggregate] = {
      new play.api.libs.json.Writes[io.flow.inventory.v0.models.Aggregate] {
        def writes(obj: io.flow.inventory.v0.models.Aggregate) = {
          jsonWritesInventoryAggregate(obj)
        }
      }
    }

    implicit val jsonReadsInventoryInventoryStatus = new play.api.libs.json.Reads[io.flow.inventory.v0.models.InventoryStatus] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.inventory.v0.models.InventoryStatus] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.inventory.v0.models.InventoryStatus(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.inventory.v0.models.InventoryStatus(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesInventoryInventoryStatus(obj: io.flow.inventory.v0.models.InventoryStatus) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectInventoryStatus(obj: io.flow.inventory.v0.models.InventoryStatus) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesInventoryInventoryStatus: play.api.libs.json.Writes[InventoryStatus] = {
      new play.api.libs.json.Writes[io.flow.inventory.v0.models.InventoryStatus] {
        def writes(obj: io.flow.inventory.v0.models.InventoryStatus) = {
          jsonWritesInventoryInventoryStatus(obj)
        }
      }
    }

    implicit val jsonReadsInventorySerialStatus = new play.api.libs.json.Reads[io.flow.inventory.v0.models.SerialStatus] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.inventory.v0.models.SerialStatus] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.inventory.v0.models.SerialStatus(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.inventory.v0.models.SerialStatus(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesInventorySerialStatus(obj: io.flow.inventory.v0.models.SerialStatus) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectSerialStatus(obj: io.flow.inventory.v0.models.SerialStatus) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesInventorySerialStatus: play.api.libs.json.Writes[SerialStatus] = {
      new play.api.libs.json.Writes[io.flow.inventory.v0.models.SerialStatus] {
        def writes(obj: io.flow.inventory.v0.models.SerialStatus) = {
          jsonWritesInventorySerialStatus(obj)
        }
      }
    }

    implicit val jsonReadsInventoryUpdateType = new play.api.libs.json.Reads[io.flow.inventory.v0.models.UpdateType] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.inventory.v0.models.UpdateType] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.inventory.v0.models.UpdateType(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.inventory.v0.models.UpdateType(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesInventoryUpdateType(obj: io.flow.inventory.v0.models.UpdateType) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectUpdateType(obj: io.flow.inventory.v0.models.UpdateType) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesInventoryUpdateType: play.api.libs.json.Writes[UpdateType] = {
      new play.api.libs.json.Writes[io.flow.inventory.v0.models.UpdateType] {
        def writes(obj: io.flow.inventory.v0.models.UpdateType) = {
          jsonWritesInventoryUpdateType(obj)
        }
      }
    }

    implicit def jsonReadsInventoryExternalApiTimeoutReservationError: play.api.libs.json.Reads[ExternalApiTimeoutReservationError] = {
      (__ \ "messages").read[Seq[String]].map { x => new ExternalApiTimeoutReservationError(messages = x) }
    }

    def jsObjectExternalApiTimeoutReservationError(obj: io.flow.inventory.v0.models.ExternalApiTimeoutReservationError): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "messages" -> play.api.libs.json.Json.toJson(obj.messages)
      )
    }

    implicit def jsonReadsInventoryGenericReservationError: play.api.libs.json.Reads[GenericReservationError] = {
      (__ \ "messages").read[Seq[String]].map { x => new GenericReservationError(messages = x) }
    }

    def jsObjectGenericReservationError(obj: io.flow.inventory.v0.models.GenericReservationError): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "messages" -> play.api.libs.json.Json.toJson(obj.messages)
      )
    }

    implicit def jsonReadsInventoryInventoryBackorder: play.api.libs.json.Reads[InventoryBackorder] = {
      (__ \ "quantity").read[Long].map { x => new InventoryBackorder(quantity = x) }
    }

    def jsObjectInventoryBackorder(obj: io.flow.inventory.v0.models.InventoryBackorder): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "quantity" -> play.api.libs.json.JsNumber(obj.quantity)
      )
    }

    implicit def jsonReadsInventoryInventoryCenterReference: play.api.libs.json.Reads[InventoryCenterReference] = {
      (__ \ "key").read[String].map { x => new InventoryCenterReference(key = x) }
    }

    def jsObjectInventoryCenterReference(obj: io.flow.inventory.v0.models.InventoryCenterReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key)
      )
    }

    implicit def jsonWritesInventoryInventoryCenterReference: play.api.libs.json.Writes[InventoryCenterReference] = {
      new play.api.libs.json.Writes[io.flow.inventory.v0.models.InventoryCenterReference] {
        def writes(obj: io.flow.inventory.v0.models.InventoryCenterReference) = {
          jsObjectInventoryCenterReference(obj)
        }
      }
    }

    implicit def jsonReadsInventoryInventoryCheckResponse: play.api.libs.json.Reads[InventoryCheckResponse] = {
      (__ \ "items").read[Seq[io.flow.inventory.v0.models.InventoryCheckResponseItem]].map { x => new InventoryCheckResponse(items = x) }
    }

    def jsObjectInventoryCheckResponse(obj: io.flow.inventory.v0.models.InventoryCheckResponse): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "items" -> play.api.libs.json.Json.toJson(obj.items)
      )
    }

    implicit def jsonWritesInventoryInventoryCheckResponse: play.api.libs.json.Writes[InventoryCheckResponse] = {
      new play.api.libs.json.Writes[io.flow.inventory.v0.models.InventoryCheckResponse] {
        def writes(obj: io.flow.inventory.v0.models.InventoryCheckResponse) = {
          jsObjectInventoryCheckResponse(obj)
        }
      }
    }

    implicit def jsonReadsInventoryInventoryCheckResponseItem: play.api.libs.json.Reads[InventoryCheckResponseItem] = {
      for {
        number <- (__ \ "number").read[String]
        quantity <- (__ \ "quantity").read[Long]
        inventoryStatus <- (__ \ "inventory_status").read[io.flow.inventory.v0.models.InventoryStatus]
      } yield InventoryCheckResponseItem(number, quantity, inventoryStatus)
    }

    def jsObjectInventoryCheckResponseItem(obj: io.flow.inventory.v0.models.InventoryCheckResponseItem): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "number" -> play.api.libs.json.JsString(obj.number),
        "quantity" -> play.api.libs.json.JsNumber(obj.quantity),
        "inventory_status" -> play.api.libs.json.JsString(obj.inventoryStatus.toString)
      )
    }

    implicit def jsonWritesInventoryInventoryCheckResponseItem: play.api.libs.json.Writes[InventoryCheckResponseItem] = {
      new play.api.libs.json.Writes[io.flow.inventory.v0.models.InventoryCheckResponseItem] {
        def writes(obj: io.flow.inventory.v0.models.InventoryCheckResponseItem) = {
          jsObjectInventoryCheckResponseItem(obj)
        }
      }
    }

    implicit def jsonReadsInventoryInventoryExperienceReference: play.api.libs.json.Reads[InventoryExperienceReference] = {
      (__ \ "key").read[String].map { x => new InventoryExperienceReference(key = x) }
    }

    def jsObjectInventoryExperienceReference(obj: io.flow.inventory.v0.models.InventoryExperienceReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key)
      )
    }

    implicit def jsonWritesInventoryInventoryExperienceReference: play.api.libs.json.Writes[InventoryExperienceReference] = {
      new play.api.libs.json.Writes[io.flow.inventory.v0.models.InventoryExperienceReference] {
        def writes(obj: io.flow.inventory.v0.models.InventoryExperienceReference) = {
          jsObjectInventoryExperienceReference(obj)
        }
      }
    }

    implicit def jsonReadsInventoryInventoryItemReference: play.api.libs.json.Reads[InventoryItemReference] = {
      (__ \ "number").read[String].map { x => new InventoryItemReference(number = x) }
    }

    def jsObjectInventoryItemReference(obj: io.flow.inventory.v0.models.InventoryItemReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "number" -> play.api.libs.json.JsString(obj.number)
      )
    }

    implicit def jsonWritesInventoryInventoryItemReference: play.api.libs.json.Writes[InventoryItemReference] = {
      new play.api.libs.json.Writes[io.flow.inventory.v0.models.InventoryItemReference] {
        def writes(obj: io.flow.inventory.v0.models.InventoryItemReference) = {
          jsObjectInventoryItemReference(obj)
        }
      }
    }

    implicit def jsonReadsInventoryInventoryRequest: play.api.libs.json.Reads[InventoryRequest] = {
      (__ \ "items").read[Seq[io.flow.inventory.v0.models.InventoryRequestItem]].map { x => new InventoryRequest(items = x) }
    }

    def jsObjectInventoryRequest(obj: io.flow.inventory.v0.models.InventoryRequest): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "items" -> play.api.libs.json.Json.toJson(obj.items)
      )
    }

    implicit def jsonWritesInventoryInventoryRequest: play.api.libs.json.Writes[InventoryRequest] = {
      new play.api.libs.json.Writes[io.flow.inventory.v0.models.InventoryRequest] {
        def writes(obj: io.flow.inventory.v0.models.InventoryRequest) = {
          jsObjectInventoryRequest(obj)
        }
      }
    }

    implicit def jsonReadsInventoryInventoryRequestItem: play.api.libs.json.Reads[InventoryRequestItem] = {
      for {
        number <- (__ \ "number").read[String]
        quantity <- (__ \ "quantity").read[Long]
      } yield InventoryRequestItem(number, quantity)
    }

    def jsObjectInventoryRequestItem(obj: io.flow.inventory.v0.models.InventoryRequestItem): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "number" -> play.api.libs.json.JsString(obj.number),
        "quantity" -> play.api.libs.json.JsNumber(obj.quantity)
      )
    }

    implicit def jsonWritesInventoryInventoryRequestItem: play.api.libs.json.Writes[InventoryRequestItem] = {
      new play.api.libs.json.Writes[io.flow.inventory.v0.models.InventoryRequestItem] {
        def writes(obj: io.flow.inventory.v0.models.InventoryRequestItem) = {
          jsObjectInventoryRequestItem(obj)
        }
      }
    }

    implicit def jsonReadsInventoryInventoryRule: play.api.libs.json.Reads[InventoryRule] = {
      for {
        id <- (__ \ "id").read[String]
        position <- (__ \ "position").read[Long]
        query <- (__ \ "query").read[String]
        strategy <- (__ \ "strategy").read[io.flow.inventory.v0.models.InventoryStrategy]
      } yield InventoryRule(id, position, query, strategy)
    }

    def jsObjectInventoryRule(obj: io.flow.inventory.v0.models.InventoryRule): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "position" -> play.api.libs.json.JsNumber(obj.position),
        "query" -> play.api.libs.json.JsString(obj.query),
        "strategy" -> jsObjectInventoryStrategy(obj.strategy)
      )
    }

    implicit def jsonWritesInventoryInventoryRule: play.api.libs.json.Writes[InventoryRule] = {
      new play.api.libs.json.Writes[io.flow.inventory.v0.models.InventoryRule] {
        def writes(obj: io.flow.inventory.v0.models.InventoryRule) = {
          jsObjectInventoryRule(obj)
        }
      }
    }

    implicit def jsonReadsInventoryInventoryRuleForm: play.api.libs.json.Reads[InventoryRuleForm] = {
      for {
        position <- (__ \ "position").read[Long]
        query <- (__ \ "query").read[String]
        strategy <- (__ \ "strategy").read[io.flow.inventory.v0.models.InventoryStrategy]
      } yield InventoryRuleForm(position, query, strategy)
    }

    def jsObjectInventoryRuleForm(obj: io.flow.inventory.v0.models.InventoryRuleForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "position" -> play.api.libs.json.JsNumber(obj.position),
        "query" -> play.api.libs.json.JsString(obj.query),
        "strategy" -> jsObjectInventoryStrategy(obj.strategy)
      )
    }

    implicit def jsonWritesInventoryInventoryRuleForm: play.api.libs.json.Writes[InventoryRuleForm] = {
      new play.api.libs.json.Writes[io.flow.inventory.v0.models.InventoryRuleForm] {
        def writes(obj: io.flow.inventory.v0.models.InventoryRuleForm) = {
          jsObjectInventoryRuleForm(obj)
        }
      }
    }

    implicit def jsonReadsInventoryInventoryRuleVersion: play.api.libs.json.Reads[InventoryRuleVersion] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        inventoryRule <- (__ \ "inventory_rule").read[io.flow.inventory.v0.models.InventoryRule]
      } yield InventoryRuleVersion(id, timestamp, `type`, inventoryRule)
    }

    def jsObjectInventoryRuleVersion(obj: io.flow.inventory.v0.models.InventoryRuleVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "inventory_rule" -> jsObjectInventoryRule(obj.inventoryRule)
      )
    }

    implicit def jsonWritesInventoryInventoryRuleVersion: play.api.libs.json.Writes[InventoryRuleVersion] = {
      new play.api.libs.json.Writes[io.flow.inventory.v0.models.InventoryRuleVersion] {
        def writes(obj: io.flow.inventory.v0.models.InventoryRuleVersion) = {
          jsObjectInventoryRuleVersion(obj)
        }
      }
    }

    implicit def jsonReadsInventoryInventorySnapshot: play.api.libs.json.Reads[InventorySnapshot] = {
      for {
        id <- (__ \ "id").read[String]
        available <- (__ \ "available").read[Long]
        center <- (__ \ "center").read[io.flow.inventory.v0.models.InventoryCenterReference]
        item <- (__ \ "item").read[io.flow.inventory.v0.models.InventoryItemReference]
        quantity <- (__ \ "quantity").read[Long]
      } yield InventorySnapshot(id, available, center, item, quantity)
    }

    def jsObjectInventorySnapshot(obj: io.flow.inventory.v0.models.InventorySnapshot): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "available" -> play.api.libs.json.JsNumber(obj.available),
        "center" -> jsObjectInventoryCenterReference(obj.center),
        "item" -> jsObjectInventoryItemReference(obj.item),
        "quantity" -> play.api.libs.json.JsNumber(obj.quantity)
      )
    }

    implicit def jsonWritesInventoryInventorySnapshot: play.api.libs.json.Writes[InventorySnapshot] = {
      new play.api.libs.json.Writes[io.flow.inventory.v0.models.InventorySnapshot] {
        def writes(obj: io.flow.inventory.v0.models.InventorySnapshot) = {
          jsObjectInventorySnapshot(obj)
        }
      }
    }

    implicit def jsonReadsInventoryInventorySnapshotVersion: play.api.libs.json.Reads[InventorySnapshotVersion] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        inventorySnapshot <- (__ \ "inventory_snapshot").read[io.flow.inventory.v0.models.InventorySnapshot]
      } yield InventorySnapshotVersion(id, timestamp, `type`, inventorySnapshot)
    }

    def jsObjectInventorySnapshotVersion(obj: io.flow.inventory.v0.models.InventorySnapshotVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "inventory_snapshot" -> jsObjectInventorySnapshot(obj.inventorySnapshot)
      )
    }

    implicit def jsonWritesInventoryInventorySnapshotVersion: play.api.libs.json.Writes[InventorySnapshotVersion] = {
      new play.api.libs.json.Writes[io.flow.inventory.v0.models.InventorySnapshotVersion] {
        def writes(obj: io.flow.inventory.v0.models.InventorySnapshotVersion) = {
          jsObjectInventorySnapshotVersion(obj)
        }
      }
    }

    implicit def jsonReadsInventoryInventoryStock: play.api.libs.json.Reads[InventoryStock] = {
      (__ \ "quantity").read[Long].map { x => new InventoryStock(quantity = x) }
    }

    def jsObjectInventoryStock(obj: io.flow.inventory.v0.models.InventoryStock): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "quantity" -> play.api.libs.json.JsNumber(obj.quantity)
      )
    }

    implicit def jsonReadsInventoryInventoryUnlimited: play.api.libs.json.Reads[InventoryUnlimited] = {
      (__ \ "quantity").read[String].map { x => new InventoryUnlimited(quantity = x) }
    }

    def jsObjectInventoryUnlimited(obj: io.flow.inventory.v0.models.InventoryUnlimited): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "quantity" -> play.api.libs.json.JsString(obj.quantity)
      )
    }

    implicit def jsonReadsInventoryInventoryUpdate: play.api.libs.json.Reads[InventoryUpdate] = {
      for {
        id <- (__ \ "id").read[String]
        idempotencyKey <- (__ \ "idempotency_key").read[String]
        center <- (__ \ "center").read[io.flow.inventory.v0.models.InventoryCenterReference]
        item <- (__ \ "item").read[io.flow.inventory.v0.models.InventoryItemReference]
        notes <- (__ \ "notes").read[_root_.play.api.libs.json.JsObject]
        quantity <- (__ \ "quantity").read[Long]
        `type` <- (__ \ "type").read[io.flow.inventory.v0.models.UpdateType]
      } yield InventoryUpdate(id, idempotencyKey, center, item, notes, quantity, `type`)
    }

    def jsObjectInventoryUpdate(obj: io.flow.inventory.v0.models.InventoryUpdate): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "idempotency_key" -> play.api.libs.json.JsString(obj.idempotencyKey),
        "center" -> jsObjectInventoryCenterReference(obj.center),
        "item" -> jsObjectInventoryItemReference(obj.item),
        "notes" -> obj.notes,
        "quantity" -> play.api.libs.json.JsNumber(obj.quantity),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString)
      )
    }

    implicit def jsonWritesInventoryInventoryUpdate: play.api.libs.json.Writes[InventoryUpdate] = {
      new play.api.libs.json.Writes[io.flow.inventory.v0.models.InventoryUpdate] {
        def writes(obj: io.flow.inventory.v0.models.InventoryUpdate) = {
          jsObjectInventoryUpdate(obj)
        }
      }
    }

    implicit def jsonReadsInventoryInventoryUpdateForm: play.api.libs.json.Reads[InventoryUpdateForm] = {
      for {
        center <- (__ \ "center").read[String]
        idempotencyKey <- (__ \ "idempotency_key").read[String]
        itemNumber <- (__ \ "item_number").read[String]
        quantity <- (__ \ "quantity").read[Long]
        `type` <- (__ \ "type").read[io.flow.inventory.v0.models.UpdateType]
        notes <- (__ \ "notes").readNullable[_root_.play.api.libs.json.JsObject]
      } yield InventoryUpdateForm(center, idempotencyKey, itemNumber, quantity, `type`, notes)
    }

    def jsObjectInventoryUpdateForm(obj: io.flow.inventory.v0.models.InventoryUpdateForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "center" -> play.api.libs.json.JsString(obj.center),
        "idempotency_key" -> play.api.libs.json.JsString(obj.idempotencyKey),
        "item_number" -> play.api.libs.json.JsString(obj.itemNumber),
        "quantity" -> play.api.libs.json.JsNumber(obj.quantity),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString)
      ) ++ (obj.notes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("notes" -> x)
      })
    }

    implicit def jsonWritesInventoryInventoryUpdateForm: play.api.libs.json.Writes[InventoryUpdateForm] = {
      new play.api.libs.json.Writes[io.flow.inventory.v0.models.InventoryUpdateForm] {
        def writes(obj: io.flow.inventory.v0.models.InventoryUpdateForm) = {
          jsObjectInventoryUpdateForm(obj)
        }
      }
    }

    implicit def jsonReadsInventoryInventoryUpdateVersion: play.api.libs.json.Reads[InventoryUpdateVersion] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        inventoryUpdate <- (__ \ "inventory_update").read[io.flow.inventory.v0.models.InventoryUpdate]
      } yield InventoryUpdateVersion(id, timestamp, `type`, inventoryUpdate)
    }

    def jsObjectInventoryUpdateVersion(obj: io.flow.inventory.v0.models.InventoryUpdateVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "inventory_update" -> jsObjectInventoryUpdate(obj.inventoryUpdate)
      )
    }

    implicit def jsonWritesInventoryInventoryUpdateVersion: play.api.libs.json.Writes[InventoryUpdateVersion] = {
      new play.api.libs.json.Writes[io.flow.inventory.v0.models.InventoryUpdateVersion] {
        def writes(obj: io.flow.inventory.v0.models.InventoryUpdateVersion) = {
          jsObjectInventoryUpdateVersion(obj)
        }
      }
    }

    implicit def jsonReadsInventoryNoInventoryReservationError: play.api.libs.json.Reads[NoInventoryReservationError] = {
      for {
        messages <- (__ \ "messages").read[Seq[String]]
        items <- (__ \ "items").read[Seq[io.flow.inventory.v0.models.NoInventoryReservationErrorItem]]
      } yield NoInventoryReservationError(messages, items)
    }

    def jsObjectNoInventoryReservationError(obj: io.flow.inventory.v0.models.NoInventoryReservationError): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "messages" -> play.api.libs.json.Json.toJson(obj.messages),
        "items" -> play.api.libs.json.Json.toJson(obj.items)
      )
    }

    implicit def jsonReadsInventoryNoInventoryReservationErrorItem: play.api.libs.json.Reads[NoInventoryReservationErrorItem] = {
      for {
        number <- (__ \ "number").read[String]
        requestedQuantity <- (__ \ "requested_quantity").read[Long]
        availableQuantity <- (__ \ "available_quantity").read[Long]
      } yield NoInventoryReservationErrorItem(number, requestedQuantity, availableQuantity)
    }

    def jsObjectNoInventoryReservationErrorItem(obj: io.flow.inventory.v0.models.NoInventoryReservationErrorItem): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "number" -> play.api.libs.json.JsString(obj.number),
        "requested_quantity" -> play.api.libs.json.JsNumber(obj.requestedQuantity),
        "available_quantity" -> play.api.libs.json.JsNumber(obj.availableQuantity)
      )
    }

    implicit def jsonWritesInventoryNoInventoryReservationErrorItem: play.api.libs.json.Writes[NoInventoryReservationErrorItem] = {
      new play.api.libs.json.Writes[io.flow.inventory.v0.models.NoInventoryReservationErrorItem] {
        def writes(obj: io.flow.inventory.v0.models.NoInventoryReservationErrorItem) = {
          jsObjectNoInventoryReservationErrorItem(obj)
        }
      }
    }

    implicit def jsonReadsInventoryPfsInventoryCheckResponse: play.api.libs.json.Reads[PfsInventoryCheckResponse] = {
      (__ \ "items").read[Map[String, io.flow.inventory.v0.models.PfsInventoryCheckResponseItem]].map { x => new PfsInventoryCheckResponse(items = x) }
    }

    def jsObjectPfsInventoryCheckResponse(obj: io.flow.inventory.v0.models.PfsInventoryCheckResponse): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "items" -> play.api.libs.json.Json.toJson(obj.items)
      )
    }

    implicit def jsonWritesInventoryPfsInventoryCheckResponse: play.api.libs.json.Writes[PfsInventoryCheckResponse] = {
      new play.api.libs.json.Writes[io.flow.inventory.v0.models.PfsInventoryCheckResponse] {
        def writes(obj: io.flow.inventory.v0.models.PfsInventoryCheckResponse) = {
          jsObjectPfsInventoryCheckResponse(obj)
        }
      }
    }

    implicit def jsonReadsInventoryPfsInventoryCheckResponseItem: play.api.libs.json.Reads[PfsInventoryCheckResponseItem] = {
      for {
        number <- (__ \ "number").read[String]
        ats <- (__ \ "ats").read[Long]
        inStock <- (__ \ "in_stock").read[Boolean]
      } yield PfsInventoryCheckResponseItem(number, ats, inStock)
    }

    def jsObjectPfsInventoryCheckResponseItem(obj: io.flow.inventory.v0.models.PfsInventoryCheckResponseItem): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "number" -> play.api.libs.json.JsString(obj.number),
        "ats" -> play.api.libs.json.JsNumber(obj.ats),
        "in_stock" -> play.api.libs.json.JsBoolean(obj.inStock)
      )
    }

    implicit def jsonWritesInventoryPfsInventoryCheckResponseItem: play.api.libs.json.Writes[PfsInventoryCheckResponseItem] = {
      new play.api.libs.json.Writes[io.flow.inventory.v0.models.PfsInventoryCheckResponseItem] {
        def writes(obj: io.flow.inventory.v0.models.PfsInventoryCheckResponseItem) = {
          jsObjectPfsInventoryCheckResponseItem(obj)
        }
      }
    }

    implicit def jsonReadsInventoryPfsInventoryStatus: play.api.libs.json.Reads[PfsInventoryStatus] = {
      (__ \ "status").read[String].map { x => new PfsInventoryStatus(status = x) }
    }

    def jsObjectPfsInventoryStatus(obj: io.flow.inventory.v0.models.PfsInventoryStatus): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "status" -> play.api.libs.json.JsString(obj.status)
      )
    }

    implicit def jsonWritesInventoryPfsInventoryStatus: play.api.libs.json.Writes[PfsInventoryStatus] = {
      new play.api.libs.json.Writes[io.flow.inventory.v0.models.PfsInventoryStatus] {
        def writes(obj: io.flow.inventory.v0.models.PfsInventoryStatus) = {
          jsObjectPfsInventoryStatus(obj)
        }
      }
    }

    implicit def jsonReadsInventoryReservation: play.api.libs.json.Reads[Reservation] = {
      for {
        id <- (__ \ "id").read[String]
        key <- (__ \ "key").read[String]
        order <- (__ \ "order").readNullable[io.flow.inventory.v0.models.ReservationOrderReference]
        items <- (__ \ "items").read[Seq[io.flow.inventory.v0.models.ReservationItem]]
      } yield Reservation(id, key, order, items)
    }

    def jsObjectReservation(obj: io.flow.inventory.v0.models.Reservation): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "key" -> play.api.libs.json.JsString(obj.key),
        "items" -> play.api.libs.json.Json.toJson(obj.items)
      ) ++ (obj.order match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("order" -> jsObjectReservationOrderReference(x))
      })
    }

    implicit def jsonWritesInventoryReservation: play.api.libs.json.Writes[Reservation] = {
      new play.api.libs.json.Writes[io.flow.inventory.v0.models.Reservation] {
        def writes(obj: io.flow.inventory.v0.models.Reservation) = {
          jsObjectReservation(obj)
        }
      }
    }

    implicit def jsonReadsInventoryReservationForm: play.api.libs.json.Reads[ReservationForm] = {
      for {
        orderNumber <- (__ \ "order_number").readNullable[String]
        items <- (__ \ "items").read[Seq[io.flow.inventory.v0.models.ReservationItemForm]]
      } yield ReservationForm(orderNumber, items)
    }

    def jsObjectReservationForm(obj: io.flow.inventory.v0.models.ReservationForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "items" -> play.api.libs.json.Json.toJson(obj.items)
      ) ++ (obj.orderNumber match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("order_number" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesInventoryReservationForm: play.api.libs.json.Writes[ReservationForm] = {
      new play.api.libs.json.Writes[io.flow.inventory.v0.models.ReservationForm] {
        def writes(obj: io.flow.inventory.v0.models.ReservationForm) = {
          jsObjectReservationForm(obj)
        }
      }
    }

    implicit def jsonReadsInventoryReservationItem: play.api.libs.json.Reads[ReservationItem] = {
      for {
        item <- (__ \ "item").read[io.flow.inventory.v0.models.ReservationItemReference]
        quantity <- (__ \ "quantity").read[Long]
      } yield ReservationItem(item, quantity)
    }

    def jsObjectReservationItem(obj: io.flow.inventory.v0.models.ReservationItem): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "item" -> jsObjectReservationItemReference(obj.item),
        "quantity" -> play.api.libs.json.JsNumber(obj.quantity)
      )
    }

    implicit def jsonWritesInventoryReservationItem: play.api.libs.json.Writes[ReservationItem] = {
      new play.api.libs.json.Writes[io.flow.inventory.v0.models.ReservationItem] {
        def writes(obj: io.flow.inventory.v0.models.ReservationItem) = {
          jsObjectReservationItem(obj)
        }
      }
    }

    implicit def jsonReadsInventoryReservationItemForm: play.api.libs.json.Reads[ReservationItemForm] = {
      for {
        itemNumber <- (__ \ "item_number").read[String]
        quantity <- (__ \ "quantity").read[Long]
      } yield ReservationItemForm(itemNumber, quantity)
    }

    def jsObjectReservationItemForm(obj: io.flow.inventory.v0.models.ReservationItemForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "item_number" -> play.api.libs.json.JsString(obj.itemNumber),
        "quantity" -> play.api.libs.json.JsNumber(obj.quantity)
      )
    }

    implicit def jsonWritesInventoryReservationItemForm: play.api.libs.json.Writes[ReservationItemForm] = {
      new play.api.libs.json.Writes[io.flow.inventory.v0.models.ReservationItemForm] {
        def writes(obj: io.flow.inventory.v0.models.ReservationItemForm) = {
          jsObjectReservationItemForm(obj)
        }
      }
    }

    implicit def jsonReadsInventoryReservationItemReference: play.api.libs.json.Reads[ReservationItemReference] = {
      (__ \ "number").read[String].map { x => new ReservationItemReference(number = x) }
    }

    def jsObjectReservationItemReference(obj: io.flow.inventory.v0.models.ReservationItemReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "number" -> play.api.libs.json.JsString(obj.number)
      )
    }

    implicit def jsonWritesInventoryReservationItemReference: play.api.libs.json.Writes[ReservationItemReference] = {
      new play.api.libs.json.Writes[io.flow.inventory.v0.models.ReservationItemReference] {
        def writes(obj: io.flow.inventory.v0.models.ReservationItemReference) = {
          jsObjectReservationItemReference(obj)
        }
      }
    }

    implicit def jsonReadsInventoryReservationOrderReference: play.api.libs.json.Reads[ReservationOrderReference] = {
      (__ \ "number").read[String].map { x => new ReservationOrderReference(number = x) }
    }

    def jsObjectReservationOrderReference(obj: io.flow.inventory.v0.models.ReservationOrderReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "number" -> play.api.libs.json.JsString(obj.number)
      )
    }

    implicit def jsonWritesInventoryReservationOrderReference: play.api.libs.json.Writes[ReservationOrderReference] = {
      new play.api.libs.json.Writes[io.flow.inventory.v0.models.ReservationOrderReference] {
        def writes(obj: io.flow.inventory.v0.models.ReservationOrderReference) = {
          jsObjectReservationOrderReference(obj)
        }
      }
    }

    implicit def jsonReadsInventorySerial: play.api.libs.json.Reads[Serial] = {
      for {
        id <- (__ \ "id").read[String]
        number <- (__ \ "number").read[String]
        itemNumber <- (__ \ "item_number").read[String]
        itemPrice <- (__ \ "item_price").read[io.flow.common.v0.models.Price]
        status <- (__ \ "status").read[io.flow.inventory.v0.models.SerialStatus]
        center <- (__ \ "center").read[io.flow.fulfillment.v0.models.CenterReference]
        attributes <- (__ \ "attributes").read[Map[String, String]]
      } yield Serial(id, number, itemNumber, itemPrice, status, center, attributes)
    }

    def jsObjectSerial(obj: io.flow.inventory.v0.models.Serial): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "number" -> play.api.libs.json.JsString(obj.number),
        "item_number" -> play.api.libs.json.JsString(obj.itemNumber),
        "item_price" -> io.flow.common.v0.models.json.jsObjectPrice(obj.itemPrice),
        "status" -> play.api.libs.json.JsString(obj.status.toString),
        "center" -> io.flow.fulfillment.v0.models.json.jsObjectCenterReference(obj.center),
        "attributes" -> play.api.libs.json.Json.toJson(obj.attributes)
      )
    }

    implicit def jsonWritesInventorySerial: play.api.libs.json.Writes[Serial] = {
      new play.api.libs.json.Writes[io.flow.inventory.v0.models.Serial] {
        def writes(obj: io.flow.inventory.v0.models.Serial) = {
          jsObjectSerial(obj)
        }
      }
    }

    implicit def jsonReadsInventorySerialForm: play.api.libs.json.Reads[SerialForm] = {
      for {
        number <- (__ \ "number").read[String]
        itemNumber <- (__ \ "item_number").read[String]
        itemPrice <- (__ \ "item_price").read[BigDecimal]
        itemCurrency <- (__ \ "item_currency").read[String]
        status <- (__ \ "status").read[io.flow.inventory.v0.models.SerialStatus]
        centerKey <- (__ \ "center_key").readNullable[String]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
      } yield SerialForm(number, itemNumber, itemPrice, itemCurrency, status, centerKey, attributes)
    }

    def jsObjectSerialForm(obj: io.flow.inventory.v0.models.SerialForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "number" -> play.api.libs.json.JsString(obj.number),
        "item_number" -> play.api.libs.json.JsString(obj.itemNumber),
        "item_price" -> play.api.libs.json.JsNumber(obj.itemPrice),
        "item_currency" -> play.api.libs.json.JsString(obj.itemCurrency),
        "status" -> play.api.libs.json.JsString(obj.status.toString)
      ) ++ (obj.centerKey match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("center_key" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesInventorySerialForm: play.api.libs.json.Writes[SerialForm] = {
      new play.api.libs.json.Writes[io.flow.inventory.v0.models.SerialForm] {
        def writes(obj: io.flow.inventory.v0.models.SerialForm) = {
          jsObjectSerialForm(obj)
        }
      }
    }

    implicit def jsonReadsInventorySerialVersion: play.api.libs.json.Reads[SerialVersion] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        serial <- (__ \ "serial").read[io.flow.inventory.v0.models.Serial]
      } yield SerialVersion(id, timestamp, `type`, serial)
    }

    def jsObjectSerialVersion(obj: io.flow.inventory.v0.models.SerialVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "serial" -> jsObjectSerial(obj.serial)
      )
    }

    implicit def jsonWritesInventorySerialVersion: play.api.libs.json.Writes[SerialVersion] = {
      new play.api.libs.json.Writes[io.flow.inventory.v0.models.SerialVersion] {
        def writes(obj: io.flow.inventory.v0.models.SerialVersion) = {
          jsObjectSerialVersion(obj)
        }
      }
    }

    implicit def jsonReadsInventoryInventoryStrategy: play.api.libs.json.Reads[InventoryStrategy] = new play.api.libs.json.Reads[InventoryStrategy] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[InventoryStrategy] = {
        (js \ "discriminator").asOpt[String].getOrElse { sys.error("Union[InventoryStrategy] requires a discriminator named 'discriminator' - this field was not found in the Json Value") } match {
          case "inventory_backorder" => js.validate[io.flow.inventory.v0.models.InventoryBackorder]
          case "inventory_stock" => js.validate[io.flow.inventory.v0.models.InventoryStock]
          case "inventory_unlimited" => js.validate[io.flow.inventory.v0.models.InventoryUnlimited]
          case other => play.api.libs.json.JsSuccess(io.flow.inventory.v0.models.InventoryStrategyUndefinedType(other))
        }
      }
    }

    def jsObjectInventoryStrategy(obj: io.flow.inventory.v0.models.InventoryStrategy): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.inventory.v0.models.InventoryBackorder => jsObjectInventoryBackorder(x) ++ play.api.libs.json.Json.obj("discriminator" -> "inventory_backorder")
        case x: io.flow.inventory.v0.models.InventoryStock => jsObjectInventoryStock(x) ++ play.api.libs.json.Json.obj("discriminator" -> "inventory_stock")
        case x: io.flow.inventory.v0.models.InventoryUnlimited => jsObjectInventoryUnlimited(x) ++ play.api.libs.json.Json.obj("discriminator" -> "inventory_unlimited")
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesInventoryInventoryStrategy: play.api.libs.json.Writes[InventoryStrategy] = {
      new play.api.libs.json.Writes[io.flow.inventory.v0.models.InventoryStrategy] {
        def writes(obj: io.flow.inventory.v0.models.InventoryStrategy) = {
          jsObjectInventoryStrategy(obj)
        }
      }
    }

    implicit def jsonReadsInventoryReservationError: play.api.libs.json.Reads[ReservationError] = new play.api.libs.json.Reads[ReservationError] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[ReservationError] = {
        (js \ "code").asOpt[String].getOrElse { sys.error("Union[ReservationError] requires a discriminator named 'code' - this field was not found in the Json Value") } match {
          case "no_inventory" => js.validate[io.flow.inventory.v0.models.NoInventoryReservationError]
          case "external_api_timeout" => js.validate[io.flow.inventory.v0.models.ExternalApiTimeoutReservationError]
          case "generic_reservation_error" => js.validate[io.flow.inventory.v0.models.GenericReservationError]
          case other => play.api.libs.json.JsSuccess(io.flow.inventory.v0.models.ReservationErrorUndefinedType(other))
        }
      }
    }

    def jsObjectReservationError(obj: io.flow.inventory.v0.models.ReservationError): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.inventory.v0.models.NoInventoryReservationError => jsObjectNoInventoryReservationError(x) ++ play.api.libs.json.Json.obj("code" -> "no_inventory")
        case x: io.flow.inventory.v0.models.ExternalApiTimeoutReservationError => jsObjectExternalApiTimeoutReservationError(x) ++ play.api.libs.json.Json.obj("code" -> "external_api_timeout")
        case x: io.flow.inventory.v0.models.GenericReservationError => jsObjectGenericReservationError(x) ++ play.api.libs.json.Json.obj("code" -> "generic_reservation_error")
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesInventoryReservationError: play.api.libs.json.Writes[ReservationError] = {
      new play.api.libs.json.Writes[io.flow.inventory.v0.models.ReservationError] {
        def writes(obj: io.flow.inventory.v0.models.ReservationError) = {
          jsObjectReservationError(obj)
        }
      }
    }
  }
}

package io.flow.inventory.v0 {

  object Bindables {

    import play.api.mvc.{PathBindable, QueryStringBindable}

    // import models directly for backwards compatibility with prior versions of the generator
    import Core._
    import Models._

    object Core {
      implicit def pathBindableDateTimeIso8601(implicit stringBinder: QueryStringBindable[String]): PathBindable[_root_.org.joda.time.DateTime] = ApibuilderPathBindable(ApibuilderTypes.dateTimeIso8601)
      implicit def queryStringBindableDateTimeIso8601(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[_root_.org.joda.time.DateTime] = ApibuilderQueryStringBindable(ApibuilderTypes.dateTimeIso8601)

      implicit def pathBindableDateIso8601(implicit stringBinder: QueryStringBindable[String]): PathBindable[_root_.org.joda.time.LocalDate] = ApibuilderPathBindable(ApibuilderTypes.dateIso8601)
      implicit def queryStringBindableDateIso8601(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[_root_.org.joda.time.LocalDate] = ApibuilderQueryStringBindable(ApibuilderTypes.dateIso8601)
    }

    object Models {
      import io.flow.inventory.v0.models._

      val aggregateConverter: ApibuilderTypeConverter[io.flow.inventory.v0.models.Aggregate] = new ApibuilderTypeConverter[io.flow.inventory.v0.models.Aggregate] {
        override def convert(value: String): io.flow.inventory.v0.models.Aggregate = io.flow.inventory.v0.models.Aggregate(value)
        override def convert(value: io.flow.inventory.v0.models.Aggregate): String = value.toString
        override def example: io.flow.inventory.v0.models.Aggregate = io.flow.inventory.v0.models.Aggregate.Maximum
        override def validValues: Seq[io.flow.inventory.v0.models.Aggregate] = io.flow.inventory.v0.models.Aggregate.all
      }
      implicit def pathBindableAggregate(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.inventory.v0.models.Aggregate] = ApibuilderPathBindable(aggregateConverter)
      implicit def queryStringBindableAggregate(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.inventory.v0.models.Aggregate] = ApibuilderQueryStringBindable(aggregateConverter)

      val inventoryStatusConverter: ApibuilderTypeConverter[io.flow.inventory.v0.models.InventoryStatus] = new ApibuilderTypeConverter[io.flow.inventory.v0.models.InventoryStatus] {
        override def convert(value: String): io.flow.inventory.v0.models.InventoryStatus = io.flow.inventory.v0.models.InventoryStatus(value)
        override def convert(value: io.flow.inventory.v0.models.InventoryStatus): String = value.toString
        override def example: io.flow.inventory.v0.models.InventoryStatus = io.flow.inventory.v0.models.InventoryStatus.HasInventory
        override def validValues: Seq[io.flow.inventory.v0.models.InventoryStatus] = io.flow.inventory.v0.models.InventoryStatus.all
      }
      implicit def pathBindableInventoryStatus(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.inventory.v0.models.InventoryStatus] = ApibuilderPathBindable(inventoryStatusConverter)
      implicit def queryStringBindableInventoryStatus(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.inventory.v0.models.InventoryStatus] = ApibuilderQueryStringBindable(inventoryStatusConverter)

      val serialStatusConverter: ApibuilderTypeConverter[io.flow.inventory.v0.models.SerialStatus] = new ApibuilderTypeConverter[io.flow.inventory.v0.models.SerialStatus] {
        override def convert(value: String): io.flow.inventory.v0.models.SerialStatus = io.flow.inventory.v0.models.SerialStatus(value)
        override def convert(value: io.flow.inventory.v0.models.SerialStatus): String = value.toString
        override def example: io.flow.inventory.v0.models.SerialStatus = io.flow.inventory.v0.models.SerialStatus.Available
        override def validValues: Seq[io.flow.inventory.v0.models.SerialStatus] = io.flow.inventory.v0.models.SerialStatus.all
      }
      implicit def pathBindableSerialStatus(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.inventory.v0.models.SerialStatus] = ApibuilderPathBindable(serialStatusConverter)
      implicit def queryStringBindableSerialStatus(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.inventory.v0.models.SerialStatus] = ApibuilderQueryStringBindable(serialStatusConverter)

      val updateTypeConverter: ApibuilderTypeConverter[io.flow.inventory.v0.models.UpdateType] = new ApibuilderTypeConverter[io.flow.inventory.v0.models.UpdateType] {
        override def convert(value: String): io.flow.inventory.v0.models.UpdateType = io.flow.inventory.v0.models.UpdateType(value)
        override def convert(value: io.flow.inventory.v0.models.UpdateType): String = value.toString
        override def example: io.flow.inventory.v0.models.UpdateType = io.flow.inventory.v0.models.UpdateType.Change
        override def validValues: Seq[io.flow.inventory.v0.models.UpdateType] = io.flow.inventory.v0.models.UpdateType.all
      }
      implicit def pathBindableUpdateType(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.inventory.v0.models.UpdateType] = ApibuilderPathBindable(updateTypeConverter)
      implicit def queryStringBindableUpdateType(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.inventory.v0.models.UpdateType] = ApibuilderQueryStringBindable(updateTypeConverter)
    }

    trait ApibuilderTypeConverter[T] {

      def convert(value: String): T

      def convert(value: T): String

      def example: T

      def validValues: Seq[T] = Nil

      def errorMessage(key: String, value: String, ex: java.lang.Exception): String = {
        val base = s"Invalid value '$value' for parameter '$key'. "
        validValues.toList match {
          case Nil => base + "Ex: " + convert(example)
          case values => base + ". Valid values are: " + values.mkString("'", "', '", "'")
        }
      }
    }

    object ApibuilderTypes {
      val dateTimeIso8601: ApibuilderTypeConverter[_root_.org.joda.time.DateTime] = new ApibuilderTypeConverter[_root_.org.joda.time.DateTime] {
        override def convert(value: String): _root_.org.joda.time.DateTime = _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseDateTime(value)
        override def convert(value: _root_.org.joda.time.DateTime): String = _root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(value)
        override def example: _root_.org.joda.time.DateTime = _root_.org.joda.time.DateTime.now
      }

      val dateIso8601: ApibuilderTypeConverter[_root_.org.joda.time.LocalDate] = new ApibuilderTypeConverter[_root_.org.joda.time.LocalDate] {
        override def convert(value: String): _root_.org.joda.time.LocalDate = _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseLocalDate(value)
        override def convert(value: _root_.org.joda.time.LocalDate): String = _root_.org.joda.time.format.ISODateTimeFormat.date.print(value)
        override def example: _root_.org.joda.time.LocalDate = _root_.org.joda.time.LocalDate.now
      }
    }

    final case class ApibuilderQueryStringBindable[T](
      converters: ApibuilderTypeConverter[T]
    ) extends QueryStringBindable[T] {

      override def bind(key: String, params: Map[String, Seq[String]]): _root_.scala.Option[_root_.scala.Either[String, T]] = {
        params.getOrElse(key, Nil).headOption.map { v =>
          try {
            Right(
              converters.convert(v)
            )
          } catch {
            case ex: java.lang.Exception => Left(
              converters.errorMessage(key, v, ex)
            )
          }
        }
      }

      override def unbind(key: String, value: T): String = {
        s"$key=${converters.convert(value)}"
      }
    }

    final case class ApibuilderPathBindable[T](
      converters: ApibuilderTypeConverter[T]
    ) extends PathBindable[T] {

      override def bind(key: String, value: String): _root_.scala.Either[String, T] = {
        try {
          Right(
            converters.convert(value)
          )
        } catch {
          case ex: java.lang.Exception => Left(
            converters.errorMessage(key, value, ex)
          )
        }
      }

      override def unbind(key: String, value: T): String = {
        converters.convert(value)
      }
    }

  }

}
