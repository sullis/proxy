/**
 * Generated by API Builder - https://www.apibuilder.io
 * Service version: 0.7.74
 * apibuilder 0.14.75 app.apibuilder.io/flow/fulfillment/0.7.74/play_2_x_json
 */
package io.flow.fulfillment.v0.models {

  /**
   * A delivery represents a group of items that will be delivered together -
   * presenting a single price and delivery time frame, where applicable, to the
   * user. Deliveries commonly are created based on the type of item and, for
   * physical goods, their center of origin
   */
  sealed trait Delivery extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * Defines the valid discriminator values for the type Delivery
   */
  sealed trait DeliveryDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object DeliveryDiscriminator {

    /**
     * Represents items that can be delivered electronically (e.g. a gift card
     * delivered via email)
     */
    case object DigitalDelivery extends DeliveryDiscriminator { override def toString = "digital_delivery" }
    /**
     * Represents items that are physical and require shipment
     */
    case object PhysicalDelivery extends DeliveryDiscriminator { override def toString = "physical_delivery" }

    final case class UNDEFINED(override val toString: String) extends DeliveryDiscriminator

    val all: scala.List[DeliveryDiscriminator] = scala.List(DigitalDelivery, PhysicalDelivery)

    private[this] val byName: Map[String, DeliveryDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): DeliveryDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[DeliveryDiscriminator] = byName.get(value.toLowerCase)

  }

  sealed trait ExpandableCenter extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * Defines the valid discriminator values for the type ExpandableCenter
   */
  sealed trait ExpandableCenterDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object ExpandableCenterDiscriminator {

    case object Center extends ExpandableCenterDiscriminator { override def toString = "center" }
    case object CenterReference extends ExpandableCenterDiscriminator { override def toString = "center_reference" }

    final case class UNDEFINED(override val toString: String) extends ExpandableCenterDiscriminator

    val all: scala.List[ExpandableCenterDiscriminator] = scala.List(Center, CenterReference)

    private[this] val byName: Map[String, ExpandableCenterDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ExpandableCenterDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ExpandableCenterDiscriminator] = byName.get(value.toLowerCase)

  }

  sealed trait PartnerCenterFee extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * Defines the valid discriminator values for the type PartnerCenterFee
   */
  sealed trait PartnerCenterFeeDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object PartnerCenterFeeDiscriminator {

    case object CommercialInvoiceFee extends PartnerCenterFeeDiscriminator { override def toString = "commercial_invoice_fee" }
    case object InboundCartonFee extends PartnerCenterFeeDiscriminator { override def toString = "inbound_carton_fee" }
    case object OutboundCartonFee extends PartnerCenterFeeDiscriminator { override def toString = "outbound_carton_fee" }

    final case class UNDEFINED(override val toString: String) extends PartnerCenterFeeDiscriminator

    val all: scala.List[PartnerCenterFeeDiscriminator] = scala.List(CommercialInvoiceFee, InboundCartonFee, OutboundCartonFee)

    private[this] val byName: Map[String, PartnerCenterFeeDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): PartnerCenterFeeDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[PartnerCenterFeeDiscriminator] = byName.get(value.toLowerCase)

  }

  /**
   * Possible outcome types from a tier rule
   */
  sealed trait TierRuleOutcome extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * Defines the valid discriminator values for the type TierRuleOutcome
   */
  sealed trait TierRuleOutcomeDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object TierRuleOutcomeDiscriminator {

    /**
     * Add a certain amount on the actual base cost
     */
    case object AmountMargin extends TierRuleOutcomeDiscriminator { override def toString = "amount_margin" }
    case object AtCost extends TierRuleOutcomeDiscriminator { override def toString = "at_cost" }
    case object FlatRate extends TierRuleOutcomeDiscriminator { override def toString = "flat_rate" }
    /**
     * Add a certain percentage of the actual base cost
     */
    case object PercentMargin extends TierRuleOutcomeDiscriminator { override def toString = "percent_margin" }

    final case class UNDEFINED(override val toString: String) extends TierRuleOutcomeDiscriminator

    val all: scala.List[TierRuleOutcomeDiscriminator] = scala.List(AmountMargin, AtCost, FlatRate, PercentMargin)

    private[this] val byName: Map[String, TierRuleOutcomeDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): TierRuleOutcomeDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[TierRuleOutcomeDiscriminator] = byName.get(value.toLowerCase)

  }

  sealed trait TierRuleOutcomeForm extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * Defines the valid discriminator values for the type TierRuleOutcomeForm
   */
  sealed trait TierRuleOutcomeFormDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object TierRuleOutcomeFormDiscriminator {

    case object AmountMarginForm extends TierRuleOutcomeFormDiscriminator { override def toString = "amount_margin_form" }
    case object FlatRateForm extends TierRuleOutcomeFormDiscriminator { override def toString = "flat_rate_form" }
    case object AtCost extends TierRuleOutcomeFormDiscriminator { override def toString = "at_cost" }
    case object PercentMargin extends TierRuleOutcomeFormDiscriminator { override def toString = "percent_margin" }

    final case class UNDEFINED(override val toString: String) extends TierRuleOutcomeFormDiscriminator

    val all: scala.List[TierRuleOutcomeFormDiscriminator] = scala.List(AmountMarginForm, FlatRateForm, AtCost, PercentMargin)

    private[this] val byName: Map[String, TierRuleOutcomeFormDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): TierRuleOutcomeFormDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[TierRuleOutcomeFormDiscriminator] = byName.get(value.toLowerCase)

  }

  /**
   * Rule outcome where shipping surfaced in quote is actual cost plus a predefined
   * margin price
   * 
   * @param margin Additional cost to be added to actual cost to get quote amount to show to
   *        customer
   */
  final case class AmountMargin(
    margin: io.flow.common.v0.models.Price
  ) extends TierRuleOutcome

  final case class AmountMarginForm(
    margin: io.flow.common.v0.models.Money
  ) extends TierRuleOutcomeForm

  /**
   * Rule outcome where shipping surfaced in quote is actual cost of the service
   */
  final case class AtCost(
    ignore: _root_.scala.Option[String] = None
  ) extends TierRuleOutcome with TierRuleOutcomeForm

  /**
   * Representation of a service level available at a center and the special pickup
   * times during the week. If pickup schedules are not provided, assumption is once
   * a day during the weekdays.
   * 
   * @param service Carrier service level ID
   * @param scheduledPickups Schedule day/times of carrier or affiliated line-haul pickup at this center. If
   *        not available, assume every day.
   * @param leadDays Additional lead time required for processing or freight-based domestic transit
   *        for this service from this center. This will go in to padding the final delivery
   *        windows.
   */
  final case class AvailableService(
    service: String,
    scheduledPickups: _root_.scala.Option[Seq[io.flow.fulfillment.v0.models.ScheduledPickup]] = None,
    leadDays: _root_.scala.Option[io.flow.fulfillment.v0.models.NumberRange] = None
  )

  final case class CarrierReference(
    id: String
  )

  /**
   * Represents a facility capable of fulfilling a shipment
   * 
   * @param key The key to use. If not provided, we will generate a unique key based on the
   *        name.
   * @param address Shipping address used for the 'from' field in generating carrier labels and
   *        customs-related documentation such as the CN22 or commercial invoice.
   * @param packaging Available types of packaging for shipment at this center
   * @param name Long name of the facility. ex: Fosdick CT, Quiet Logistics Andover
   * @param services List of carrier service levels available at this center
   * @param schedule Schedule of the origin center where shipment is originating. Contains normal
   *        operating hours, holiday periods, and cutoff.
   * @param timezone The timezone name. Case insensitive. See https://api.flow.io/reference/timezones
   * @param partnerCenter If a center operates as a crossdock this contains information about the
   *        crossdock
   */
  final case class Center(
    id: String,
    key: String,
    address: io.flow.fulfillment.v0.models.ShippingAddress,
    packaging: Seq[io.flow.fulfillment.v0.models.Packaging],
    name: String,
    services: Seq[io.flow.fulfillment.v0.models.AvailableService],
    schedule: io.flow.common.v0.models.Schedule,
    timezone: String,
    capabilities: _root_.scala.Option[Seq[io.flow.fulfillment.v0.models.CenterCapability]] = None,
    partnerCenter: _root_.scala.Option[io.flow.fulfillment.v0.models.PartnerCenter] = None
  ) extends ExpandableCenter

  /**
   * @param address Shipping address used for the 'from' field in generating carrier labels and
   *        customs-related documentation such as the CN22 or commercial invoice.
   * @param packaging Available types of packaging for shipment at this center
   * @param name Organization-provided name for the center
   * @param services List of carrier service levels available at this center
   * @param schedule Schedule of the origin center where shipment is originating. Contains normal
   *        operating hours, holiday periods, and cutoff.
   * @param timezone The timezone name. Case insensitive. See
   *        https://api.flow.io/reference/timezones. If not explicitly provided, Flow will
   *        estimate the timezone based on address of the Center.
   * @param key The key to use. If not provided, we will generate a unique key based on the
   *        name.
   * @param partnerCenterForm If a center operates as a crossdock this contains information about the
   *        crossdock
   */
  final case class CenterForm(
    address: io.flow.fulfillment.v0.models.ShippingAddress,
    packaging: Seq[io.flow.fulfillment.v0.models.Packaging],
    name: String,
    services: Seq[io.flow.fulfillment.v0.models.AvailableService],
    schedule: io.flow.common.v0.models.Schedule,
    timezone: _root_.scala.Option[String] = None,
    key: _root_.scala.Option[String] = None,
    capabilities: _root_.scala.Option[Seq[io.flow.fulfillment.v0.models.CenterCapability]] = None,
    partnerCenterForm: _root_.scala.Option[io.flow.fulfillment.v0.models.PartnerCenterForm] = None
  )

  /**
   * @param q The query used to search for centers
   */
  final case class CenterQuery(
    q: String
  )

  final case class CenterReference(
    organizationId: String,
    centerKey: String
  ) extends ExpandableCenter

  final case class CenterSummary(
    id: String,
    key: String
  )

  final case class CenterVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    center: io.flow.fulfillment.v0.models.Center
  )

  final case class CommercialInvoiceFee(
    amount: io.flow.common.v0.models.Money
  ) extends PartnerCenterFee

  /**
   * @param countries List of iso-3166-3 country codes. See https://api.flow.io/reference/countries.
   */
  final case class CountryAvailability(
    status: io.flow.fulfillment.v0.models.ItemAvailabilityStatus,
    countries: Seq[String]
  )

  /**
   * @param countries List of iso-3166-3 country codes. See https://api.flow.io/reference/countries.
   */
  final case class CountryShippingPricing(
    pricing: io.flow.fulfillment.v0.models.ItemShippingPricing,
    countries: Seq[String]
  )

  /**
   * @param shipmentEstimate For items that may not immediately ship out from the origin because of different
   *        models of inventory (e.g. drop-ship, sell-first), this is a way for a client to
   *        communicate when the items can ship out. This will be used to calculate delivery
   *        option windows.
   * @param price The price of this item for this order. If not specified, we will use the item
   *        price from the experience
   * @param attributes A set of key/value pairs that you can attach to the order. It can be useful for
   *        storing additional information about the charge in a structured format.
   * @param center Optional center key associated with this item. Used for orders and quotes to
   *        specify where to ship an item from. If not specified, Flow will infer based on
   *        inventory setup.
   * @param discount The total discount, if any, to apply to this line item. Note that the discount
   *        is the total discount to apply regardless of the quantity here
   */
  final case class DeliveryItem(
    number: String,
    quantity: Long,
    shipmentEstimate: _root_.scala.Option[io.flow.common.v0.models.DatetimeRange] = None,
    price: _root_.scala.Option[io.flow.common.v0.models.MoneyWithOptionalBase] = None,
    attributes: _root_.scala.Option[Map[String, String]] = None,
    center: _root_.scala.Option[String] = None,
    discount: _root_.scala.Option[io.flow.common.v0.models.MoneyWithOptionalBase] = None
  )

  /**
   * Represents a way to fulfill a delivery, including an estimates for the date
   * range and cost
   * 
   * @param cost Sum of all cost details, including actual shipping cost and any fees levied by
   *        partner center or shipping carrier.
   * @param price Price of shipping to be used for the end-customer selecting this option. Can be
   *        actual cost, etc.
   * @param ruleOutcome Tier rule outcome used to generate the delivery option price. This would be an
   *        indication whether something was a flat rate or at cost.
   * @param sendTo Intermediate destination required before going to final destination
   * @param surcharge Surcharges to be paid for by the end-customer.
   */
  final case class DeliveryOption(
    id: String,
    cost: io.flow.fulfillment.v0.models.PriceWithBaseAndDetails,
    deliveredDuty: io.flow.common.v0.models.DeliveredDuty,
    price: io.flow.fulfillment.v0.models.PriceWithBaseAndDetails,
    service: io.flow.fulfillment.v0.models.ServiceSummary,
    tier: io.flow.fulfillment.v0.models.TierSummary,
    window: io.flow.fulfillment.v0.models.DeliveryWindow,
    ruleOutcome: _root_.scala.Option[io.flow.fulfillment.v0.models.TierRuleOutcome] = None,
    weight: _root_.scala.Option[io.flow.fulfillment.v0.models.OptionWeightEstimates] = None,
    sendTo: _root_.scala.Option[io.flow.fulfillment.v0.models.ShippingAddress] = None,
    surcharge: _root_.scala.Option[io.flow.fulfillment.v0.models.PriceWithBaseAndDetails] = None
  )

  /**
   * @param currency The ISO-4217 3 character currency code in which the amount is calculated.
   * @param amount Sum of all delivery option cost components in this detail.
   * @param label The formatted label for this cost detail that should be displayed to the user.
   * @param base The amount of this cost detail in the base currency of the organization.
   */
  final case class DeliveryOptionCostComponent(
    key: io.flow.fulfillment.v0.models.DeliveryOptionCostDetailComponentKey,
    currency: String,
    amount: BigDecimal,
    label: String,
    base: _root_.scala.Option[io.flow.common.v0.models.Price] = None
  )

  /**
   * @param source Source of the cost detail
   * @param currency The ISO-4217 3 character currency code in which the amount is calculated.
   * @param amount Sum of all delivery option cost components in this detail.
   * @param label The formatted label for this cost detail that should be displayed to the user.
   * @param base The amount of this cost detail in the base currency of the organization.
   */
  final case class DeliveryOptionCostDetail(
    source: io.flow.fulfillment.v0.models.DeliveryOptionCostDetailSource,
    currency: String,
    amount: BigDecimal,
    label: String,
    base: _root_.scala.Option[io.flow.common.v0.models.Price] = None,
    components: Seq[io.flow.fulfillment.v0.models.DeliveryOptionCostComponent]
  )

  /**
   * Represents a way to fulfill a delivery, including an estimates for the date
   * range and cost
   */
  final case class DeliveryOptionForm(
    delivery: String,
    items: Seq[io.flow.fulfillment.v0.models.QuoteLineItemForm],
    destination: io.flow.fulfillment.v0.models.ShippingAddress
  )

  final case class DeliveryOptionReference(
    id: String
  )

  /**
   * @param cost Actual shipping cost to be charged to the merchant by Flow
   * @param price Price of shipping to be used for the end-customer selecting this option. Can be
   *        actual cost, etc.
   */
  final case class DeliveryOptionSummary(
    id: String,
    cost: io.flow.common.v0.models.Price,
    deliveredDuty: io.flow.common.v0.models.DeliveredDuty,
    price: io.flow.common.v0.models.Price,
    service: io.flow.fulfillment.v0.models.ServiceReference,
    tier: io.flow.fulfillment.v0.models.TierReference,
    window: io.flow.common.v0.models.DatetimeRange
  )

  final case class DeliveryOptionVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    deliveryOption: io.flow.fulfillment.v0.models.DeliveryOptionSummary
  )

  final case class DeliverySummary(
    id: String,
    items: Seq[io.flow.common.v0.models.LineItemForm]
  )

  final case class DeliveryVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    delivery: io.flow.fulfillment.v0.models.DeliverySummary
  )

  /**
   * Flow's estimate of when a shipment for this delivery will actually arrive at the
   * final destination, taking into account a shipment estimate, center schedules,
   * and carrier transit windows.
   * 
   * @param timezone Timezone of the destination based on the destination address of the shipment.
   */
  final case class DeliveryWindow(
    from: _root_.org.joda.time.DateTime,
    to: _root_.org.joda.time.DateTime,
    timezone: _root_.scala.Option[String] = None,
    label: _root_.scala.Option[String] = None
  )

  /**
   * @param source Did this come from Flow, carrier, organization, center, etc.
   */
  final case class DeliveryWindowComponent(
    from: _root_.org.joda.time.DateTime,
    to: _root_.org.joda.time.DateTime,
    source: io.flow.fulfillment.v0.models.DeliveryWindowComponentSource
  )

  /**
   * Components and information taken into account when calculating a final delivery
   * window.
   * 
   * @param shipmentEstimate Estimate of when a delivery may leave the center. Flow will usually come up with
   *        an estimate, but this may be provided directly from an organization if they are
   *        using a drop-ship/sell-first model of fulfillment.
   * @param transitEstimate Estimate of days in actual transit from leaving the center to arriving at final
   *        destination.
   */
  final case class DeliveryWindowComponents(
    shipmentEstimate: io.flow.fulfillment.v0.models.DeliveryWindowComponent,
    transitEstimate: io.flow.fulfillment.v0.models.DeliveryWindowComponent
  )

  /**
   * Components and information taken into account when calculating a final delivery
   * window
   * 
   * @param processingEstimates Estimates for time each facility takes to process a shipment. This can represent
   *        center, dropship / sell-first, or crossdock processing time
   * @param transitEstimates Estimates for time each portion of shipping takes. If no crossdock is used there
   *        will be a single transit estimate. If a crossdock is used there will be two
   *        transit estimates
   */
  final case class DeliveryWindowComponentsV2(
    processingEstimates: Seq[io.flow.fulfillment.v0.models.ProcessingEstimate],
    transitEstimates: Seq[io.flow.fulfillment.v0.models.TransitEstimate]
  )

  /**
   * Represents a collection of items that are digitally available and do not require
   * a physical shipment
   */
  final case class DigitalDelivery(
    id: String,
    items: Seq[io.flow.fulfillment.v0.models.DeliveryItem]
  ) extends Delivery

  /**
   * Range of time given a from and to number and the unit. For example: 1-4 hours or
   * 4-7 days
   */
  final case class EstimatedWindow(
    from: Long,
    to: Long,
    unit: io.flow.common.v0.models.UnitOfTime
  )

  /**
   * Rule outcome where shipping surfaced in quote is pre-defined flat rate
   * 
   * @param zeroAmountIndicator When a price is zero, this indicates whether `label` should be `free` or `0`
   */
  final case class FlatRate(
    price: io.flow.common.v0.models.Price,
    zeroAmountIndicator: _root_.scala.Option[io.flow.fulfillment.v0.models.ZeroAmountIndicator] = None
  ) extends TierRuleOutcome

  /**
   * @param zeroAmountIndicator When a price is zero, this indicates whether `label` should be `free` or `0`
   */
  final case class FlatRateForm(
    price: io.flow.common.v0.models.Money,
    zeroAmountIndicator: _root_.scala.Option[io.flow.fulfillment.v0.models.ZeroAmountIndicator] = None
  ) extends TierRuleOutcomeForm

  /**
   * @param currency ISO 4217 3 currency code as defined in https://api.flow.io/reference/currencies
   */
  final case class FulfillmentExperienceReference(
    id: String,
    currency: String
  )

  final case class InboundCartonFee(
    amount: io.flow.common.v0.models.Money
  ) extends PartnerCenterFee

  /**
   * Available shipping price(s) a customer sees. This can be used for targetted ads
   * on Google or to display shipping price(s) on a PDP.
   * 
   * @param min Minimum possible amount a customer might pay.
   * @param max If different than the minimum available price, then this is provided.
   */
  final case class ItemShippingPricing(
    min: io.flow.common.v0.models.Price,
    max: _root_.scala.Option[io.flow.common.v0.models.Price] = None
  )

  final case class NumberRange(
    min: Long,
    max: Long
  )

  final case class OptionWeightEstimates(
    gravitational: io.flow.common.v0.models.Measurement,
    dimensional: io.flow.common.v0.models.Measurement
  )

  final case class OutboundCartonFee(
    amount: io.flow.common.v0.models.Money
  ) extends PartnerCenterFee

  /**
   * Represents packaging available to ship items
   * 
   * @param name User-friendly name for the package. Defaults to concatenation of dimension
   *        values. e.g. box-12x4x30
   */
  final case class Packaging(
    dimensions: io.flow.common.v0.models.Dimensions,
    name: _root_.scala.Option[String] = None,
    number: _root_.scala.Option[String] = None
  )

  /**
   * Represents information about a partner (e.g. external 3PL) running the
   * fulfillment center
   * 
   * @param partnerReference Partner that is associated with this crossdock center
   * @param number Identifier used by the partner for this center
   */
  final case class PartnerCenter(
    partnerReference: io.flow.common.v0.models.PartnerReference,
    number: _root_.scala.Option[String] = None,
    fees: _root_.scala.Option[Seq[io.flow.fulfillment.v0.models.PartnerCenterFee]] = None
  )

  /**
   * @param partnerId Partner that is associated with this crossdock center
   * @param number Identifier used by the partner for this center
   */
  final case class PartnerCenterForm(
    partnerId: String,
    number: _root_.scala.Option[String] = None,
    fees: _root_.scala.Option[Seq[io.flow.fulfillment.v0.models.PartnerCenterFee]] = None
  )

  /**
   * Rule outcome where shipping surfaced in quote is actual cost plus a predefined
   * margin percentage
   * 
   * @param percentage Percentage of the cost to be added to actual cost to get quote amount to show to
   *        customer
   */
  final case class PercentMargin(
    percentage: Double
  ) extends TierRuleOutcome with TierRuleOutcomeForm

  /**
   * Represents a collection of items, the available delivery option tier for that
   * collection of items, and metadata about those options
   * 
   * @param center Origin center for this delivery.
   * @param specialServices List of special services associated with transport or delivery of this physical
   *        shipment.
   */
  final case class PhysicalDelivery(
    id: String,
    center: _root_.scala.Option[io.flow.fulfillment.v0.models.CenterSummary] = None,
    items: Seq[io.flow.fulfillment.v0.models.DeliveryItem],
    options: Seq[io.flow.fulfillment.v0.models.DeliveryOption],
    specialServices: _root_.scala.Option[Seq[io.flow.fulfillment.v0.models.PhysicalDeliverySpecialSerivce]] = None
  ) extends Delivery

  /**
   * @param currency Iso 4217 3 currency code as defined in https://api.flow.io/reference/currencies
   * @param label The localized label of the amount and currency
   */
  final case class PriceWithBaseAndDetails(
    currency: String,
    amount: Double,
    label: String,
    base: _root_.scala.Option[io.flow.common.v0.models.Price] = None,
    details: _root_.scala.Option[Seq[io.flow.fulfillment.v0.models.DeliveryOptionCostDetail]] = None
  )

  /**
   * @param location Location of where the package is being processed
   * @param source Did this come from Flow, carrier, organization, center, etc.
   */
  final case class ProcessingEstimate(
    location: io.flow.fulfillment.v0.models.DeliveryWindowLocation,
    minDate: _root_.org.joda.time.DateTime,
    maxDate: _root_.org.joda.time.DateTime,
    source: io.flow.fulfillment.v0.models.DeliveryWindowComponentSource
  )

  /**
   * Represents a collection of deliveries and available options for fulfillment of
   * that delivery
   * 
   * @param selections Selected options for the quote. This is used to prepare accurate fully-landed
   *        costs of an order and can also be used to pre-select a delivery option on a
   *        typical checkout page. By default, the option(s) shown here are part of the
   *        default tier of an experience. If no default tier has been designated for the
   *        tier group, the default selection would be the first option in the list.
   * @param deliveredDuty Desired delivered duty options to be returned as part of this quote. If not
   *        provided, default to paid.
   * @param deliveredDuties Desired delivered duty options to be returned as part of this quote
   */
  final case class Quote(
    id: String,
    destination: io.flow.fulfillment.v0.models.ShippingAddress,
    deliveries: Seq[io.flow.fulfillment.v0.models.Delivery],
    selections: Seq[io.flow.fulfillment.v0.models.DeliveryOptionReference],
    deliveredDuty: io.flow.common.v0.models.DeliveredDuty = io.flow.common.v0.models.DeliveredDuty.Paid,
    deliveredDuties: Seq[io.flow.common.v0.models.DeliveredDuty]
  )

  /**
   * @param messages A summary of the errors
   * @param itemNumbers A list of of the item numbers that are not available in inventory
   */
  final case class QuoteError(
    code: io.flow.fulfillment.v0.models.QuoteErrorCode,
    messages: Seq[String],
    itemNumbers: _root_.scala.Option[Seq[String]] = None
  )

  /**
   * @param experience Experience to use for the region of this quote
   * @param deliveredDuty Desired delivered duty options to be returned as part of this quote. If not
   *        provided, service will use all available rates.
   * @param deliveredDuties Desired delivered duty options to be returned as part of this quote. If not
   *        provided, service will use all available rates.
   * @param direction Quote is for outbound shipment or return shipment. If not provided, will assume
   *        status quo of outbound shipment.
   */
  final case class QuoteForm(
    destination: io.flow.fulfillment.v0.models.ShippingAddress,
    experience: String,
    items: Seq[io.flow.fulfillment.v0.models.QuoteLineItemForm],
    deliveredDuty: _root_.scala.Option[io.flow.common.v0.models.DeliveredDuty] = None,
    deliveredDuties: _root_.scala.Option[Seq[io.flow.common.v0.models.DeliveredDuty]] = None,
    direction: _root_.scala.Option[io.flow.fulfillment.v0.models.TierDirection] = None
  )

  /**
   * Line items and relevant attributes. Similar to common.line_item_form, but price
   * is a money_with_optional_base
   * 
   * @param shipmentEstimate For items that may not immediately ship out from the origin because of different
   *        models of inventory (e.g. drop-ship, sell-first), this is a way for a client to
   *        communicate when the items can ship out. This will be used to calculate delivery
   *        option windows.
   * @param price The price of this item for this order. If not specified, we will use the item
   *        price from the experience
   * @param attributes A set of key/value pairs that you can attach to the order. It can be useful for
   *        storing additional information about the charge in a structured format.
   * @param center Optional center key associated with this item. Used for orders and quotes to
   *        specify where to ship an item from. If not specified, Flow will infer based on
   *        inventory setup.
   * @param discount The total discount, if any, to apply to this line item. Note that the discount
   *        is the total discount to apply regardless of the quantity here
   * @param discounts The discounts, if any, to apply to this line item. Note that the discount is the
   *        total discount to apply regardless of the quantity here
   */
  final case class QuoteLineItemForm(
    number: String,
    quantity: Long,
    shipmentEstimate: _root_.scala.Option[io.flow.common.v0.models.DatetimeRange] = None,
    price: _root_.scala.Option[io.flow.common.v0.models.MoneyWithBase] = None,
    attributes: _root_.scala.Option[Map[String, String]] = None,
    center: _root_.scala.Option[String] = None,
    discount: _root_.scala.Option[io.flow.common.v0.models.Money] = None,
    discounts: _root_.scala.Option[io.flow.common.v0.models.DiscountsForm] = None
  )

  final case class QuoteSummary(
    id: String,
    destination: io.flow.fulfillment.v0.models.ShippingAddress
  )

  final case class QuoteVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    quote: io.flow.fulfillment.v0.models.QuoteSummary
  )

  /**
   * @param dayOfWeek Day of week when a pickup might occur
   * @param hourOfDay Local time hour of the day in military format. Valid values: 00-23
   * @param minuteOfHour Minute within the hour. Valid values: 00-59
   */
  final case class ScheduledPickup(
    dayOfWeek: io.flow.common.v0.models.DayOfWeek,
    hourOfDay: String,
    minuteOfHour: String
  )

  final case class ServiceReference(
    id: String
  )

  /**
   * @param centerCode Optional identifier for the service level at the organization's center. This
   *        code can be used to communicate service level to the center/3PL.
   */
  final case class ServiceSummary(
    id: String,
    carrier: io.flow.fulfillment.v0.models.CarrierReference,
    name: String,
    centerCode: _root_.scala.Option[String] = None
  )

  /**
   * @param contact Contact information of entity at the address
   * @param location Attributes of the physical location
   * @param centerReference If this address corresponds to a center this is information about the center
   * @param service Carrier service ID going to intermediate destination in `send_to`
   */
  final case class ShippingAddress(
    contact: io.flow.common.v0.models.Contact,
    location: io.flow.common.v0.models.Address,
    @deprecated("This field is deprecated. Please use the 'center_reference' field") centerKey: _root_.scala.Option[String] = None,
    centerReference: _root_.scala.Option[io.flow.fulfillment.v0.models.CenterReference] = None,
    service: _root_.scala.Option[io.flow.fulfillment.v0.models.ServiceSummary] = None
  )

  final case class ShippingConfiguration(
    id: String,
    name: String,
    key: String,
    `type`: io.flow.fulfillment.v0.models.ShippingConfigurationType,
    shippingLanes: Seq[io.flow.fulfillment.v0.models.ShippingLane]
  )

  /**
   * @param original The shipping configuration being copied
   * @param `new` The new shipping configuration
   */
  final case class ShippingConfigurationCopy(
    original: io.flow.fulfillment.v0.models.ShippingConfigurationReference,
    `new`: io.flow.fulfillment.v0.models.ShippingConfigurationReference
  )

  /**
   * @param name The name of the shipping configuration to be added
   */
  final case class ShippingConfigurationCopyForm(
    name: String
  )

  /**
   * @param name The name of the shipping configuration to be added
   */
  final case class ShippingConfigurationForm(
    name: String
  )

  /**
   * Denormalized availability status of an item in a shipping configuration for a
   * destination region
   */
  final case class ShippingConfigurationItemAvailability(
    id: String,
    item: io.flow.common.v0.models.ItemReference,
    shippingConfiguration: io.flow.fulfillment.v0.models.ShippingConfigurationSummary,
    availabilities: Seq[io.flow.fulfillment.v0.models.CountryAvailability]
  )

  /**
   * Denormalized shipping pricing available for a customer of an item in a shipping
   * configuration for a destination region.
   */
  final case class ShippingConfigurationItemShippingPricing(
    id: String,
    item: io.flow.common.v0.models.ItemReference,
    shippingConfiguration: io.flow.fulfillment.v0.models.ShippingConfigurationSummary,
    countryShippingPricings: Seq[io.flow.fulfillment.v0.models.CountryShippingPricing]
  )

  final case class ShippingConfigurationReference(
    key: String
  )

  final case class ShippingConfigurationSummary(
    id: String,
    name: String,
    key: String,
    `type`: io.flow.fulfillment.v0.models.ShippingConfigurationType
  )

  final case class ShippingConfigurationVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    shippingConfiguration: io.flow.fulfillment.v0.models.ShippingConfiguration
  )

  /**
   * @param shippingConfiguration The shipping configuration reference this lane belongs to
   * @param region The destination region for this shipping lane
   * @param centers The origin centers this lane can ship from
   * @param query Query used to retrieve centers
   * @param strategy Specifies strategy for picking center that will fulfill deliveries for the
   *        shipping lane when multiple centers are available as origins and are capable of
   *        shipping to the destination
   */
  final case class ShippingLane(
    id: String,
    shippingConfiguration: io.flow.fulfillment.v0.models.ShippingConfigurationReference,
    region: String,
    centers: Seq[io.flow.fulfillment.v0.models.ExpandableCenter],
    tiers: Seq[io.flow.fulfillment.v0.models.Tier],
    query: io.flow.query.builder.v0.models.Query,
    strategy: io.flow.fulfillment.v0.models.LaneStrategy = io.flow.fulfillment.v0.models.LaneStrategy.Oldest
  )

  /**
   * @param from The query used to select the origin centers for this shipping lane
   * @param to The destination region for this shipping lane
   * @param strategy Specifies strategy for picking center that will fulfill deliveries for the
   *        shipping lane when multiple centers are available as origins and are capable of
   *        shipping to the destination
   */
  final case class ShippingLaneForm(
    from: String,
    to: String,
    strategy: _root_.scala.Option[io.flow.fulfillment.v0.models.LaneStrategy] = None
  )

  final case class ShippingLaneVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    shippingLane: io.flow.fulfillment.v0.models.ShippingLane
  )

  /**
   * Surcharge responsible parties that can be displayed and selected
   * 
   * @param name Display name of the responsible party
   * @param responsibleParty The responsible party model value
   */
  final case class SurchargeResponsiblePartyDisplay(
    name: String,
    responsibleParty: io.flow.fulfillment.v0.models.SurchargeResponsibleParty
  )

  /**
   * @param responsibleParty Who is responsible for paying the surcharge
   */
  final case class SurchargeSetting(
    key: io.flow.fulfillment.v0.models.DeliveryOptionCostDetailComponentKey,
    responsibleParty: io.flow.fulfillment.v0.models.SurchargeResponsibleParty
  )

  /**
   * Surcharge settings that can be displayed and configured
   * 
   * @param name Display name of the surcharge setting
   * @param description Detailed description that could be displayed as a tooltip
   * @param key The delivery option model key
   * @param available The available options to display
   */
  final case class SurchargeSettingDisplay(
    name: String,
    description: String,
    key: io.flow.fulfillment.v0.models.DeliveryOptionCostDetailComponentKey,
    available: Seq[io.flow.fulfillment.v0.models.SurchargeResponsiblePartyDisplay]
  )

  /**
   * Service shipping tier available in this tier group. e.g. Standard tier, Express
   * tier, Economy tier
   * 
   * @param integration Type of shipping integration used for this tier.
   * @param message Optional message to show with the shipping tier name.
   * @param rules Ordered set of rules for this tier
   * @param services Services associated with this tier
   * @param strategy If multiple available return outcomes for a single tier, strategy picks the top
   *        one based on cost or timing.
   * @param visibility Public or Private. Private ones appear as inactive/disabled to the public
   * @param currency Currency to be used for the tier. May be different from the experience currency,
   *        but enforce all rules use this currency. ISO 4217 3 currency code as defined in
   *        https://api.flow.io/reference/currencies
   * @param description Description of the tier intended for internal description of return tiers or
   *        could be used for caption/tooltips on a checkout page.
   * @param shippingLane If this tier belongs to the shipping lane this is the corresponding shipping
   *        lane id
   * @param surchargeSettings The apportionment of additional shipping surcharges and fees that may be levied
   *        by some carriers
   */
  final case class Tier(
    id: String,
    direction: io.flow.fulfillment.v0.models.TierDirection = io.flow.fulfillment.v0.models.TierDirection.Outbound,
    integration: io.flow.fulfillment.v0.models.ShipmentIntegrationType,
    name: String,
    message: _root_.scala.Option[String] = None,
    rules: Seq[io.flow.fulfillment.v0.models.TierRule],
    services: Seq[io.flow.reference.v0.models.CarrierService],
    strategy: io.flow.fulfillment.v0.models.TierStrategy,
    visibility: io.flow.common.v0.models.Visibility,
    currency: String,
    description: _root_.scala.Option[String] = None,
    display: _root_.scala.Option[io.flow.fulfillment.v0.models.TierDisplay] = None,
    shippingLane: _root_.scala.Option[String] = None,
    surchargeSettings: _root_.scala.Option[Seq[io.flow.fulfillment.v0.models.SurchargeSetting]] = None
  )

  /**
   * @param estimate Contains delivery estimate data, generally used to indicate when an item will
   *        arrive.
   */
  final case class TierDisplay(
    estimate: io.flow.fulfillment.v0.models.TierEstimate
  )

  final case class TierDisplayForm(
    estimate: _root_.scala.Option[io.flow.fulfillment.v0.models.TierEstimate] = None
  )

  /**
   * @param `type` Indicates the origin of the label, e.g. custom or calculated.
   * @param label The text describing the estimated delivery window, if available.
   */
  final case class TierEstimate(
    `type`: io.flow.fulfillment.v0.models.TierEstimateType,
    label: _root_.scala.Option[String] = None
  )

  /**
   * Service shipping tier available in this tier group. e.g. Standard tier, Express
   * tier, Economy tier
   * 
   * @param currency Currency to be used for the tier. May be different from the experience currency,
   *        but enforce all rules use this currency. ISO 4217 3 currency code as defined in
   *        https://api.flow.io/reference/currencies
   * @param integration Type of shipping integration used for this tier.
   * @param message Optional message to show with the shipping tier name.
   * @param rules Ordered set of rules for this tier
   * @param services Services associated with this tier
   * @param strategy If multiple available return outcomes for a single tier, strategy picks the top
   *        one based on cost or timing.
   * @param visibility Public or Private. Private ones appear as inactive/disabled to the public
   * @param description Description of the tier intended for internal description of return tiers or
   *        could be used for caption/tooltips on a checkout page.
   * @param shippingLane The id of the shipping lane this tier belongs to
   * @param surchargeSettings How to apportion additional shipping surcharges and fees that may be levied by
   *        some carriers
   */
  final case class TierForm(
    currency: String,
    integration: io.flow.fulfillment.v0.models.ShipmentIntegrationType,
    name: String,
    message: _root_.scala.Option[String] = None,
    rules: Seq[io.flow.fulfillment.v0.models.TierRuleForm],
    services: Seq[String],
    strategy: io.flow.fulfillment.v0.models.TierStrategy,
    visibility: io.flow.common.v0.models.Visibility,
    description: _root_.scala.Option[String] = None,
    direction: _root_.scala.Option[io.flow.fulfillment.v0.models.TierDirection] = None,
    display: _root_.scala.Option[io.flow.fulfillment.v0.models.TierDisplayForm] = None,
    shippingLane: String,
    surchargeSettings: _root_.scala.Option[Seq[io.flow.fulfillment.v0.models.SurchargeSetting]] = None
  )

  final case class TierReference(
    id: String
  )

  /**
   * System to filter incoming quote for a shipment request based on a query and
   * output corresponding outcomes.
   * 
   * @param position Execution position of this rule relative to other rules in the tier. Lower
   *        position numbers indicate rules that should be executed earlier.
   * @param query Search API query
   * @param outcome Resulting cost function applied if query is met. e.g. service cost, flat rate
   */
  final case class TierRule(
    id: String,
    position: Long,
    query: String,
    outcome: io.flow.fulfillment.v0.models.TierRuleOutcome
  )

  /**
   * @param position Execution position of this rule relative to other rules in the tier. Lower
   *        position numbers indicate rules that should be executed earlier. If not
   *        specified, we automatically set the position to be last.
   */
  final case class TierRuleForm(
    position: _root_.scala.Option[Long] = None,
    query: String,
    outcome: io.flow.fulfillment.v0.models.TierRuleOutcomeForm
  )

  final case class TierRuleVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    tierRule: io.flow.fulfillment.v0.models.TierRule
  )

  /**
   * @param integration Type of shipping integration used for this tier.
   * @param services Services associated with this tier
   * @param strategy If multiple available return outcomes for a single tier, strategy picks the top
   *        one based on cost or timing.
   * @param visibility Public or Private. Private ones appear as inactive/disabled to the public
   * @param currency Currency to be used for the tier. May be different from the experience currency,
   *        but enforce all rules use this currency. ISO 4217 3 currency code as defined in
   *        https://api.flow.io/reference/currencies
   * @param display Contains the display text for this tier.
   * @param message Optional message to show with the shipping tier name.
   */
  final case class TierSummary(
    id: String,
    experience: _root_.scala.Option[io.flow.fulfillment.v0.models.FulfillmentExperienceReference] = None,
    integration: io.flow.fulfillment.v0.models.ShipmentIntegrationType,
    name: String,
    services: Seq[String],
    strategy: io.flow.fulfillment.v0.models.TierStrategy,
    visibility: io.flow.common.v0.models.Visibility,
    currency: String,
    display: _root_.scala.Option[io.flow.fulfillment.v0.models.TierDisplay] = None,
    message: _root_.scala.Option[String] = None
  )

  final case class TierVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    tier: io.flow.fulfillment.v0.models.TierSummary
  )

  /**
   * @param origin Location of where the package is shipping from
   * @param destination Location of where the package is shipping to
   * @param source Did this come from Flow, carrier, organization, center, etc.
   */
  final case class TransitEstimate(
    origin: io.flow.fulfillment.v0.models.DeliveryWindowLocation,
    destination: io.flow.fulfillment.v0.models.DeliveryWindowLocation,
    minDate: _root_.org.joda.time.DateTime,
    maxDate: _root_.org.joda.time.DateTime,
    source: io.flow.fulfillment.v0.models.DeliveryWindowComponentSource
  )

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union Delivery, it will need to be handled in the client code. This
   * implementation will deserialize these future types as an instance of this class.
   * 
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  final case class DeliveryUndefinedType(
    description: String
  ) extends Delivery

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union ExpandableCenter, it will need to be handled in the client code.
   * This implementation will deserialize these future types as an instance of this
   * class.
   * 
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  final case class ExpandableCenterUndefinedType(
    description: String
  ) extends ExpandableCenter

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union PartnerCenterFee, it will need to be handled in the client code.
   * This implementation will deserialize these future types as an instance of this
   * class.
   * 
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  final case class PartnerCenterFeeUndefinedType(
    description: String
  ) extends PartnerCenterFee

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union TierRuleOutcome, it will need to be handled in the client code.
   * This implementation will deserialize these future types as an instance of this
   * class.
   * 
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  final case class TierRuleOutcomeUndefinedType(
    description: String
  ) extends TierRuleOutcome

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union TierRuleOutcomeForm, it will need to be handled in the client code.
   * This implementation will deserialize these future types as an instance of this
   * class.
   * 
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  final case class TierRuleOutcomeFormUndefinedType(
    description: String
  ) extends TierRuleOutcomeForm

  sealed trait CenterCapability extends _root_.scala.Product with _root_.scala.Serializable

  object CenterCapability {

    case object International extends CenterCapability { override def toString = "international" }
    case object Domestic extends CenterCapability { override def toString = "domestic" }
    case object Crossdock extends CenterCapability { override def toString = "crossdock" }
    case object CommercialInvoice extends CenterCapability { override def toString = "commercial_invoice" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends CenterCapability

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[CenterCapability] = scala.List(International, Domestic, Crossdock, CommercialInvoice)

    private[this]
    val byName: Map[String, CenterCapability] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): CenterCapability = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[CenterCapability] = byName.get(value.toLowerCase)

  }

  sealed trait DeliveryOptionCostDetailComponentKey extends _root_.scala.Product with _root_.scala.Serializable

  object DeliveryOptionCostDetailComponentKey {

    case object RatecardBaseCost extends DeliveryOptionCostDetailComponentKey { override def toString = "ratecard_base_cost" }
    case object RatecardDdpFee extends DeliveryOptionCostDetailComponentKey { override def toString = "ratecard_ddp_fee" }
    case object RatecardFuelSurcharge extends DeliveryOptionCostDetailComponentKey { override def toString = "ratecard_fuel_surcharge" }
    case object RatecardOversizedShipmentFee extends DeliveryOptionCostDetailComponentKey { override def toString = "ratecard_oversized_shipment_fee" }
    case object RatecardRuralShipmentFee extends DeliveryOptionCostDetailComponentKey { override def toString = "ratecard_rural_shipment_fee" }
    case object CenterCommercialInvoiceFee extends DeliveryOptionCostDetailComponentKey { override def toString = "center_commercial_invoice_fee" }
    case object CenterInboundCartonFee extends DeliveryOptionCostDetailComponentKey { override def toString = "center_inbound_carton_fee" }
    case object CenterOutboundCartonFee extends DeliveryOptionCostDetailComponentKey { override def toString = "center_outbound_carton_fee" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends DeliveryOptionCostDetailComponentKey

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[DeliveryOptionCostDetailComponentKey] = scala.List(RatecardBaseCost, RatecardDdpFee, RatecardFuelSurcharge, RatecardOversizedShipmentFee, RatecardRuralShipmentFee, CenterCommercialInvoiceFee, CenterInboundCartonFee, CenterOutboundCartonFee)

    private[this]
    val byName: Map[String, DeliveryOptionCostDetailComponentKey] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): DeliveryOptionCostDetailComponentKey = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[DeliveryOptionCostDetailComponentKey] = byName.get(value.toLowerCase)

  }

  sealed trait DeliveryOptionCostDetailSource extends _root_.scala.Product with _root_.scala.Serializable

  object DeliveryOptionCostDetailSource {

    case object Center extends DeliveryOptionCostDetailSource { override def toString = "center" }
    case object Ratecard extends DeliveryOptionCostDetailSource { override def toString = "ratecard" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends DeliveryOptionCostDetailSource

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[DeliveryOptionCostDetailSource] = scala.List(Center, Ratecard)

    private[this]
    val byName: Map[String, DeliveryOptionCostDetailSource] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): DeliveryOptionCostDetailSource = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[DeliveryOptionCostDetailSource] = byName.get(value.toLowerCase)

  }

  sealed trait DeliveryWindowComponentSource extends _root_.scala.Product with _root_.scala.Serializable

  object DeliveryWindowComponentSource {

    case object Flow extends DeliveryWindowComponentSource { override def toString = "flow" }
    case object Organization extends DeliveryWindowComponentSource { override def toString = "organization" }
    case object Carrier extends DeliveryWindowComponentSource { override def toString = "carrier" }
    case object Center extends DeliveryWindowComponentSource { override def toString = "center" }
    /**
     * A delivery estimate may be a combination of multiple sources
     */
    case object Mixed extends DeliveryWindowComponentSource { override def toString = "mixed" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends DeliveryWindowComponentSource

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[DeliveryWindowComponentSource] = scala.List(Flow, Organization, Carrier, Center, Mixed)

    private[this]
    val byName: Map[String, DeliveryWindowComponentSource] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): DeliveryWindowComponentSource = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[DeliveryWindowComponentSource] = byName.get(value.toLowerCase)

  }

  sealed trait DeliveryWindowLocation extends _root_.scala.Product with _root_.scala.Serializable

  object DeliveryWindowLocation {

    case object Center extends DeliveryWindowLocation { override def toString = "center" }
    case object Crossdock extends DeliveryWindowLocation { override def toString = "crossdock" }
    case object Customer extends DeliveryWindowLocation { override def toString = "customer" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends DeliveryWindowLocation

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[DeliveryWindowLocation] = scala.List(Center, Crossdock, Customer)

    private[this]
    val byName: Map[String, DeliveryWindowLocation] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): DeliveryWindowLocation = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[DeliveryWindowLocation] = byName.get(value.toLowerCase)

  }

  sealed trait ItemAvailabilityStatus extends _root_.scala.Product with _root_.scala.Serializable

  object ItemAvailabilityStatus {

    /**
     * Inventory is generally available for purchase
     */
    case object Available extends ItemAvailabilityStatus { override def toString = "available" }
    /**
     * Inventory is low and may soon become unavailable for purchase (# inventory items
     * <= 5). Unless there is a specific use case for low inventory, it can be treated
     * the same as 'available'
     */
    case object Low extends ItemAvailabilityStatus { override def toString = "low" }
    /**
     * There is no inventory available and is not available for purchase. Sample
     * actions that can be taken are hiding the item or marking as `sold out` on the
     * frontend
     */
    case object OutOfStock extends ItemAvailabilityStatus { override def toString = "out_of_stock" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends ItemAvailabilityStatus

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[ItemAvailabilityStatus] = scala.List(Available, Low, OutOfStock)

    private[this]
    val byName: Map[String, ItemAvailabilityStatus] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ItemAvailabilityStatus = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ItemAvailabilityStatus] = byName.get(value.toLowerCase)

  }

  /**
   * Strategy to select origin center on a shipping lane with multiple capable
   * shipping origin centers
   */
  sealed trait LaneStrategy extends _root_.scala.Product with _root_.scala.Serializable

  object LaneStrategy {

    /**
     * Use the oldest center by creation date.
     */
    case object Oldest extends LaneStrategy { override def toString = "oldest" }
    /**
     * Optimize for fastest average time in transit across all tiers from the center on
     * the lane
     */
    case object Fastest extends LaneStrategy { override def toString = "fastest" }
    /**
     * Optimize for lowest average cost across all tiers from the center on the lane
     */
    case object LowestCost extends LaneStrategy { override def toString = "lowest_cost" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends LaneStrategy

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[LaneStrategy] = scala.List(Oldest, Fastest, LowestCost)

    private[this]
    val byName: Map[String, LaneStrategy] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): LaneStrategy = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[LaneStrategy] = byName.get(value.toLowerCase)

  }

  sealed trait PhysicalDeliverySpecialSerivce extends _root_.scala.Product with _root_.scala.Serializable

  object PhysicalDeliverySpecialSerivce {

    case object ColdStorage extends PhysicalDeliverySpecialSerivce { override def toString = "cold_storage" }
    case object Hazardous extends PhysicalDeliverySpecialSerivce { override def toString = "hazardous" }
    case object Perishable extends PhysicalDeliverySpecialSerivce { override def toString = "perishable" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends PhysicalDeliverySpecialSerivce

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[PhysicalDeliverySpecialSerivce] = scala.List(ColdStorage, Hazardous, Perishable)

    private[this]
    val byName: Map[String, PhysicalDeliverySpecialSerivce] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): PhysicalDeliverySpecialSerivce = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[PhysicalDeliverySpecialSerivce] = byName.get(value.toLowerCase)

  }

  sealed trait QuoteErrorCode extends _root_.scala.Product with _root_.scala.Serializable

  object QuoteErrorCode {

    case object GenericError extends QuoteErrorCode { override def toString = "generic_error" }
    /**
     * Item numbers are not available in inventory
     */
    case object ItemsNotAvailable extends QuoteErrorCode { override def toString = "items_not_available" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends QuoteErrorCode

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[QuoteErrorCode] = scala.List(GenericError, ItemsNotAvailable)

    private[this]
    val byName: Map[String, QuoteErrorCode] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): QuoteErrorCode = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[QuoteErrorCode] = byName.get(value.toLowerCase)

  }

  /**
   * Type of shipping integration for a given shipping tier
   */
  sealed trait ShipmentIntegrationType extends _root_.scala.Product with _root_.scala.Serializable

  object ShipmentIntegrationType {

    /**
     * Always generate a label for the chosen delivery option.
     */
    case object Direct extends ShipmentIntegrationType { override def toString = "direct" }
    /**
     * Booking and label generation is not available. Just use Flow to calculate
     * delivery window estimates and shipment prices to display.
     */
    case object Information extends ShipmentIntegrationType { override def toString = "information" }
    /**
     * A generic label will be provided by the client organization when available as
     * pre-advice shipment notification to carrier partner.
     */
    case object Preadvice extends ShipmentIntegrationType { override def toString = "preadvice" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends ShipmentIntegrationType

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[ShipmentIntegrationType] = scala.List(Direct, Information, Preadvice)

    private[this]
    val byName: Map[String, ShipmentIntegrationType] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ShipmentIntegrationType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ShipmentIntegrationType] = byName.get(value.toLowerCase)

  }

  sealed trait ShippingConfigurationType extends _root_.scala.Product with _root_.scala.Serializable

  object ShippingConfigurationType {

    case object Default extends ShippingConfigurationType { override def toString = "default" }
    case object Variant extends ShippingConfigurationType { override def toString = "variant" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends ShippingConfigurationType

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[ShippingConfigurationType] = scala.List(Default, Variant)

    private[this]
    val byName: Map[String, ShippingConfigurationType] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ShippingConfigurationType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ShippingConfigurationType] = byName.get(value.toLowerCase)

  }

  sealed trait Strategy extends _root_.scala.Product with _root_.scala.Serializable

  object Strategy {

    /**
     * Tightest range
     */
    case object Range extends Strategy { override def toString = "range" }
    /**
     * Lowest minimum of the ranges
     */
    case object From extends Strategy { override def toString = "from" }
    /**
     * Lowest maximum of the ranges
     */
    case object To extends Strategy { override def toString = "to" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends Strategy

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[Strategy] = scala.List(Range, From, To)

    private[this]
    val byName: Map[String, Strategy] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): Strategy = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[Strategy] = byName.get(value.toLowerCase)

  }

  sealed trait SurchargeResponsibleParty extends _root_.scala.Product with _root_.scala.Serializable

  object SurchargeResponsibleParty {

    /**
     * The merchant pays for this surcharge
     */
    case object Organization extends SurchargeResponsibleParty { override def toString = "organization" }
    /**
     * The customer pays for this surcharge
     */
    case object Customer extends SurchargeResponsibleParty { override def toString = "customer" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends SurchargeResponsibleParty

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[SurchargeResponsibleParty] = scala.List(Organization, Customer)

    private[this]
    val byName: Map[String, SurchargeResponsibleParty] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): SurchargeResponsibleParty = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[SurchargeResponsibleParty] = byName.get(value.toLowerCase)

  }

  /**
   * Describes fulfillment direction of this logistics tier
   */
  sealed trait TierDirection extends _root_.scala.Product with _root_.scala.Serializable

  object TierDirection {

    case object Outbound extends TierDirection { override def toString = "outbound" }
    case object Return extends TierDirection { override def toString = "return" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends TierDirection

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[TierDirection] = scala.List(Outbound, Return)

    private[this]
    val byName: Map[String, TierDirection] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): TierDirection = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[TierDirection] = byName.get(value.toLowerCase)

  }

  /**
   * Describes the type of label displayed for shipping tiers.
   */
  sealed trait TierEstimateType extends _root_.scala.Product with _root_.scala.Serializable

  object TierEstimateType {

    /**
     * Displays the calculated delivery window estimate next to the shipping tier name.
     */
    case object Calculated extends TierEstimateType { override def toString = "calculated" }
    /**
     * Shows a custom label next to the shipping tier name instead of a delivery window
     * estimate.
     */
    case object Custom extends TierEstimateType { override def toString = "custom" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends TierEstimateType

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[TierEstimateType] = scala.List(Calculated, Custom)

    private[this]
    val byName: Map[String, TierEstimateType] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): TierEstimateType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[TierEstimateType] = byName.get(value.toLowerCase)

  }

  /**
   * Strategy to apply when there are multiple rates available for a tier
   */
  sealed trait TierStrategy extends _root_.scala.Product with _root_.scala.Serializable

  object TierStrategy {

    /**
     * Optimize for fastest first, then cheapest
     */
    case object Fastest extends TierStrategy { override def toString = "fastest" }
    /**
     * Optimize for lowest cost first, then fastest
     */
    case object LowestCost extends TierStrategy { override def toString = "lowest_cost" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends TierStrategy

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[TierStrategy] = scala.List(Fastest, LowestCost)

    private[this]
    val byName: Map[String, TierStrategy] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): TierStrategy = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[TierStrategy] = byName.get(value.toLowerCase)

  }

  sealed trait ZeroAmountIndicator extends _root_.scala.Product with _root_.scala.Serializable

  object ZeroAmountIndicator {

    /**
     * Show the number 0.00 in the label
     */
    case object Zero extends ZeroAmountIndicator { override def toString = "zero" }
    /**
     * Show the word `FREE` in the label
     */
    case object Free extends ZeroAmountIndicator { override def toString = "free" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends ZeroAmountIndicator

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[ZeroAmountIndicator] = scala.List(Zero, Free)

    private[this]
    val byName: Map[String, ZeroAmountIndicator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ZeroAmountIndicator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ZeroAmountIndicator] = byName.get(value.toLowerCase)

  }

}

package io.flow.fulfillment.v0.models {

  package object json {
    import play.api.libs.json.__
    import play.api.libs.json.JsString
    import play.api.libs.json.Writes
    import play.api.libs.functional.syntax._
    import io.flow.common.v0.models.json._
    import io.flow.error.v0.models.json._
    import io.flow.fulfillment.v0.models.json._
    import io.flow.permission.v0.models.json._
    import io.flow.query.builder.v0.models.json._
    import io.flow.reference.v0.models.json._

    private[v0] implicit val jsonReadsUUID = __.read[String].map { str =>
      _root_.java.util.UUID.fromString(str)
    }

    private[v0] implicit val jsonWritesUUID = new Writes[_root_.java.util.UUID] {
      def writes(x: _root_.java.util.UUID) = JsString(x.toString)
    }

    private[v0] implicit val jsonReadsJodaDateTime = __.read[String].map { str =>
      _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseDateTime(str)
    }

    private[v0] implicit val jsonWritesJodaDateTime = new Writes[_root_.org.joda.time.DateTime] {
      def writes(x: _root_.org.joda.time.DateTime) = {
        JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(x))
      }
    }

    private[v0] implicit val jsonReadsJodaLocalDate = __.read[String].map { str =>
      _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseLocalDate(str)
    }

    private[v0] implicit val jsonWritesJodaLocalDate = new Writes[_root_.org.joda.time.LocalDate] {
      def writes(x: _root_.org.joda.time.LocalDate) = {
        JsString(_root_.org.joda.time.format.ISODateTimeFormat.date.print(x))
      }
    }

    implicit val jsonReadsFulfillmentCenterCapability = new play.api.libs.json.Reads[io.flow.fulfillment.v0.models.CenterCapability] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.fulfillment.v0.models.CenterCapability] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.fulfillment.v0.models.CenterCapability(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.fulfillment.v0.models.CenterCapability(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesFulfillmentCenterCapability(obj: io.flow.fulfillment.v0.models.CenterCapability) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectCenterCapability(obj: io.flow.fulfillment.v0.models.CenterCapability) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesFulfillmentCenterCapability: play.api.libs.json.Writes[CenterCapability] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.CenterCapability] {
        def writes(obj: io.flow.fulfillment.v0.models.CenterCapability) = {
          jsonWritesFulfillmentCenterCapability(obj)
        }
      }
    }

    implicit val jsonReadsFulfillmentDeliveryOptionCostDetailComponentKey = new play.api.libs.json.Reads[io.flow.fulfillment.v0.models.DeliveryOptionCostDetailComponentKey] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.fulfillment.v0.models.DeliveryOptionCostDetailComponentKey] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.fulfillment.v0.models.DeliveryOptionCostDetailComponentKey(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.fulfillment.v0.models.DeliveryOptionCostDetailComponentKey(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesFulfillmentDeliveryOptionCostDetailComponentKey(obj: io.flow.fulfillment.v0.models.DeliveryOptionCostDetailComponentKey) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectDeliveryOptionCostDetailComponentKey(obj: io.flow.fulfillment.v0.models.DeliveryOptionCostDetailComponentKey) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesFulfillmentDeliveryOptionCostDetailComponentKey: play.api.libs.json.Writes[DeliveryOptionCostDetailComponentKey] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.DeliveryOptionCostDetailComponentKey] {
        def writes(obj: io.flow.fulfillment.v0.models.DeliveryOptionCostDetailComponentKey) = {
          jsonWritesFulfillmentDeliveryOptionCostDetailComponentKey(obj)
        }
      }
    }

    implicit val jsonReadsFulfillmentDeliveryOptionCostDetailSource = new play.api.libs.json.Reads[io.flow.fulfillment.v0.models.DeliveryOptionCostDetailSource] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.fulfillment.v0.models.DeliveryOptionCostDetailSource] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.fulfillment.v0.models.DeliveryOptionCostDetailSource(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.fulfillment.v0.models.DeliveryOptionCostDetailSource(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesFulfillmentDeliveryOptionCostDetailSource(obj: io.flow.fulfillment.v0.models.DeliveryOptionCostDetailSource) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectDeliveryOptionCostDetailSource(obj: io.flow.fulfillment.v0.models.DeliveryOptionCostDetailSource) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesFulfillmentDeliveryOptionCostDetailSource: play.api.libs.json.Writes[DeliveryOptionCostDetailSource] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.DeliveryOptionCostDetailSource] {
        def writes(obj: io.flow.fulfillment.v0.models.DeliveryOptionCostDetailSource) = {
          jsonWritesFulfillmentDeliveryOptionCostDetailSource(obj)
        }
      }
    }

    implicit val jsonReadsFulfillmentDeliveryWindowComponentSource = new play.api.libs.json.Reads[io.flow.fulfillment.v0.models.DeliveryWindowComponentSource] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.fulfillment.v0.models.DeliveryWindowComponentSource] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.fulfillment.v0.models.DeliveryWindowComponentSource(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.fulfillment.v0.models.DeliveryWindowComponentSource(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesFulfillmentDeliveryWindowComponentSource(obj: io.flow.fulfillment.v0.models.DeliveryWindowComponentSource) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectDeliveryWindowComponentSource(obj: io.flow.fulfillment.v0.models.DeliveryWindowComponentSource) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesFulfillmentDeliveryWindowComponentSource: play.api.libs.json.Writes[DeliveryWindowComponentSource] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.DeliveryWindowComponentSource] {
        def writes(obj: io.flow.fulfillment.v0.models.DeliveryWindowComponentSource) = {
          jsonWritesFulfillmentDeliveryWindowComponentSource(obj)
        }
      }
    }

    implicit val jsonReadsFulfillmentDeliveryWindowLocation = new play.api.libs.json.Reads[io.flow.fulfillment.v0.models.DeliveryWindowLocation] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.fulfillment.v0.models.DeliveryWindowLocation] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.fulfillment.v0.models.DeliveryWindowLocation(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.fulfillment.v0.models.DeliveryWindowLocation(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesFulfillmentDeliveryWindowLocation(obj: io.flow.fulfillment.v0.models.DeliveryWindowLocation) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectDeliveryWindowLocation(obj: io.flow.fulfillment.v0.models.DeliveryWindowLocation) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesFulfillmentDeliveryWindowLocation: play.api.libs.json.Writes[DeliveryWindowLocation] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.DeliveryWindowLocation] {
        def writes(obj: io.flow.fulfillment.v0.models.DeliveryWindowLocation) = {
          jsonWritesFulfillmentDeliveryWindowLocation(obj)
        }
      }
    }

    implicit val jsonReadsFulfillmentItemAvailabilityStatus = new play.api.libs.json.Reads[io.flow.fulfillment.v0.models.ItemAvailabilityStatus] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.fulfillment.v0.models.ItemAvailabilityStatus] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.fulfillment.v0.models.ItemAvailabilityStatus(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.fulfillment.v0.models.ItemAvailabilityStatus(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesFulfillmentItemAvailabilityStatus(obj: io.flow.fulfillment.v0.models.ItemAvailabilityStatus) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectItemAvailabilityStatus(obj: io.flow.fulfillment.v0.models.ItemAvailabilityStatus) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesFulfillmentItemAvailabilityStatus: play.api.libs.json.Writes[ItemAvailabilityStatus] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.ItemAvailabilityStatus] {
        def writes(obj: io.flow.fulfillment.v0.models.ItemAvailabilityStatus) = {
          jsonWritesFulfillmentItemAvailabilityStatus(obj)
        }
      }
    }

    implicit val jsonReadsFulfillmentLaneStrategy = new play.api.libs.json.Reads[io.flow.fulfillment.v0.models.LaneStrategy] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.fulfillment.v0.models.LaneStrategy] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.fulfillment.v0.models.LaneStrategy(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.fulfillment.v0.models.LaneStrategy(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesFulfillmentLaneStrategy(obj: io.flow.fulfillment.v0.models.LaneStrategy) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectLaneStrategy(obj: io.flow.fulfillment.v0.models.LaneStrategy) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesFulfillmentLaneStrategy: play.api.libs.json.Writes[LaneStrategy] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.LaneStrategy] {
        def writes(obj: io.flow.fulfillment.v0.models.LaneStrategy) = {
          jsonWritesFulfillmentLaneStrategy(obj)
        }
      }
    }

    implicit val jsonReadsFulfillmentPhysicalDeliverySpecialSerivce = new play.api.libs.json.Reads[io.flow.fulfillment.v0.models.PhysicalDeliverySpecialSerivce] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.fulfillment.v0.models.PhysicalDeliverySpecialSerivce] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.fulfillment.v0.models.PhysicalDeliverySpecialSerivce(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.fulfillment.v0.models.PhysicalDeliverySpecialSerivce(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesFulfillmentPhysicalDeliverySpecialSerivce(obj: io.flow.fulfillment.v0.models.PhysicalDeliverySpecialSerivce) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectPhysicalDeliverySpecialSerivce(obj: io.flow.fulfillment.v0.models.PhysicalDeliverySpecialSerivce) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesFulfillmentPhysicalDeliverySpecialSerivce: play.api.libs.json.Writes[PhysicalDeliverySpecialSerivce] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.PhysicalDeliverySpecialSerivce] {
        def writes(obj: io.flow.fulfillment.v0.models.PhysicalDeliverySpecialSerivce) = {
          jsonWritesFulfillmentPhysicalDeliverySpecialSerivce(obj)
        }
      }
    }

    implicit val jsonReadsFulfillmentQuoteErrorCode = new play.api.libs.json.Reads[io.flow.fulfillment.v0.models.QuoteErrorCode] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.fulfillment.v0.models.QuoteErrorCode] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.fulfillment.v0.models.QuoteErrorCode(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.fulfillment.v0.models.QuoteErrorCode(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesFulfillmentQuoteErrorCode(obj: io.flow.fulfillment.v0.models.QuoteErrorCode) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectQuoteErrorCode(obj: io.flow.fulfillment.v0.models.QuoteErrorCode) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesFulfillmentQuoteErrorCode: play.api.libs.json.Writes[QuoteErrorCode] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.QuoteErrorCode] {
        def writes(obj: io.flow.fulfillment.v0.models.QuoteErrorCode) = {
          jsonWritesFulfillmentQuoteErrorCode(obj)
        }
      }
    }

    implicit val jsonReadsFulfillmentShipmentIntegrationType = new play.api.libs.json.Reads[io.flow.fulfillment.v0.models.ShipmentIntegrationType] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.fulfillment.v0.models.ShipmentIntegrationType] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.fulfillment.v0.models.ShipmentIntegrationType(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.fulfillment.v0.models.ShipmentIntegrationType(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesFulfillmentShipmentIntegrationType(obj: io.flow.fulfillment.v0.models.ShipmentIntegrationType) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectShipmentIntegrationType(obj: io.flow.fulfillment.v0.models.ShipmentIntegrationType) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesFulfillmentShipmentIntegrationType: play.api.libs.json.Writes[ShipmentIntegrationType] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.ShipmentIntegrationType] {
        def writes(obj: io.flow.fulfillment.v0.models.ShipmentIntegrationType) = {
          jsonWritesFulfillmentShipmentIntegrationType(obj)
        }
      }
    }

    implicit val jsonReadsFulfillmentShippingConfigurationType = new play.api.libs.json.Reads[io.flow.fulfillment.v0.models.ShippingConfigurationType] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.fulfillment.v0.models.ShippingConfigurationType] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.fulfillment.v0.models.ShippingConfigurationType(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.fulfillment.v0.models.ShippingConfigurationType(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesFulfillmentShippingConfigurationType(obj: io.flow.fulfillment.v0.models.ShippingConfigurationType) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectShippingConfigurationType(obj: io.flow.fulfillment.v0.models.ShippingConfigurationType) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesFulfillmentShippingConfigurationType: play.api.libs.json.Writes[ShippingConfigurationType] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.ShippingConfigurationType] {
        def writes(obj: io.flow.fulfillment.v0.models.ShippingConfigurationType) = {
          jsonWritesFulfillmentShippingConfigurationType(obj)
        }
      }
    }

    implicit val jsonReadsFulfillmentStrategy = new play.api.libs.json.Reads[io.flow.fulfillment.v0.models.Strategy] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.fulfillment.v0.models.Strategy] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.fulfillment.v0.models.Strategy(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.fulfillment.v0.models.Strategy(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesFulfillmentStrategy(obj: io.flow.fulfillment.v0.models.Strategy) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectStrategy(obj: io.flow.fulfillment.v0.models.Strategy) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesFulfillmentStrategy: play.api.libs.json.Writes[Strategy] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.Strategy] {
        def writes(obj: io.flow.fulfillment.v0.models.Strategy) = {
          jsonWritesFulfillmentStrategy(obj)
        }
      }
    }

    implicit val jsonReadsFulfillmentSurchargeResponsibleParty = new play.api.libs.json.Reads[io.flow.fulfillment.v0.models.SurchargeResponsibleParty] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.fulfillment.v0.models.SurchargeResponsibleParty] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.fulfillment.v0.models.SurchargeResponsibleParty(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.fulfillment.v0.models.SurchargeResponsibleParty(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesFulfillmentSurchargeResponsibleParty(obj: io.flow.fulfillment.v0.models.SurchargeResponsibleParty) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectSurchargeResponsibleParty(obj: io.flow.fulfillment.v0.models.SurchargeResponsibleParty) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesFulfillmentSurchargeResponsibleParty: play.api.libs.json.Writes[SurchargeResponsibleParty] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.SurchargeResponsibleParty] {
        def writes(obj: io.flow.fulfillment.v0.models.SurchargeResponsibleParty) = {
          jsonWritesFulfillmentSurchargeResponsibleParty(obj)
        }
      }
    }

    implicit val jsonReadsFulfillmentTierDirection = new play.api.libs.json.Reads[io.flow.fulfillment.v0.models.TierDirection] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.fulfillment.v0.models.TierDirection] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.fulfillment.v0.models.TierDirection(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.fulfillment.v0.models.TierDirection(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesFulfillmentTierDirection(obj: io.flow.fulfillment.v0.models.TierDirection) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectTierDirection(obj: io.flow.fulfillment.v0.models.TierDirection) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesFulfillmentTierDirection: play.api.libs.json.Writes[TierDirection] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.TierDirection] {
        def writes(obj: io.flow.fulfillment.v0.models.TierDirection) = {
          jsonWritesFulfillmentTierDirection(obj)
        }
      }
    }

    implicit val jsonReadsFulfillmentTierEstimateType = new play.api.libs.json.Reads[io.flow.fulfillment.v0.models.TierEstimateType] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.fulfillment.v0.models.TierEstimateType] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.fulfillment.v0.models.TierEstimateType(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.fulfillment.v0.models.TierEstimateType(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesFulfillmentTierEstimateType(obj: io.flow.fulfillment.v0.models.TierEstimateType) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectTierEstimateType(obj: io.flow.fulfillment.v0.models.TierEstimateType) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesFulfillmentTierEstimateType: play.api.libs.json.Writes[TierEstimateType] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.TierEstimateType] {
        def writes(obj: io.flow.fulfillment.v0.models.TierEstimateType) = {
          jsonWritesFulfillmentTierEstimateType(obj)
        }
      }
    }

    implicit val jsonReadsFulfillmentTierStrategy = new play.api.libs.json.Reads[io.flow.fulfillment.v0.models.TierStrategy] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.fulfillment.v0.models.TierStrategy] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.fulfillment.v0.models.TierStrategy(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.fulfillment.v0.models.TierStrategy(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesFulfillmentTierStrategy(obj: io.flow.fulfillment.v0.models.TierStrategy) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectTierStrategy(obj: io.flow.fulfillment.v0.models.TierStrategy) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesFulfillmentTierStrategy: play.api.libs.json.Writes[TierStrategy] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.TierStrategy] {
        def writes(obj: io.flow.fulfillment.v0.models.TierStrategy) = {
          jsonWritesFulfillmentTierStrategy(obj)
        }
      }
    }

    implicit val jsonReadsFulfillmentZeroAmountIndicator = new play.api.libs.json.Reads[io.flow.fulfillment.v0.models.ZeroAmountIndicator] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.fulfillment.v0.models.ZeroAmountIndicator] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.fulfillment.v0.models.ZeroAmountIndicator(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.fulfillment.v0.models.ZeroAmountIndicator(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesFulfillmentZeroAmountIndicator(obj: io.flow.fulfillment.v0.models.ZeroAmountIndicator) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectZeroAmountIndicator(obj: io.flow.fulfillment.v0.models.ZeroAmountIndicator) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesFulfillmentZeroAmountIndicator: play.api.libs.json.Writes[ZeroAmountIndicator] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.ZeroAmountIndicator] {
        def writes(obj: io.flow.fulfillment.v0.models.ZeroAmountIndicator) = {
          jsonWritesFulfillmentZeroAmountIndicator(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentAmountMargin: play.api.libs.json.Reads[AmountMargin] = {
      (__ \ "margin").read[io.flow.common.v0.models.Price].map { x => new AmountMargin(margin = x) }
    }

    def jsObjectAmountMargin(obj: io.flow.fulfillment.v0.models.AmountMargin): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "margin" -> io.flow.common.v0.models.json.jsObjectPrice(obj.margin)
      )
    }

    implicit def jsonReadsFulfillmentAmountMarginForm: play.api.libs.json.Reads[AmountMarginForm] = {
      (__ \ "margin").read[io.flow.common.v0.models.Money].map { x => new AmountMarginForm(margin = x) }
    }

    def jsObjectAmountMarginForm(obj: io.flow.fulfillment.v0.models.AmountMarginForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "margin" -> io.flow.common.v0.models.json.jsObjectMoney(obj.margin)
      )
    }

    implicit def jsonReadsFulfillmentAtCost: play.api.libs.json.Reads[AtCost] = {
      (__ \ "ignore").readNullable[String].map { x => new AtCost(ignore = x) }
    }

    def jsObjectAtCost(obj: io.flow.fulfillment.v0.models.AtCost): play.api.libs.json.JsObject = {
      (obj.ignore match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("ignore" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonReadsFulfillmentAvailableService: play.api.libs.json.Reads[AvailableService] = {
      for {
        service <- (__ \ "service").read[String]
        scheduledPickups <- (__ \ "scheduled_pickups").readNullable[Seq[io.flow.fulfillment.v0.models.ScheduledPickup]]
        leadDays <- (__ \ "lead_days").readNullable[io.flow.fulfillment.v0.models.NumberRange]
      } yield AvailableService(service, scheduledPickups, leadDays)
    }

    def jsObjectAvailableService(obj: io.flow.fulfillment.v0.models.AvailableService): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "service" -> play.api.libs.json.JsString(obj.service)
      ) ++ (obj.scheduledPickups match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("scheduled_pickups" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.leadDays match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("lead_days" -> jsObjectNumberRange(x))
      })
    }

    implicit def jsonWritesFulfillmentAvailableService: play.api.libs.json.Writes[AvailableService] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.AvailableService] {
        def writes(obj: io.flow.fulfillment.v0.models.AvailableService) = {
          jsObjectAvailableService(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentCarrierReference: play.api.libs.json.Reads[CarrierReference] = {
      (__ \ "id").read[String].map { x => new CarrierReference(id = x) }
    }

    def jsObjectCarrierReference(obj: io.flow.fulfillment.v0.models.CarrierReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id)
      )
    }

    implicit def jsonWritesFulfillmentCarrierReference: play.api.libs.json.Writes[CarrierReference] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.CarrierReference] {
        def writes(obj: io.flow.fulfillment.v0.models.CarrierReference) = {
          jsObjectCarrierReference(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentCenter: play.api.libs.json.Reads[Center] = {
      for {
        id <- (__ \ "id").read[String]
        key <- (__ \ "key").read[String]
        address <- (__ \ "address").read[io.flow.fulfillment.v0.models.ShippingAddress]
        packaging <- (__ \ "packaging").read[Seq[io.flow.fulfillment.v0.models.Packaging]]
        name <- (__ \ "name").read[String]
        services <- (__ \ "services").read[Seq[io.flow.fulfillment.v0.models.AvailableService]]
        schedule <- (__ \ "schedule").read[io.flow.common.v0.models.Schedule]
        timezone <- (__ \ "timezone").read[String]
        capabilities <- (__ \ "capabilities").readNullable[Seq[io.flow.fulfillment.v0.models.CenterCapability]]
        partnerCenter <- (__ \ "partner_center").readNullable[io.flow.fulfillment.v0.models.PartnerCenter]
      } yield Center(id, key, address, packaging, name, services, schedule, timezone, capabilities, partnerCenter)
    }

    def jsObjectCenter(obj: io.flow.fulfillment.v0.models.Center): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "key" -> play.api.libs.json.JsString(obj.key),
        "address" -> jsObjectShippingAddress(obj.address),
        "packaging" -> play.api.libs.json.Json.toJson(obj.packaging),
        "name" -> play.api.libs.json.JsString(obj.name),
        "services" -> play.api.libs.json.Json.toJson(obj.services),
        "schedule" -> io.flow.common.v0.models.json.jsObjectSchedule(obj.schedule),
        "timezone" -> play.api.libs.json.JsString(obj.timezone)
      ) ++ (obj.capabilities match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("capabilities" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.partnerCenter match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("partner_center" -> jsObjectPartnerCenter(x))
      })
    }

    implicit def jsonReadsFulfillmentCenterForm: play.api.libs.json.Reads[CenterForm] = {
      for {
        address <- (__ \ "address").read[io.flow.fulfillment.v0.models.ShippingAddress]
        packaging <- (__ \ "packaging").read[Seq[io.flow.fulfillment.v0.models.Packaging]]
        name <- (__ \ "name").read[String]
        services <- (__ \ "services").read[Seq[io.flow.fulfillment.v0.models.AvailableService]]
        schedule <- (__ \ "schedule").read[io.flow.common.v0.models.Schedule]
        timezone <- (__ \ "timezone").readNullable[String]
        key <- (__ \ "key").readNullable[String]
        capabilities <- (__ \ "capabilities").readNullable[Seq[io.flow.fulfillment.v0.models.CenterCapability]]
        partnerCenterForm <- (__ \ "partner_center_form").readNullable[io.flow.fulfillment.v0.models.PartnerCenterForm]
      } yield CenterForm(address, packaging, name, services, schedule, timezone, key, capabilities, partnerCenterForm)
    }

    def jsObjectCenterForm(obj: io.flow.fulfillment.v0.models.CenterForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "address" -> jsObjectShippingAddress(obj.address),
        "packaging" -> play.api.libs.json.Json.toJson(obj.packaging),
        "name" -> play.api.libs.json.JsString(obj.name),
        "services" -> play.api.libs.json.Json.toJson(obj.services),
        "schedule" -> io.flow.common.v0.models.json.jsObjectSchedule(obj.schedule)
      ) ++ (obj.timezone match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("timezone" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.key match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("key" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.capabilities match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("capabilities" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.partnerCenterForm match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("partner_center_form" -> jsObjectPartnerCenterForm(x))
      })
    }

    implicit def jsonWritesFulfillmentCenterForm: play.api.libs.json.Writes[CenterForm] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.CenterForm] {
        def writes(obj: io.flow.fulfillment.v0.models.CenterForm) = {
          jsObjectCenterForm(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentCenterQuery: play.api.libs.json.Reads[CenterQuery] = {
      (__ \ "q").read[String].map { x => new CenterQuery(q = x) }
    }

    def jsObjectCenterQuery(obj: io.flow.fulfillment.v0.models.CenterQuery): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "q" -> play.api.libs.json.JsString(obj.q)
      )
    }

    implicit def jsonWritesFulfillmentCenterQuery: play.api.libs.json.Writes[CenterQuery] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.CenterQuery] {
        def writes(obj: io.flow.fulfillment.v0.models.CenterQuery) = {
          jsObjectCenterQuery(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentCenterReference: play.api.libs.json.Reads[CenterReference] = {
      for {
        organizationId <- (__ \ "organization_id").read[String]
        centerKey <- (__ \ "center_key").read[String]
      } yield CenterReference(organizationId, centerKey)
    }

    def jsObjectCenterReference(obj: io.flow.fulfillment.v0.models.CenterReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "organization_id" -> play.api.libs.json.JsString(obj.organizationId),
        "center_key" -> play.api.libs.json.JsString(obj.centerKey)
      )
    }

    implicit def jsonReadsFulfillmentCenterSummary: play.api.libs.json.Reads[CenterSummary] = {
      for {
        id <- (__ \ "id").read[String]
        key <- (__ \ "key").read[String]
      } yield CenterSummary(id, key)
    }

    def jsObjectCenterSummary(obj: io.flow.fulfillment.v0.models.CenterSummary): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "key" -> play.api.libs.json.JsString(obj.key)
      )
    }

    implicit def jsonWritesFulfillmentCenterSummary: play.api.libs.json.Writes[CenterSummary] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.CenterSummary] {
        def writes(obj: io.flow.fulfillment.v0.models.CenterSummary) = {
          jsObjectCenterSummary(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentCenterVersion: play.api.libs.json.Reads[CenterVersion] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        center <- (__ \ "center").read[io.flow.fulfillment.v0.models.Center]
      } yield CenterVersion(id, timestamp, `type`, center)
    }

    def jsObjectCenterVersion(obj: io.flow.fulfillment.v0.models.CenterVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "center" -> jsObjectCenter(obj.center)
      )
    }

    implicit def jsonWritesFulfillmentCenterVersion: play.api.libs.json.Writes[CenterVersion] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.CenterVersion] {
        def writes(obj: io.flow.fulfillment.v0.models.CenterVersion) = {
          jsObjectCenterVersion(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentCommercialInvoiceFee: play.api.libs.json.Reads[CommercialInvoiceFee] = {
      (__ \ "amount").read[io.flow.common.v0.models.Money].map { x => new CommercialInvoiceFee(amount = x) }
    }

    def jsObjectCommercialInvoiceFee(obj: io.flow.fulfillment.v0.models.CommercialInvoiceFee): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "amount" -> io.flow.common.v0.models.json.jsObjectMoney(obj.amount)
      )
    }

    implicit def jsonReadsFulfillmentCountryAvailability: play.api.libs.json.Reads[CountryAvailability] = {
      for {
        status <- (__ \ "status").read[io.flow.fulfillment.v0.models.ItemAvailabilityStatus]
        countries <- (__ \ "countries").read[Seq[String]]
      } yield CountryAvailability(status, countries)
    }

    def jsObjectCountryAvailability(obj: io.flow.fulfillment.v0.models.CountryAvailability): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "status" -> play.api.libs.json.JsString(obj.status.toString),
        "countries" -> play.api.libs.json.Json.toJson(obj.countries)
      )
    }

    implicit def jsonWritesFulfillmentCountryAvailability: play.api.libs.json.Writes[CountryAvailability] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.CountryAvailability] {
        def writes(obj: io.flow.fulfillment.v0.models.CountryAvailability) = {
          jsObjectCountryAvailability(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentCountryShippingPricing: play.api.libs.json.Reads[CountryShippingPricing] = {
      for {
        pricing <- (__ \ "pricing").read[io.flow.fulfillment.v0.models.ItemShippingPricing]
        countries <- (__ \ "countries").read[Seq[String]]
      } yield CountryShippingPricing(pricing, countries)
    }

    def jsObjectCountryShippingPricing(obj: io.flow.fulfillment.v0.models.CountryShippingPricing): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "pricing" -> jsObjectItemShippingPricing(obj.pricing),
        "countries" -> play.api.libs.json.Json.toJson(obj.countries)
      )
    }

    implicit def jsonWritesFulfillmentCountryShippingPricing: play.api.libs.json.Writes[CountryShippingPricing] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.CountryShippingPricing] {
        def writes(obj: io.flow.fulfillment.v0.models.CountryShippingPricing) = {
          jsObjectCountryShippingPricing(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentDeliveryItem: play.api.libs.json.Reads[DeliveryItem] = {
      for {
        number <- (__ \ "number").read[String]
        quantity <- (__ \ "quantity").read[Long]
        shipmentEstimate <- (__ \ "shipment_estimate").readNullable[io.flow.common.v0.models.DatetimeRange]
        price <- (__ \ "price").readNullable[io.flow.common.v0.models.MoneyWithOptionalBase]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
        center <- (__ \ "center").readNullable[String]
        discount <- (__ \ "discount").readNullable[io.flow.common.v0.models.MoneyWithOptionalBase]
      } yield DeliveryItem(number, quantity, shipmentEstimate, price, attributes, center, discount)
    }

    def jsObjectDeliveryItem(obj: io.flow.fulfillment.v0.models.DeliveryItem): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "number" -> play.api.libs.json.JsString(obj.number),
        "quantity" -> play.api.libs.json.JsNumber(obj.quantity)
      ) ++ (obj.shipmentEstimate match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("shipment_estimate" -> io.flow.common.v0.models.json.jsObjectDatetimeRange(x))
      }) ++
      (obj.price match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("price" -> io.flow.common.v0.models.json.jsObjectMoneyWithOptionalBase(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.center match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("center" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.discount match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("discount" -> io.flow.common.v0.models.json.jsObjectMoneyWithOptionalBase(x))
      })
    }

    implicit def jsonWritesFulfillmentDeliveryItem: play.api.libs.json.Writes[DeliveryItem] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.DeliveryItem] {
        def writes(obj: io.flow.fulfillment.v0.models.DeliveryItem) = {
          jsObjectDeliveryItem(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentDeliveryOption: play.api.libs.json.Reads[DeliveryOption] = {
      for {
        id <- (__ \ "id").read[String]
        cost <- (__ \ "cost").read[io.flow.fulfillment.v0.models.PriceWithBaseAndDetails]
        deliveredDuty <- (__ \ "delivered_duty").read[io.flow.common.v0.models.DeliveredDuty]
        price <- (__ \ "price").read[io.flow.fulfillment.v0.models.PriceWithBaseAndDetails]
        service <- (__ \ "service").read[io.flow.fulfillment.v0.models.ServiceSummary]
        tier <- (__ \ "tier").read[io.flow.fulfillment.v0.models.TierSummary]
        window <- (__ \ "window").read[io.flow.fulfillment.v0.models.DeliveryWindow]
        ruleOutcome <- (__ \ "rule_outcome").readNullable[io.flow.fulfillment.v0.models.TierRuleOutcome]
        weight <- (__ \ "weight").readNullable[io.flow.fulfillment.v0.models.OptionWeightEstimates]
        sendTo <- (__ \ "send_to").readNullable[io.flow.fulfillment.v0.models.ShippingAddress]
        surcharge <- (__ \ "surcharge").readNullable[io.flow.fulfillment.v0.models.PriceWithBaseAndDetails]
      } yield DeliveryOption(id, cost, deliveredDuty, price, service, tier, window, ruleOutcome, weight, sendTo, surcharge)
    }

    def jsObjectDeliveryOption(obj: io.flow.fulfillment.v0.models.DeliveryOption): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "cost" -> jsObjectPriceWithBaseAndDetails(obj.cost),
        "delivered_duty" -> play.api.libs.json.JsString(obj.deliveredDuty.toString),
        "price" -> jsObjectPriceWithBaseAndDetails(obj.price),
        "service" -> jsObjectServiceSummary(obj.service),
        "tier" -> jsObjectTierSummary(obj.tier),
        "window" -> jsObjectDeliveryWindow(obj.window)
      ) ++ (obj.ruleOutcome match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("rule_outcome" -> jsObjectTierRuleOutcome(x))
      }) ++
      (obj.weight match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("weight" -> jsObjectOptionWeightEstimates(x))
      }) ++
      (obj.sendTo match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("send_to" -> jsObjectShippingAddress(x))
      }) ++
      (obj.surcharge match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("surcharge" -> jsObjectPriceWithBaseAndDetails(x))
      })
    }

    implicit def jsonWritesFulfillmentDeliveryOption: play.api.libs.json.Writes[DeliveryOption] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.DeliveryOption] {
        def writes(obj: io.flow.fulfillment.v0.models.DeliveryOption) = {
          jsObjectDeliveryOption(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentDeliveryOptionCostComponent: play.api.libs.json.Reads[DeliveryOptionCostComponent] = {
      for {
        key <- (__ \ "key").read[io.flow.fulfillment.v0.models.DeliveryOptionCostDetailComponentKey]
        currency <- (__ \ "currency").read[String]
        amount <- (__ \ "amount").read[BigDecimal]
        label <- (__ \ "label").read[String]
        base <- (__ \ "base").readNullable[io.flow.common.v0.models.Price]
      } yield DeliveryOptionCostComponent(key, currency, amount, label, base)
    }

    def jsObjectDeliveryOptionCostComponent(obj: io.flow.fulfillment.v0.models.DeliveryOptionCostComponent): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key.toString),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "label" -> play.api.libs.json.JsString(obj.label)
      ) ++ (obj.base match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("base" -> io.flow.common.v0.models.json.jsObjectPrice(x))
      })
    }

    implicit def jsonWritesFulfillmentDeliveryOptionCostComponent: play.api.libs.json.Writes[DeliveryOptionCostComponent] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.DeliveryOptionCostComponent] {
        def writes(obj: io.flow.fulfillment.v0.models.DeliveryOptionCostComponent) = {
          jsObjectDeliveryOptionCostComponent(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentDeliveryOptionCostDetail: play.api.libs.json.Reads[DeliveryOptionCostDetail] = {
      for {
        source <- (__ \ "source").read[io.flow.fulfillment.v0.models.DeliveryOptionCostDetailSource]
        currency <- (__ \ "currency").read[String]
        amount <- (__ \ "amount").read[BigDecimal]
        label <- (__ \ "label").read[String]
        base <- (__ \ "base").readNullable[io.flow.common.v0.models.Price]
        components <- (__ \ "components").read[Seq[io.flow.fulfillment.v0.models.DeliveryOptionCostComponent]]
      } yield DeliveryOptionCostDetail(source, currency, amount, label, base, components)
    }

    def jsObjectDeliveryOptionCostDetail(obj: io.flow.fulfillment.v0.models.DeliveryOptionCostDetail): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "source" -> play.api.libs.json.JsString(obj.source.toString),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "label" -> play.api.libs.json.JsString(obj.label),
        "components" -> play.api.libs.json.Json.toJson(obj.components)
      ) ++ (obj.base match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("base" -> io.flow.common.v0.models.json.jsObjectPrice(x))
      })
    }

    implicit def jsonWritesFulfillmentDeliveryOptionCostDetail: play.api.libs.json.Writes[DeliveryOptionCostDetail] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.DeliveryOptionCostDetail] {
        def writes(obj: io.flow.fulfillment.v0.models.DeliveryOptionCostDetail) = {
          jsObjectDeliveryOptionCostDetail(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentDeliveryOptionForm: play.api.libs.json.Reads[DeliveryOptionForm] = {
      for {
        delivery <- (__ \ "delivery").read[String]
        items <- (__ \ "items").read[Seq[io.flow.fulfillment.v0.models.QuoteLineItemForm]]
        destination <- (__ \ "destination").read[io.flow.fulfillment.v0.models.ShippingAddress]
      } yield DeliveryOptionForm(delivery, items, destination)
    }

    def jsObjectDeliveryOptionForm(obj: io.flow.fulfillment.v0.models.DeliveryOptionForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "delivery" -> play.api.libs.json.JsString(obj.delivery),
        "items" -> play.api.libs.json.Json.toJson(obj.items),
        "destination" -> jsObjectShippingAddress(obj.destination)
      )
    }

    implicit def jsonWritesFulfillmentDeliveryOptionForm: play.api.libs.json.Writes[DeliveryOptionForm] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.DeliveryOptionForm] {
        def writes(obj: io.flow.fulfillment.v0.models.DeliveryOptionForm) = {
          jsObjectDeliveryOptionForm(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentDeliveryOptionReference: play.api.libs.json.Reads[DeliveryOptionReference] = {
      (__ \ "id").read[String].map { x => new DeliveryOptionReference(id = x) }
    }

    def jsObjectDeliveryOptionReference(obj: io.flow.fulfillment.v0.models.DeliveryOptionReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id)
      )
    }

    implicit def jsonWritesFulfillmentDeliveryOptionReference: play.api.libs.json.Writes[DeliveryOptionReference] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.DeliveryOptionReference] {
        def writes(obj: io.flow.fulfillment.v0.models.DeliveryOptionReference) = {
          jsObjectDeliveryOptionReference(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentDeliveryOptionSummary: play.api.libs.json.Reads[DeliveryOptionSummary] = {
      for {
        id <- (__ \ "id").read[String]
        cost <- (__ \ "cost").read[io.flow.common.v0.models.Price]
        deliveredDuty <- (__ \ "delivered_duty").read[io.flow.common.v0.models.DeliveredDuty]
        price <- (__ \ "price").read[io.flow.common.v0.models.Price]
        service <- (__ \ "service").read[io.flow.fulfillment.v0.models.ServiceReference]
        tier <- (__ \ "tier").read[io.flow.fulfillment.v0.models.TierReference]
        window <- (__ \ "window").read[io.flow.common.v0.models.DatetimeRange]
      } yield DeliveryOptionSummary(id, cost, deliveredDuty, price, service, tier, window)
    }

    def jsObjectDeliveryOptionSummary(obj: io.flow.fulfillment.v0.models.DeliveryOptionSummary): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "cost" -> io.flow.common.v0.models.json.jsObjectPrice(obj.cost),
        "delivered_duty" -> play.api.libs.json.JsString(obj.deliveredDuty.toString),
        "price" -> io.flow.common.v0.models.json.jsObjectPrice(obj.price),
        "service" -> jsObjectServiceReference(obj.service),
        "tier" -> jsObjectTierReference(obj.tier),
        "window" -> io.flow.common.v0.models.json.jsObjectDatetimeRange(obj.window)
      )
    }

    implicit def jsonWritesFulfillmentDeliveryOptionSummary: play.api.libs.json.Writes[DeliveryOptionSummary] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.DeliveryOptionSummary] {
        def writes(obj: io.flow.fulfillment.v0.models.DeliveryOptionSummary) = {
          jsObjectDeliveryOptionSummary(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentDeliveryOptionVersion: play.api.libs.json.Reads[DeliveryOptionVersion] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        deliveryOption <- (__ \ "delivery_option").read[io.flow.fulfillment.v0.models.DeliveryOptionSummary]
      } yield DeliveryOptionVersion(id, timestamp, `type`, deliveryOption)
    }

    def jsObjectDeliveryOptionVersion(obj: io.flow.fulfillment.v0.models.DeliveryOptionVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "delivery_option" -> jsObjectDeliveryOptionSummary(obj.deliveryOption)
      )
    }

    implicit def jsonWritesFulfillmentDeliveryOptionVersion: play.api.libs.json.Writes[DeliveryOptionVersion] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.DeliveryOptionVersion] {
        def writes(obj: io.flow.fulfillment.v0.models.DeliveryOptionVersion) = {
          jsObjectDeliveryOptionVersion(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentDeliverySummary: play.api.libs.json.Reads[DeliverySummary] = {
      for {
        id <- (__ \ "id").read[String]
        items <- (__ \ "items").read[Seq[io.flow.common.v0.models.LineItemForm]]
      } yield DeliverySummary(id, items)
    }

    def jsObjectDeliverySummary(obj: io.flow.fulfillment.v0.models.DeliverySummary): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "items" -> play.api.libs.json.Json.toJson(obj.items)
      )
    }

    implicit def jsonWritesFulfillmentDeliverySummary: play.api.libs.json.Writes[DeliverySummary] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.DeliverySummary] {
        def writes(obj: io.flow.fulfillment.v0.models.DeliverySummary) = {
          jsObjectDeliverySummary(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentDeliveryVersion: play.api.libs.json.Reads[DeliveryVersion] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        delivery <- (__ \ "delivery").read[io.flow.fulfillment.v0.models.DeliverySummary]
      } yield DeliveryVersion(id, timestamp, `type`, delivery)
    }

    def jsObjectDeliveryVersion(obj: io.flow.fulfillment.v0.models.DeliveryVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "delivery" -> jsObjectDeliverySummary(obj.delivery)
      )
    }

    implicit def jsonWritesFulfillmentDeliveryVersion: play.api.libs.json.Writes[DeliveryVersion] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.DeliveryVersion] {
        def writes(obj: io.flow.fulfillment.v0.models.DeliveryVersion) = {
          jsObjectDeliveryVersion(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentDeliveryWindow: play.api.libs.json.Reads[DeliveryWindow] = {
      for {
        from <- (__ \ "from").read[_root_.org.joda.time.DateTime]
        to <- (__ \ "to").read[_root_.org.joda.time.DateTime]
        timezone <- (__ \ "timezone").readNullable[String]
        label <- (__ \ "label").readNullable[String]
      } yield DeliveryWindow(from, to, timezone, label)
    }

    def jsObjectDeliveryWindow(obj: io.flow.fulfillment.v0.models.DeliveryWindow): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "from" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.from)),
        "to" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.to))
      ) ++ (obj.timezone match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("timezone" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.label match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("label" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesFulfillmentDeliveryWindow: play.api.libs.json.Writes[DeliveryWindow] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.DeliveryWindow] {
        def writes(obj: io.flow.fulfillment.v0.models.DeliveryWindow) = {
          jsObjectDeliveryWindow(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentDeliveryWindowComponent: play.api.libs.json.Reads[DeliveryWindowComponent] = {
      for {
        from <- (__ \ "from").read[_root_.org.joda.time.DateTime]
        to <- (__ \ "to").read[_root_.org.joda.time.DateTime]
        source <- (__ \ "source").read[io.flow.fulfillment.v0.models.DeliveryWindowComponentSource]
      } yield DeliveryWindowComponent(from, to, source)
    }

    def jsObjectDeliveryWindowComponent(obj: io.flow.fulfillment.v0.models.DeliveryWindowComponent): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "from" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.from)),
        "to" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.to)),
        "source" -> play.api.libs.json.JsString(obj.source.toString)
      )
    }

    implicit def jsonWritesFulfillmentDeliveryWindowComponent: play.api.libs.json.Writes[DeliveryWindowComponent] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.DeliveryWindowComponent] {
        def writes(obj: io.flow.fulfillment.v0.models.DeliveryWindowComponent) = {
          jsObjectDeliveryWindowComponent(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentDeliveryWindowComponents: play.api.libs.json.Reads[DeliveryWindowComponents] = {
      for {
        shipmentEstimate <- (__ \ "shipment_estimate").read[io.flow.fulfillment.v0.models.DeliveryWindowComponent]
        transitEstimate <- (__ \ "transit_estimate").read[io.flow.fulfillment.v0.models.DeliveryWindowComponent]
      } yield DeliveryWindowComponents(shipmentEstimate, transitEstimate)
    }

    def jsObjectDeliveryWindowComponents(obj: io.flow.fulfillment.v0.models.DeliveryWindowComponents): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "shipment_estimate" -> jsObjectDeliveryWindowComponent(obj.shipmentEstimate),
        "transit_estimate" -> jsObjectDeliveryWindowComponent(obj.transitEstimate)
      )
    }

    implicit def jsonWritesFulfillmentDeliveryWindowComponents: play.api.libs.json.Writes[DeliveryWindowComponents] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.DeliveryWindowComponents] {
        def writes(obj: io.flow.fulfillment.v0.models.DeliveryWindowComponents) = {
          jsObjectDeliveryWindowComponents(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentDeliveryWindowComponentsV2: play.api.libs.json.Reads[DeliveryWindowComponentsV2] = {
      for {
        processingEstimates <- (__ \ "processing_estimates").read[Seq[io.flow.fulfillment.v0.models.ProcessingEstimate]]
        transitEstimates <- (__ \ "transit_estimates").read[Seq[io.flow.fulfillment.v0.models.TransitEstimate]]
      } yield DeliveryWindowComponentsV2(processingEstimates, transitEstimates)
    }

    def jsObjectDeliveryWindowComponentsV2(obj: io.flow.fulfillment.v0.models.DeliveryWindowComponentsV2): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "processing_estimates" -> play.api.libs.json.Json.toJson(obj.processingEstimates),
        "transit_estimates" -> play.api.libs.json.Json.toJson(obj.transitEstimates)
      )
    }

    implicit def jsonWritesFulfillmentDeliveryWindowComponentsV2: play.api.libs.json.Writes[DeliveryWindowComponentsV2] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.DeliveryWindowComponentsV2] {
        def writes(obj: io.flow.fulfillment.v0.models.DeliveryWindowComponentsV2) = {
          jsObjectDeliveryWindowComponentsV2(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentDigitalDelivery: play.api.libs.json.Reads[DigitalDelivery] = {
      for {
        id <- (__ \ "id").read[String]
        items <- (__ \ "items").read[Seq[io.flow.fulfillment.v0.models.DeliveryItem]]
      } yield DigitalDelivery(id, items)
    }

    def jsObjectDigitalDelivery(obj: io.flow.fulfillment.v0.models.DigitalDelivery): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "items" -> play.api.libs.json.Json.toJson(obj.items)
      )
    }

    implicit def jsonReadsFulfillmentEstimatedWindow: play.api.libs.json.Reads[EstimatedWindow] = {
      for {
        from <- (__ \ "from").read[Long]
        to <- (__ \ "to").read[Long]
        unit <- (__ \ "unit").read[io.flow.common.v0.models.UnitOfTime]
      } yield EstimatedWindow(from, to, unit)
    }

    def jsObjectEstimatedWindow(obj: io.flow.fulfillment.v0.models.EstimatedWindow): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "from" -> play.api.libs.json.JsNumber(obj.from),
        "to" -> play.api.libs.json.JsNumber(obj.to),
        "unit" -> play.api.libs.json.JsString(obj.unit.toString)
      )
    }

    implicit def jsonWritesFulfillmentEstimatedWindow: play.api.libs.json.Writes[EstimatedWindow] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.EstimatedWindow] {
        def writes(obj: io.flow.fulfillment.v0.models.EstimatedWindow) = {
          jsObjectEstimatedWindow(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentFlatRate: play.api.libs.json.Reads[FlatRate] = {
      for {
        price <- (__ \ "price").read[io.flow.common.v0.models.Price]
        zeroAmountIndicator <- (__ \ "zero_amount_indicator").readNullable[io.flow.fulfillment.v0.models.ZeroAmountIndicator]
      } yield FlatRate(price, zeroAmountIndicator)
    }

    def jsObjectFlatRate(obj: io.flow.fulfillment.v0.models.FlatRate): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "price" -> io.flow.common.v0.models.json.jsObjectPrice(obj.price)
      ) ++ (obj.zeroAmountIndicator match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("zero_amount_indicator" -> play.api.libs.json.JsString(x.toString))
      })
    }

    implicit def jsonReadsFulfillmentFlatRateForm: play.api.libs.json.Reads[FlatRateForm] = {
      for {
        price <- (__ \ "price").read[io.flow.common.v0.models.Money]
        zeroAmountIndicator <- (__ \ "zero_amount_indicator").readNullable[io.flow.fulfillment.v0.models.ZeroAmountIndicator]
      } yield FlatRateForm(price, zeroAmountIndicator)
    }

    def jsObjectFlatRateForm(obj: io.flow.fulfillment.v0.models.FlatRateForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "price" -> io.flow.common.v0.models.json.jsObjectMoney(obj.price)
      ) ++ (obj.zeroAmountIndicator match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("zero_amount_indicator" -> play.api.libs.json.JsString(x.toString))
      })
    }

    implicit def jsonReadsFulfillmentFulfillmentExperienceReference: play.api.libs.json.Reads[FulfillmentExperienceReference] = {
      for {
        id <- (__ \ "id").read[String]
        currency <- (__ \ "currency").read[String]
      } yield FulfillmentExperienceReference(id, currency)
    }

    def jsObjectFulfillmentExperienceReference(obj: io.flow.fulfillment.v0.models.FulfillmentExperienceReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "currency" -> play.api.libs.json.JsString(obj.currency)
      )
    }

    implicit def jsonWritesFulfillmentFulfillmentExperienceReference: play.api.libs.json.Writes[FulfillmentExperienceReference] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.FulfillmentExperienceReference] {
        def writes(obj: io.flow.fulfillment.v0.models.FulfillmentExperienceReference) = {
          jsObjectFulfillmentExperienceReference(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentInboundCartonFee: play.api.libs.json.Reads[InboundCartonFee] = {
      (__ \ "amount").read[io.flow.common.v0.models.Money].map { x => new InboundCartonFee(amount = x) }
    }

    def jsObjectInboundCartonFee(obj: io.flow.fulfillment.v0.models.InboundCartonFee): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "amount" -> io.flow.common.v0.models.json.jsObjectMoney(obj.amount)
      )
    }

    implicit def jsonReadsFulfillmentItemShippingPricing: play.api.libs.json.Reads[ItemShippingPricing] = {
      for {
        min <- (__ \ "min").read[io.flow.common.v0.models.Price]
        max <- (__ \ "max").readNullable[io.flow.common.v0.models.Price]
      } yield ItemShippingPricing(min, max)
    }

    def jsObjectItemShippingPricing(obj: io.flow.fulfillment.v0.models.ItemShippingPricing): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "min" -> io.flow.common.v0.models.json.jsObjectPrice(obj.min)
      ) ++ (obj.max match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("max" -> io.flow.common.v0.models.json.jsObjectPrice(x))
      })
    }

    implicit def jsonWritesFulfillmentItemShippingPricing: play.api.libs.json.Writes[ItemShippingPricing] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.ItemShippingPricing] {
        def writes(obj: io.flow.fulfillment.v0.models.ItemShippingPricing) = {
          jsObjectItemShippingPricing(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentNumberRange: play.api.libs.json.Reads[NumberRange] = {
      for {
        min <- (__ \ "min").read[Long]
        max <- (__ \ "max").read[Long]
      } yield NumberRange(min, max)
    }

    def jsObjectNumberRange(obj: io.flow.fulfillment.v0.models.NumberRange): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "min" -> play.api.libs.json.JsNumber(obj.min),
        "max" -> play.api.libs.json.JsNumber(obj.max)
      )
    }

    implicit def jsonWritesFulfillmentNumberRange: play.api.libs.json.Writes[NumberRange] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.NumberRange] {
        def writes(obj: io.flow.fulfillment.v0.models.NumberRange) = {
          jsObjectNumberRange(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentOptionWeightEstimates: play.api.libs.json.Reads[OptionWeightEstimates] = {
      for {
        gravitational <- (__ \ "gravitational").read[io.flow.common.v0.models.Measurement]
        dimensional <- (__ \ "dimensional").read[io.flow.common.v0.models.Measurement]
      } yield OptionWeightEstimates(gravitational, dimensional)
    }

    def jsObjectOptionWeightEstimates(obj: io.flow.fulfillment.v0.models.OptionWeightEstimates): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "gravitational" -> io.flow.common.v0.models.json.jsObjectMeasurement(obj.gravitational),
        "dimensional" -> io.flow.common.v0.models.json.jsObjectMeasurement(obj.dimensional)
      )
    }

    implicit def jsonWritesFulfillmentOptionWeightEstimates: play.api.libs.json.Writes[OptionWeightEstimates] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.OptionWeightEstimates] {
        def writes(obj: io.flow.fulfillment.v0.models.OptionWeightEstimates) = {
          jsObjectOptionWeightEstimates(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentOutboundCartonFee: play.api.libs.json.Reads[OutboundCartonFee] = {
      (__ \ "amount").read[io.flow.common.v0.models.Money].map { x => new OutboundCartonFee(amount = x) }
    }

    def jsObjectOutboundCartonFee(obj: io.flow.fulfillment.v0.models.OutboundCartonFee): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "amount" -> io.flow.common.v0.models.json.jsObjectMoney(obj.amount)
      )
    }

    implicit def jsonReadsFulfillmentPackaging: play.api.libs.json.Reads[Packaging] = {
      for {
        dimensions <- (__ \ "dimensions").read[io.flow.common.v0.models.Dimensions]
        name <- (__ \ "name").readNullable[String]
        number <- (__ \ "number").readNullable[String]
      } yield Packaging(dimensions, name, number)
    }

    def jsObjectPackaging(obj: io.flow.fulfillment.v0.models.Packaging): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "dimensions" -> io.flow.common.v0.models.json.jsObjectDimensions(obj.dimensions)
      ) ++ (obj.name match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("name" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.number match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("number" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesFulfillmentPackaging: play.api.libs.json.Writes[Packaging] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.Packaging] {
        def writes(obj: io.flow.fulfillment.v0.models.Packaging) = {
          jsObjectPackaging(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentPartnerCenter: play.api.libs.json.Reads[PartnerCenter] = {
      for {
        partnerReference <- (__ \ "partner_reference").read[io.flow.common.v0.models.PartnerReference]
        number <- (__ \ "number").readNullable[String]
        fees <- (__ \ "fees").readNullable[Seq[io.flow.fulfillment.v0.models.PartnerCenterFee]]
      } yield PartnerCenter(partnerReference, number, fees)
    }

    def jsObjectPartnerCenter(obj: io.flow.fulfillment.v0.models.PartnerCenter): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "partner_reference" -> io.flow.common.v0.models.json.jsObjectPartnerReference(obj.partnerReference)
      ) ++ (obj.number match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("number" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.fees match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("fees" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesFulfillmentPartnerCenter: play.api.libs.json.Writes[PartnerCenter] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.PartnerCenter] {
        def writes(obj: io.flow.fulfillment.v0.models.PartnerCenter) = {
          jsObjectPartnerCenter(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentPartnerCenterForm: play.api.libs.json.Reads[PartnerCenterForm] = {
      for {
        partnerId <- (__ \ "partner_id").read[String]
        number <- (__ \ "number").readNullable[String]
        fees <- (__ \ "fees").readNullable[Seq[io.flow.fulfillment.v0.models.PartnerCenterFee]]
      } yield PartnerCenterForm(partnerId, number, fees)
    }

    def jsObjectPartnerCenterForm(obj: io.flow.fulfillment.v0.models.PartnerCenterForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "partner_id" -> play.api.libs.json.JsString(obj.partnerId)
      ) ++ (obj.number match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("number" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.fees match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("fees" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesFulfillmentPartnerCenterForm: play.api.libs.json.Writes[PartnerCenterForm] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.PartnerCenterForm] {
        def writes(obj: io.flow.fulfillment.v0.models.PartnerCenterForm) = {
          jsObjectPartnerCenterForm(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentPercentMargin: play.api.libs.json.Reads[PercentMargin] = {
      (__ \ "percentage").read[Double].map { x => new PercentMargin(percentage = x) }
    }

    def jsObjectPercentMargin(obj: io.flow.fulfillment.v0.models.PercentMargin): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "percentage" -> play.api.libs.json.JsNumber(obj.percentage)
      )
    }

    implicit def jsonReadsFulfillmentPhysicalDelivery: play.api.libs.json.Reads[PhysicalDelivery] = {
      for {
        id <- (__ \ "id").read[String]
        center <- (__ \ "center").readNullable[io.flow.fulfillment.v0.models.CenterSummary]
        items <- (__ \ "items").read[Seq[io.flow.fulfillment.v0.models.DeliveryItem]]
        options <- (__ \ "options").read[Seq[io.flow.fulfillment.v0.models.DeliveryOption]]
        specialServices <- (__ \ "special_services").readNullable[Seq[io.flow.fulfillment.v0.models.PhysicalDeliverySpecialSerivce]]
      } yield PhysicalDelivery(id, center, items, options, specialServices)
    }

    def jsObjectPhysicalDelivery(obj: io.flow.fulfillment.v0.models.PhysicalDelivery): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "items" -> play.api.libs.json.Json.toJson(obj.items),
        "options" -> play.api.libs.json.Json.toJson(obj.options)
      ) ++ (obj.center match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("center" -> jsObjectCenterSummary(x))
      }) ++
      (obj.specialServices match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("special_services" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonReadsFulfillmentPriceWithBaseAndDetails: play.api.libs.json.Reads[PriceWithBaseAndDetails] = {
      for {
        currency <- (__ \ "currency").read[String]
        amount <- (__ \ "amount").read[Double]
        label <- (__ \ "label").read[String]
        base <- (__ \ "base").readNullable[io.flow.common.v0.models.Price]
        details <- (__ \ "details").readNullable[Seq[io.flow.fulfillment.v0.models.DeliveryOptionCostDetail]]
      } yield PriceWithBaseAndDetails(currency, amount, label, base, details)
    }

    def jsObjectPriceWithBaseAndDetails(obj: io.flow.fulfillment.v0.models.PriceWithBaseAndDetails): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "label" -> play.api.libs.json.JsString(obj.label)
      ) ++ (obj.base match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("base" -> io.flow.common.v0.models.json.jsObjectPrice(x))
      }) ++
      (obj.details match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("details" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesFulfillmentPriceWithBaseAndDetails: play.api.libs.json.Writes[PriceWithBaseAndDetails] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.PriceWithBaseAndDetails] {
        def writes(obj: io.flow.fulfillment.v0.models.PriceWithBaseAndDetails) = {
          jsObjectPriceWithBaseAndDetails(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentProcessingEstimate: play.api.libs.json.Reads[ProcessingEstimate] = {
      for {
        location <- (__ \ "location").read[io.flow.fulfillment.v0.models.DeliveryWindowLocation]
        minDate <- (__ \ "min_date").read[_root_.org.joda.time.DateTime]
        maxDate <- (__ \ "max_date").read[_root_.org.joda.time.DateTime]
        source <- (__ \ "source").read[io.flow.fulfillment.v0.models.DeliveryWindowComponentSource]
      } yield ProcessingEstimate(location, minDate, maxDate, source)
    }

    def jsObjectProcessingEstimate(obj: io.flow.fulfillment.v0.models.ProcessingEstimate): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "location" -> play.api.libs.json.JsString(obj.location.toString),
        "min_date" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.minDate)),
        "max_date" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.maxDate)),
        "source" -> play.api.libs.json.JsString(obj.source.toString)
      )
    }

    implicit def jsonWritesFulfillmentProcessingEstimate: play.api.libs.json.Writes[ProcessingEstimate] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.ProcessingEstimate] {
        def writes(obj: io.flow.fulfillment.v0.models.ProcessingEstimate) = {
          jsObjectProcessingEstimate(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentQuote: play.api.libs.json.Reads[Quote] = {
      for {
        id <- (__ \ "id").read[String]
        destination <- (__ \ "destination").read[io.flow.fulfillment.v0.models.ShippingAddress]
        deliveries <- (__ \ "deliveries").read[Seq[io.flow.fulfillment.v0.models.Delivery]]
        selections <- (__ \ "selections").read[Seq[io.flow.fulfillment.v0.models.DeliveryOptionReference]]
        deliveredDuty <- (__ \ "delivered_duty").read[io.flow.common.v0.models.DeliveredDuty]
        deliveredDuties <- (__ \ "delivered_duties").read[Seq[io.flow.common.v0.models.DeliveredDuty]]
      } yield Quote(id, destination, deliveries, selections, deliveredDuty, deliveredDuties)
    }

    def jsObjectQuote(obj: io.flow.fulfillment.v0.models.Quote): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "destination" -> jsObjectShippingAddress(obj.destination),
        "deliveries" -> play.api.libs.json.Json.toJson(obj.deliveries),
        "selections" -> play.api.libs.json.Json.toJson(obj.selections),
        "delivered_duty" -> play.api.libs.json.JsString(obj.deliveredDuty.toString),
        "delivered_duties" -> play.api.libs.json.Json.toJson(obj.deliveredDuties)
      )
    }

    implicit def jsonWritesFulfillmentQuote: play.api.libs.json.Writes[Quote] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.Quote] {
        def writes(obj: io.flow.fulfillment.v0.models.Quote) = {
          jsObjectQuote(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentQuoteError: play.api.libs.json.Reads[QuoteError] = {
      for {
        code <- (__ \ "code").read[io.flow.fulfillment.v0.models.QuoteErrorCode]
        messages <- (__ \ "messages").read[Seq[String]]
        itemNumbers <- (__ \ "item_numbers").readNullable[Seq[String]]
      } yield QuoteError(code, messages, itemNumbers)
    }

    def jsObjectQuoteError(obj: io.flow.fulfillment.v0.models.QuoteError): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "code" -> play.api.libs.json.JsString(obj.code.toString),
        "messages" -> play.api.libs.json.Json.toJson(obj.messages)
      ) ++ (obj.itemNumbers match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("item_numbers" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesFulfillmentQuoteError: play.api.libs.json.Writes[QuoteError] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.QuoteError] {
        def writes(obj: io.flow.fulfillment.v0.models.QuoteError) = {
          jsObjectQuoteError(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentQuoteForm: play.api.libs.json.Reads[QuoteForm] = {
      for {
        destination <- (__ \ "destination").read[io.flow.fulfillment.v0.models.ShippingAddress]
        experience <- (__ \ "experience").read[String]
        items <- (__ \ "items").read[Seq[io.flow.fulfillment.v0.models.QuoteLineItemForm]]
        deliveredDuty <- (__ \ "delivered_duty").readNullable[io.flow.common.v0.models.DeliveredDuty]
        deliveredDuties <- (__ \ "delivered_duties").readNullable[Seq[io.flow.common.v0.models.DeliveredDuty]]
        direction <- (__ \ "direction").readNullable[io.flow.fulfillment.v0.models.TierDirection]
      } yield QuoteForm(destination, experience, items, deliveredDuty, deliveredDuties, direction)
    }

    def jsObjectQuoteForm(obj: io.flow.fulfillment.v0.models.QuoteForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "destination" -> jsObjectShippingAddress(obj.destination),
        "experience" -> play.api.libs.json.JsString(obj.experience),
        "items" -> play.api.libs.json.Json.toJson(obj.items)
      ) ++ (obj.deliveredDuty match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("delivered_duty" -> play.api.libs.json.JsString(x.toString))
      }) ++
      (obj.deliveredDuties match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("delivered_duties" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.direction match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("direction" -> play.api.libs.json.JsString(x.toString))
      })
    }

    implicit def jsonWritesFulfillmentQuoteForm: play.api.libs.json.Writes[QuoteForm] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.QuoteForm] {
        def writes(obj: io.flow.fulfillment.v0.models.QuoteForm) = {
          jsObjectQuoteForm(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentQuoteLineItemForm: play.api.libs.json.Reads[QuoteLineItemForm] = {
      for {
        number <- (__ \ "number").read[String]
        quantity <- (__ \ "quantity").read[Long]
        shipmentEstimate <- (__ \ "shipment_estimate").readNullable[io.flow.common.v0.models.DatetimeRange]
        price <- (__ \ "price").readNullable[io.flow.common.v0.models.MoneyWithBase]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
        center <- (__ \ "center").readNullable[String]
        discount <- (__ \ "discount").readNullable[io.flow.common.v0.models.Money]
        discounts <- (__ \ "discounts").readNullable[io.flow.common.v0.models.DiscountsForm]
      } yield QuoteLineItemForm(number, quantity, shipmentEstimate, price, attributes, center, discount, discounts)
    }

    def jsObjectQuoteLineItemForm(obj: io.flow.fulfillment.v0.models.QuoteLineItemForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "number" -> play.api.libs.json.JsString(obj.number),
        "quantity" -> play.api.libs.json.JsNumber(obj.quantity)
      ) ++ (obj.shipmentEstimate match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("shipment_estimate" -> io.flow.common.v0.models.json.jsObjectDatetimeRange(x))
      }) ++
      (obj.price match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("price" -> io.flow.common.v0.models.json.jsObjectMoneyWithBase(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.center match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("center" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.discount match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("discount" -> io.flow.common.v0.models.json.jsObjectMoney(x))
      }) ++
      (obj.discounts match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("discounts" -> io.flow.common.v0.models.json.jsObjectDiscountsForm(x))
      })
    }

    implicit def jsonWritesFulfillmentQuoteLineItemForm: play.api.libs.json.Writes[QuoteLineItemForm] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.QuoteLineItemForm] {
        def writes(obj: io.flow.fulfillment.v0.models.QuoteLineItemForm) = {
          jsObjectQuoteLineItemForm(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentQuoteSummary: play.api.libs.json.Reads[QuoteSummary] = {
      for {
        id <- (__ \ "id").read[String]
        destination <- (__ \ "destination").read[io.flow.fulfillment.v0.models.ShippingAddress]
      } yield QuoteSummary(id, destination)
    }

    def jsObjectQuoteSummary(obj: io.flow.fulfillment.v0.models.QuoteSummary): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "destination" -> jsObjectShippingAddress(obj.destination)
      )
    }

    implicit def jsonWritesFulfillmentQuoteSummary: play.api.libs.json.Writes[QuoteSummary] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.QuoteSummary] {
        def writes(obj: io.flow.fulfillment.v0.models.QuoteSummary) = {
          jsObjectQuoteSummary(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentQuoteVersion: play.api.libs.json.Reads[QuoteVersion] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        quote <- (__ \ "quote").read[io.flow.fulfillment.v0.models.QuoteSummary]
      } yield QuoteVersion(id, timestamp, `type`, quote)
    }

    def jsObjectQuoteVersion(obj: io.flow.fulfillment.v0.models.QuoteVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "quote" -> jsObjectQuoteSummary(obj.quote)
      )
    }

    implicit def jsonWritesFulfillmentQuoteVersion: play.api.libs.json.Writes[QuoteVersion] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.QuoteVersion] {
        def writes(obj: io.flow.fulfillment.v0.models.QuoteVersion) = {
          jsObjectQuoteVersion(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentScheduledPickup: play.api.libs.json.Reads[ScheduledPickup] = {
      for {
        dayOfWeek <- (__ \ "day_of_week").read[io.flow.common.v0.models.DayOfWeek]
        hourOfDay <- (__ \ "hour_of_day").read[String]
        minuteOfHour <- (__ \ "minute_of_hour").read[String]
      } yield ScheduledPickup(dayOfWeek, hourOfDay, minuteOfHour)
    }

    def jsObjectScheduledPickup(obj: io.flow.fulfillment.v0.models.ScheduledPickup): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "day_of_week" -> play.api.libs.json.JsString(obj.dayOfWeek.toString),
        "hour_of_day" -> play.api.libs.json.JsString(obj.hourOfDay),
        "minute_of_hour" -> play.api.libs.json.JsString(obj.minuteOfHour)
      )
    }

    implicit def jsonWritesFulfillmentScheduledPickup: play.api.libs.json.Writes[ScheduledPickup] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.ScheduledPickup] {
        def writes(obj: io.flow.fulfillment.v0.models.ScheduledPickup) = {
          jsObjectScheduledPickup(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentServiceReference: play.api.libs.json.Reads[ServiceReference] = {
      (__ \ "id").read[String].map { x => new ServiceReference(id = x) }
    }

    def jsObjectServiceReference(obj: io.flow.fulfillment.v0.models.ServiceReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id)
      )
    }

    implicit def jsonWritesFulfillmentServiceReference: play.api.libs.json.Writes[ServiceReference] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.ServiceReference] {
        def writes(obj: io.flow.fulfillment.v0.models.ServiceReference) = {
          jsObjectServiceReference(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentServiceSummary: play.api.libs.json.Reads[ServiceSummary] = {
      for {
        id <- (__ \ "id").read[String]
        carrier <- (__ \ "carrier").read[io.flow.fulfillment.v0.models.CarrierReference]
        name <- (__ \ "name").read[String]
        centerCode <- (__ \ "center_code").readNullable[String]
      } yield ServiceSummary(id, carrier, name, centerCode)
    }

    def jsObjectServiceSummary(obj: io.flow.fulfillment.v0.models.ServiceSummary): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "carrier" -> jsObjectCarrierReference(obj.carrier),
        "name" -> play.api.libs.json.JsString(obj.name)
      ) ++ (obj.centerCode match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("center_code" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesFulfillmentServiceSummary: play.api.libs.json.Writes[ServiceSummary] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.ServiceSummary] {
        def writes(obj: io.flow.fulfillment.v0.models.ServiceSummary) = {
          jsObjectServiceSummary(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentShippingAddress: play.api.libs.json.Reads[ShippingAddress] = {
      for {
        contact <- (__ \ "contact").read[io.flow.common.v0.models.Contact]
        location <- (__ \ "location").read[io.flow.common.v0.models.Address]
        centerKey <- (__ \ "center_key").readNullable[String]
        centerReference <- (__ \ "center_reference").readNullable[io.flow.fulfillment.v0.models.CenterReference]
        service <- (__ \ "service").readNullable[io.flow.fulfillment.v0.models.ServiceSummary]
      } yield ShippingAddress(contact, location, centerKey, centerReference, service)
    }

    def jsObjectShippingAddress(obj: io.flow.fulfillment.v0.models.ShippingAddress): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "contact" -> io.flow.common.v0.models.json.jsObjectContact(obj.contact),
        "location" -> io.flow.common.v0.models.json.jsObjectAddress(obj.location)
      ) ++ (obj.centerKey match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("center_key" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.centerReference match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("center_reference" -> jsObjectCenterReference(x))
      }) ++
      (obj.service match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("service" -> jsObjectServiceSummary(x))
      })
    }

    implicit def jsonWritesFulfillmentShippingAddress: play.api.libs.json.Writes[ShippingAddress] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.ShippingAddress] {
        def writes(obj: io.flow.fulfillment.v0.models.ShippingAddress) = {
          jsObjectShippingAddress(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentShippingConfiguration: play.api.libs.json.Reads[ShippingConfiguration] = {
      for {
        id <- (__ \ "id").read[String]
        name <- (__ \ "name").read[String]
        key <- (__ \ "key").read[String]
        `type` <- (__ \ "type").read[io.flow.fulfillment.v0.models.ShippingConfigurationType]
        shippingLanes <- (__ \ "shipping_lanes").read[Seq[io.flow.fulfillment.v0.models.ShippingLane]]
      } yield ShippingConfiguration(id, name, key, `type`, shippingLanes)
    }

    def jsObjectShippingConfiguration(obj: io.flow.fulfillment.v0.models.ShippingConfiguration): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "name" -> play.api.libs.json.JsString(obj.name),
        "key" -> play.api.libs.json.JsString(obj.key),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "shipping_lanes" -> play.api.libs.json.Json.toJson(obj.shippingLanes)
      )
    }

    implicit def jsonWritesFulfillmentShippingConfiguration: play.api.libs.json.Writes[ShippingConfiguration] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.ShippingConfiguration] {
        def writes(obj: io.flow.fulfillment.v0.models.ShippingConfiguration) = {
          jsObjectShippingConfiguration(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentShippingConfigurationCopy: play.api.libs.json.Reads[ShippingConfigurationCopy] = {
      for {
        original <- (__ \ "original").read[io.flow.fulfillment.v0.models.ShippingConfigurationReference]
        `new` <- (__ \ "new").read[io.flow.fulfillment.v0.models.ShippingConfigurationReference]
      } yield ShippingConfigurationCopy(original, `new`)
    }

    def jsObjectShippingConfigurationCopy(obj: io.flow.fulfillment.v0.models.ShippingConfigurationCopy): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "original" -> jsObjectShippingConfigurationReference(obj.original),
        "new" -> jsObjectShippingConfigurationReference(obj.`new`)
      )
    }

    implicit def jsonWritesFulfillmentShippingConfigurationCopy: play.api.libs.json.Writes[ShippingConfigurationCopy] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.ShippingConfigurationCopy] {
        def writes(obj: io.flow.fulfillment.v0.models.ShippingConfigurationCopy) = {
          jsObjectShippingConfigurationCopy(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentShippingConfigurationCopyForm: play.api.libs.json.Reads[ShippingConfigurationCopyForm] = {
      (__ \ "name").read[String].map { x => new ShippingConfigurationCopyForm(name = x) }
    }

    def jsObjectShippingConfigurationCopyForm(obj: io.flow.fulfillment.v0.models.ShippingConfigurationCopyForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "name" -> play.api.libs.json.JsString(obj.name)
      )
    }

    implicit def jsonWritesFulfillmentShippingConfigurationCopyForm: play.api.libs.json.Writes[ShippingConfigurationCopyForm] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.ShippingConfigurationCopyForm] {
        def writes(obj: io.flow.fulfillment.v0.models.ShippingConfigurationCopyForm) = {
          jsObjectShippingConfigurationCopyForm(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentShippingConfigurationForm: play.api.libs.json.Reads[ShippingConfigurationForm] = {
      (__ \ "name").read[String].map { x => new ShippingConfigurationForm(name = x) }
    }

    def jsObjectShippingConfigurationForm(obj: io.flow.fulfillment.v0.models.ShippingConfigurationForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "name" -> play.api.libs.json.JsString(obj.name)
      )
    }

    implicit def jsonWritesFulfillmentShippingConfigurationForm: play.api.libs.json.Writes[ShippingConfigurationForm] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.ShippingConfigurationForm] {
        def writes(obj: io.flow.fulfillment.v0.models.ShippingConfigurationForm) = {
          jsObjectShippingConfigurationForm(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentShippingConfigurationItemAvailability: play.api.libs.json.Reads[ShippingConfigurationItemAvailability] = {
      for {
        id <- (__ \ "id").read[String]
        item <- (__ \ "item").read[io.flow.common.v0.models.ItemReference]
        shippingConfiguration <- (__ \ "shipping_configuration").read[io.flow.fulfillment.v0.models.ShippingConfigurationSummary]
        availabilities <- (__ \ "availabilities").read[Seq[io.flow.fulfillment.v0.models.CountryAvailability]]
      } yield ShippingConfigurationItemAvailability(id, item, shippingConfiguration, availabilities)
    }

    def jsObjectShippingConfigurationItemAvailability(obj: io.flow.fulfillment.v0.models.ShippingConfigurationItemAvailability): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "item" -> io.flow.common.v0.models.json.jsObjectItemReference(obj.item),
        "shipping_configuration" -> jsObjectShippingConfigurationSummary(obj.shippingConfiguration),
        "availabilities" -> play.api.libs.json.Json.toJson(obj.availabilities)
      )
    }

    implicit def jsonWritesFulfillmentShippingConfigurationItemAvailability: play.api.libs.json.Writes[ShippingConfigurationItemAvailability] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.ShippingConfigurationItemAvailability] {
        def writes(obj: io.flow.fulfillment.v0.models.ShippingConfigurationItemAvailability) = {
          jsObjectShippingConfigurationItemAvailability(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentShippingConfigurationItemShippingPricing: play.api.libs.json.Reads[ShippingConfigurationItemShippingPricing] = {
      for {
        id <- (__ \ "id").read[String]
        item <- (__ \ "item").read[io.flow.common.v0.models.ItemReference]
        shippingConfiguration <- (__ \ "shipping_configuration").read[io.flow.fulfillment.v0.models.ShippingConfigurationSummary]
        countryShippingPricings <- (__ \ "country_shipping_pricings").read[Seq[io.flow.fulfillment.v0.models.CountryShippingPricing]]
      } yield ShippingConfigurationItemShippingPricing(id, item, shippingConfiguration, countryShippingPricings)
    }

    def jsObjectShippingConfigurationItemShippingPricing(obj: io.flow.fulfillment.v0.models.ShippingConfigurationItemShippingPricing): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "item" -> io.flow.common.v0.models.json.jsObjectItemReference(obj.item),
        "shipping_configuration" -> jsObjectShippingConfigurationSummary(obj.shippingConfiguration),
        "country_shipping_pricings" -> play.api.libs.json.Json.toJson(obj.countryShippingPricings)
      )
    }

    implicit def jsonWritesFulfillmentShippingConfigurationItemShippingPricing: play.api.libs.json.Writes[ShippingConfigurationItemShippingPricing] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.ShippingConfigurationItemShippingPricing] {
        def writes(obj: io.flow.fulfillment.v0.models.ShippingConfigurationItemShippingPricing) = {
          jsObjectShippingConfigurationItemShippingPricing(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentShippingConfigurationReference: play.api.libs.json.Reads[ShippingConfigurationReference] = {
      (__ \ "key").read[String].map { x => new ShippingConfigurationReference(key = x) }
    }

    def jsObjectShippingConfigurationReference(obj: io.flow.fulfillment.v0.models.ShippingConfigurationReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key)
      )
    }

    implicit def jsonWritesFulfillmentShippingConfigurationReference: play.api.libs.json.Writes[ShippingConfigurationReference] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.ShippingConfigurationReference] {
        def writes(obj: io.flow.fulfillment.v0.models.ShippingConfigurationReference) = {
          jsObjectShippingConfigurationReference(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentShippingConfigurationSummary: play.api.libs.json.Reads[ShippingConfigurationSummary] = {
      for {
        id <- (__ \ "id").read[String]
        name <- (__ \ "name").read[String]
        key <- (__ \ "key").read[String]
        `type` <- (__ \ "type").read[io.flow.fulfillment.v0.models.ShippingConfigurationType]
      } yield ShippingConfigurationSummary(id, name, key, `type`)
    }

    def jsObjectShippingConfigurationSummary(obj: io.flow.fulfillment.v0.models.ShippingConfigurationSummary): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "name" -> play.api.libs.json.JsString(obj.name),
        "key" -> play.api.libs.json.JsString(obj.key),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString)
      )
    }

    implicit def jsonWritesFulfillmentShippingConfigurationSummary: play.api.libs.json.Writes[ShippingConfigurationSummary] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.ShippingConfigurationSummary] {
        def writes(obj: io.flow.fulfillment.v0.models.ShippingConfigurationSummary) = {
          jsObjectShippingConfigurationSummary(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentShippingConfigurationVersion: play.api.libs.json.Reads[ShippingConfigurationVersion] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        shippingConfiguration <- (__ \ "shipping_configuration").read[io.flow.fulfillment.v0.models.ShippingConfiguration]
      } yield ShippingConfigurationVersion(id, timestamp, `type`, shippingConfiguration)
    }

    def jsObjectShippingConfigurationVersion(obj: io.flow.fulfillment.v0.models.ShippingConfigurationVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "shipping_configuration" -> jsObjectShippingConfiguration(obj.shippingConfiguration)
      )
    }

    implicit def jsonWritesFulfillmentShippingConfigurationVersion: play.api.libs.json.Writes[ShippingConfigurationVersion] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.ShippingConfigurationVersion] {
        def writes(obj: io.flow.fulfillment.v0.models.ShippingConfigurationVersion) = {
          jsObjectShippingConfigurationVersion(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentShippingLane: play.api.libs.json.Reads[ShippingLane] = {
      for {
        id <- (__ \ "id").read[String]
        shippingConfiguration <- (__ \ "shipping_configuration").read[io.flow.fulfillment.v0.models.ShippingConfigurationReference]
        region <- (__ \ "region").read[String]
        centers <- (__ \ "centers").read[Seq[io.flow.fulfillment.v0.models.ExpandableCenter]]
        tiers <- (__ \ "tiers").read[Seq[io.flow.fulfillment.v0.models.Tier]]
        query <- (__ \ "query").read[io.flow.query.builder.v0.models.Query]
        strategy <- (__ \ "strategy").read[io.flow.fulfillment.v0.models.LaneStrategy]
      } yield ShippingLane(id, shippingConfiguration, region, centers, tiers, query, strategy)
    }

    def jsObjectShippingLane(obj: io.flow.fulfillment.v0.models.ShippingLane): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "shipping_configuration" -> jsObjectShippingConfigurationReference(obj.shippingConfiguration),
        "region" -> play.api.libs.json.JsString(obj.region),
        "centers" -> play.api.libs.json.Json.toJson(obj.centers),
        "tiers" -> play.api.libs.json.Json.toJson(obj.tiers),
        "query" -> io.flow.query.builder.v0.models.json.jsObjectQuery(obj.query),
        "strategy" -> play.api.libs.json.JsString(obj.strategy.toString)
      )
    }

    implicit def jsonWritesFulfillmentShippingLane: play.api.libs.json.Writes[ShippingLane] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.ShippingLane] {
        def writes(obj: io.flow.fulfillment.v0.models.ShippingLane) = {
          jsObjectShippingLane(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentShippingLaneForm: play.api.libs.json.Reads[ShippingLaneForm] = {
      for {
        from <- (__ \ "from").read[String]
        to <- (__ \ "to").read[String]
        strategy <- (__ \ "strategy").readNullable[io.flow.fulfillment.v0.models.LaneStrategy]
      } yield ShippingLaneForm(from, to, strategy)
    }

    def jsObjectShippingLaneForm(obj: io.flow.fulfillment.v0.models.ShippingLaneForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "from" -> play.api.libs.json.JsString(obj.from),
        "to" -> play.api.libs.json.JsString(obj.to)
      ) ++ (obj.strategy match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("strategy" -> play.api.libs.json.JsString(x.toString))
      })
    }

    implicit def jsonWritesFulfillmentShippingLaneForm: play.api.libs.json.Writes[ShippingLaneForm] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.ShippingLaneForm] {
        def writes(obj: io.flow.fulfillment.v0.models.ShippingLaneForm) = {
          jsObjectShippingLaneForm(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentShippingLaneVersion: play.api.libs.json.Reads[ShippingLaneVersion] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        shippingLane <- (__ \ "shipping_lane").read[io.flow.fulfillment.v0.models.ShippingLane]
      } yield ShippingLaneVersion(id, timestamp, `type`, shippingLane)
    }

    def jsObjectShippingLaneVersion(obj: io.flow.fulfillment.v0.models.ShippingLaneVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "shipping_lane" -> jsObjectShippingLane(obj.shippingLane)
      )
    }

    implicit def jsonWritesFulfillmentShippingLaneVersion: play.api.libs.json.Writes[ShippingLaneVersion] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.ShippingLaneVersion] {
        def writes(obj: io.flow.fulfillment.v0.models.ShippingLaneVersion) = {
          jsObjectShippingLaneVersion(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentSurchargeResponsiblePartyDisplay: play.api.libs.json.Reads[SurchargeResponsiblePartyDisplay] = {
      for {
        name <- (__ \ "name").read[String]
        responsibleParty <- (__ \ "responsible_party").read[io.flow.fulfillment.v0.models.SurchargeResponsibleParty]
      } yield SurchargeResponsiblePartyDisplay(name, responsibleParty)
    }

    def jsObjectSurchargeResponsiblePartyDisplay(obj: io.flow.fulfillment.v0.models.SurchargeResponsiblePartyDisplay): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "name" -> play.api.libs.json.JsString(obj.name),
        "responsible_party" -> play.api.libs.json.JsString(obj.responsibleParty.toString)
      )
    }

    implicit def jsonWritesFulfillmentSurchargeResponsiblePartyDisplay: play.api.libs.json.Writes[SurchargeResponsiblePartyDisplay] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.SurchargeResponsiblePartyDisplay] {
        def writes(obj: io.flow.fulfillment.v0.models.SurchargeResponsiblePartyDisplay) = {
          jsObjectSurchargeResponsiblePartyDisplay(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentSurchargeSetting: play.api.libs.json.Reads[SurchargeSetting] = {
      for {
        key <- (__ \ "key").read[io.flow.fulfillment.v0.models.DeliveryOptionCostDetailComponentKey]
        responsibleParty <- (__ \ "responsible_party").read[io.flow.fulfillment.v0.models.SurchargeResponsibleParty]
      } yield SurchargeSetting(key, responsibleParty)
    }

    def jsObjectSurchargeSetting(obj: io.flow.fulfillment.v0.models.SurchargeSetting): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key.toString),
        "responsible_party" -> play.api.libs.json.JsString(obj.responsibleParty.toString)
      )
    }

    implicit def jsonWritesFulfillmentSurchargeSetting: play.api.libs.json.Writes[SurchargeSetting] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.SurchargeSetting] {
        def writes(obj: io.flow.fulfillment.v0.models.SurchargeSetting) = {
          jsObjectSurchargeSetting(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentSurchargeSettingDisplay: play.api.libs.json.Reads[SurchargeSettingDisplay] = {
      for {
        name <- (__ \ "name").read[String]
        description <- (__ \ "description").read[String]
        key <- (__ \ "key").read[io.flow.fulfillment.v0.models.DeliveryOptionCostDetailComponentKey]
        available <- (__ \ "available").read[Seq[io.flow.fulfillment.v0.models.SurchargeResponsiblePartyDisplay]]
      } yield SurchargeSettingDisplay(name, description, key, available)
    }

    def jsObjectSurchargeSettingDisplay(obj: io.flow.fulfillment.v0.models.SurchargeSettingDisplay): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "name" -> play.api.libs.json.JsString(obj.name),
        "description" -> play.api.libs.json.JsString(obj.description),
        "key" -> play.api.libs.json.JsString(obj.key.toString),
        "available" -> play.api.libs.json.Json.toJson(obj.available)
      )
    }

    implicit def jsonWritesFulfillmentSurchargeSettingDisplay: play.api.libs.json.Writes[SurchargeSettingDisplay] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.SurchargeSettingDisplay] {
        def writes(obj: io.flow.fulfillment.v0.models.SurchargeSettingDisplay) = {
          jsObjectSurchargeSettingDisplay(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentTier: play.api.libs.json.Reads[Tier] = {
      for {
        id <- (__ \ "id").read[String]
        direction <- (__ \ "direction").read[io.flow.fulfillment.v0.models.TierDirection]
        integration <- (__ \ "integration").read[io.flow.fulfillment.v0.models.ShipmentIntegrationType]
        name <- (__ \ "name").read[String]
        message <- (__ \ "message").readNullable[String]
        rules <- (__ \ "rules").read[Seq[io.flow.fulfillment.v0.models.TierRule]]
        services <- (__ \ "services").read[Seq[io.flow.reference.v0.models.CarrierService]]
        strategy <- (__ \ "strategy").read[io.flow.fulfillment.v0.models.TierStrategy]
        visibility <- (__ \ "visibility").read[io.flow.common.v0.models.Visibility]
        currency <- (__ \ "currency").read[String]
        description <- (__ \ "description").readNullable[String]
        display <- (__ \ "display").readNullable[io.flow.fulfillment.v0.models.TierDisplay]
        shippingLane <- (__ \ "shipping_lane").readNullable[String]
        surchargeSettings <- (__ \ "surcharge_settings").readNullable[Seq[io.flow.fulfillment.v0.models.SurchargeSetting]]
      } yield Tier(id, direction, integration, name, message, rules, services, strategy, visibility, currency, description, display, shippingLane, surchargeSettings)
    }

    def jsObjectTier(obj: io.flow.fulfillment.v0.models.Tier): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "direction" -> play.api.libs.json.JsString(obj.direction.toString),
        "integration" -> play.api.libs.json.JsString(obj.integration.toString),
        "name" -> play.api.libs.json.JsString(obj.name),
        "rules" -> play.api.libs.json.Json.toJson(obj.rules),
        "services" -> play.api.libs.json.Json.toJson(obj.services),
        "strategy" -> play.api.libs.json.JsString(obj.strategy.toString),
        "visibility" -> play.api.libs.json.JsString(obj.visibility.toString),
        "currency" -> play.api.libs.json.JsString(obj.currency)
      ) ++ (obj.message match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("message" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.display match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("display" -> jsObjectTierDisplay(x))
      }) ++
      (obj.shippingLane match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("shipping_lane" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.surchargeSettings match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("surcharge_settings" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesFulfillmentTier: play.api.libs.json.Writes[Tier] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.Tier] {
        def writes(obj: io.flow.fulfillment.v0.models.Tier) = {
          jsObjectTier(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentTierDisplay: play.api.libs.json.Reads[TierDisplay] = {
      (__ \ "estimate").read[io.flow.fulfillment.v0.models.TierEstimate].map { x => new TierDisplay(estimate = x) }
    }

    def jsObjectTierDisplay(obj: io.flow.fulfillment.v0.models.TierDisplay): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "estimate" -> jsObjectTierEstimate(obj.estimate)
      )
    }

    implicit def jsonWritesFulfillmentTierDisplay: play.api.libs.json.Writes[TierDisplay] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.TierDisplay] {
        def writes(obj: io.flow.fulfillment.v0.models.TierDisplay) = {
          jsObjectTierDisplay(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentTierDisplayForm: play.api.libs.json.Reads[TierDisplayForm] = {
      (__ \ "estimate").readNullable[io.flow.fulfillment.v0.models.TierEstimate].map { x => new TierDisplayForm(estimate = x) }
    }

    def jsObjectTierDisplayForm(obj: io.flow.fulfillment.v0.models.TierDisplayForm): play.api.libs.json.JsObject = {
      (obj.estimate match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("estimate" -> jsObjectTierEstimate(x))
      })
    }

    implicit def jsonWritesFulfillmentTierDisplayForm: play.api.libs.json.Writes[TierDisplayForm] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.TierDisplayForm] {
        def writes(obj: io.flow.fulfillment.v0.models.TierDisplayForm) = {
          jsObjectTierDisplayForm(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentTierEstimate: play.api.libs.json.Reads[TierEstimate] = {
      for {
        `type` <- (__ \ "type").read[io.flow.fulfillment.v0.models.TierEstimateType]
        label <- (__ \ "label").readNullable[String]
      } yield TierEstimate(`type`, label)
    }

    def jsObjectTierEstimate(obj: io.flow.fulfillment.v0.models.TierEstimate): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "type" -> play.api.libs.json.JsString(obj.`type`.toString)
      ) ++ (obj.label match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("label" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesFulfillmentTierEstimate: play.api.libs.json.Writes[TierEstimate] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.TierEstimate] {
        def writes(obj: io.flow.fulfillment.v0.models.TierEstimate) = {
          jsObjectTierEstimate(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentTierForm: play.api.libs.json.Reads[TierForm] = {
      for {
        currency <- (__ \ "currency").read[String]
        integration <- (__ \ "integration").read[io.flow.fulfillment.v0.models.ShipmentIntegrationType]
        name <- (__ \ "name").read[String]
        message <- (__ \ "message").readNullable[String]
        rules <- (__ \ "rules").read[Seq[io.flow.fulfillment.v0.models.TierRuleForm]]
        services <- (__ \ "services").read[Seq[String]]
        strategy <- (__ \ "strategy").read[io.flow.fulfillment.v0.models.TierStrategy]
        visibility <- (__ \ "visibility").read[io.flow.common.v0.models.Visibility]
        description <- (__ \ "description").readNullable[String]
        direction <- (__ \ "direction").readNullable[io.flow.fulfillment.v0.models.TierDirection]
        display <- (__ \ "display").readNullable[io.flow.fulfillment.v0.models.TierDisplayForm]
        shippingLane <- (__ \ "shipping_lane").read[String]
        surchargeSettings <- (__ \ "surcharge_settings").readNullable[Seq[io.flow.fulfillment.v0.models.SurchargeSetting]]
      } yield TierForm(currency, integration, name, message, rules, services, strategy, visibility, description, direction, display, shippingLane, surchargeSettings)
    }

    def jsObjectTierForm(obj: io.flow.fulfillment.v0.models.TierForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "integration" -> play.api.libs.json.JsString(obj.integration.toString),
        "name" -> play.api.libs.json.JsString(obj.name),
        "rules" -> play.api.libs.json.Json.toJson(obj.rules),
        "services" -> play.api.libs.json.Json.toJson(obj.services),
        "strategy" -> play.api.libs.json.JsString(obj.strategy.toString),
        "visibility" -> play.api.libs.json.JsString(obj.visibility.toString),
        "shipping_lane" -> play.api.libs.json.JsString(obj.shippingLane)
      ) ++ (obj.message match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("message" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.direction match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("direction" -> play.api.libs.json.JsString(x.toString))
      }) ++
      (obj.display match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("display" -> jsObjectTierDisplayForm(x))
      }) ++
      (obj.surchargeSettings match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("surcharge_settings" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesFulfillmentTierForm: play.api.libs.json.Writes[TierForm] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.TierForm] {
        def writes(obj: io.flow.fulfillment.v0.models.TierForm) = {
          jsObjectTierForm(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentTierReference: play.api.libs.json.Reads[TierReference] = {
      (__ \ "id").read[String].map { x => new TierReference(id = x) }
    }

    def jsObjectTierReference(obj: io.flow.fulfillment.v0.models.TierReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id)
      )
    }

    implicit def jsonWritesFulfillmentTierReference: play.api.libs.json.Writes[TierReference] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.TierReference] {
        def writes(obj: io.flow.fulfillment.v0.models.TierReference) = {
          jsObjectTierReference(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentTierRule: play.api.libs.json.Reads[TierRule] = {
      for {
        id <- (__ \ "id").read[String]
        position <- (__ \ "position").read[Long]
        query <- (__ \ "query").read[String]
        outcome <- (__ \ "outcome").read[io.flow.fulfillment.v0.models.TierRuleOutcome]
      } yield TierRule(id, position, query, outcome)
    }

    def jsObjectTierRule(obj: io.flow.fulfillment.v0.models.TierRule): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "position" -> play.api.libs.json.JsNumber(obj.position),
        "query" -> play.api.libs.json.JsString(obj.query),
        "outcome" -> jsObjectTierRuleOutcome(obj.outcome)
      )
    }

    implicit def jsonWritesFulfillmentTierRule: play.api.libs.json.Writes[TierRule] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.TierRule] {
        def writes(obj: io.flow.fulfillment.v0.models.TierRule) = {
          jsObjectTierRule(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentTierRuleForm: play.api.libs.json.Reads[TierRuleForm] = {
      for {
        position <- (__ \ "position").readNullable[Long]
        query <- (__ \ "query").read[String]
        outcome <- (__ \ "outcome").read[io.flow.fulfillment.v0.models.TierRuleOutcomeForm]
      } yield TierRuleForm(position, query, outcome)
    }

    def jsObjectTierRuleForm(obj: io.flow.fulfillment.v0.models.TierRuleForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "query" -> play.api.libs.json.JsString(obj.query),
        "outcome" -> jsObjectTierRuleOutcomeForm(obj.outcome)
      ) ++ (obj.position match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("position" -> play.api.libs.json.JsNumber(x))
      })
    }

    implicit def jsonWritesFulfillmentTierRuleForm: play.api.libs.json.Writes[TierRuleForm] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.TierRuleForm] {
        def writes(obj: io.flow.fulfillment.v0.models.TierRuleForm) = {
          jsObjectTierRuleForm(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentTierRuleVersion: play.api.libs.json.Reads[TierRuleVersion] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        tierRule <- (__ \ "tier_rule").read[io.flow.fulfillment.v0.models.TierRule]
      } yield TierRuleVersion(id, timestamp, `type`, tierRule)
    }

    def jsObjectTierRuleVersion(obj: io.flow.fulfillment.v0.models.TierRuleVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "tier_rule" -> jsObjectTierRule(obj.tierRule)
      )
    }

    implicit def jsonWritesFulfillmentTierRuleVersion: play.api.libs.json.Writes[TierRuleVersion] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.TierRuleVersion] {
        def writes(obj: io.flow.fulfillment.v0.models.TierRuleVersion) = {
          jsObjectTierRuleVersion(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentTierSummary: play.api.libs.json.Reads[TierSummary] = {
      for {
        id <- (__ \ "id").read[String]
        experience <- (__ \ "experience").readNullable[io.flow.fulfillment.v0.models.FulfillmentExperienceReference]
        integration <- (__ \ "integration").read[io.flow.fulfillment.v0.models.ShipmentIntegrationType]
        name <- (__ \ "name").read[String]
        services <- (__ \ "services").read[Seq[String]]
        strategy <- (__ \ "strategy").read[io.flow.fulfillment.v0.models.TierStrategy]
        visibility <- (__ \ "visibility").read[io.flow.common.v0.models.Visibility]
        currency <- (__ \ "currency").read[String]
        display <- (__ \ "display").readNullable[io.flow.fulfillment.v0.models.TierDisplay]
        message <- (__ \ "message").readNullable[String]
      } yield TierSummary(id, experience, integration, name, services, strategy, visibility, currency, display, message)
    }

    def jsObjectTierSummary(obj: io.flow.fulfillment.v0.models.TierSummary): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "integration" -> play.api.libs.json.JsString(obj.integration.toString),
        "name" -> play.api.libs.json.JsString(obj.name),
        "services" -> play.api.libs.json.Json.toJson(obj.services),
        "strategy" -> play.api.libs.json.JsString(obj.strategy.toString),
        "visibility" -> play.api.libs.json.JsString(obj.visibility.toString),
        "currency" -> play.api.libs.json.JsString(obj.currency)
      ) ++ (obj.experience match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("experience" -> jsObjectFulfillmentExperienceReference(x))
      }) ++
      (obj.display match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("display" -> jsObjectTierDisplay(x))
      }) ++
      (obj.message match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("message" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesFulfillmentTierSummary: play.api.libs.json.Writes[TierSummary] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.TierSummary] {
        def writes(obj: io.flow.fulfillment.v0.models.TierSummary) = {
          jsObjectTierSummary(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentTierVersion: play.api.libs.json.Reads[TierVersion] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        tier <- (__ \ "tier").read[io.flow.fulfillment.v0.models.TierSummary]
      } yield TierVersion(id, timestamp, `type`, tier)
    }

    def jsObjectTierVersion(obj: io.flow.fulfillment.v0.models.TierVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "tier" -> jsObjectTierSummary(obj.tier)
      )
    }

    implicit def jsonWritesFulfillmentTierVersion: play.api.libs.json.Writes[TierVersion] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.TierVersion] {
        def writes(obj: io.flow.fulfillment.v0.models.TierVersion) = {
          jsObjectTierVersion(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentTransitEstimate: play.api.libs.json.Reads[TransitEstimate] = {
      for {
        origin <- (__ \ "origin").read[io.flow.fulfillment.v0.models.DeliveryWindowLocation]
        destination <- (__ \ "destination").read[io.flow.fulfillment.v0.models.DeliveryWindowLocation]
        minDate <- (__ \ "min_date").read[_root_.org.joda.time.DateTime]
        maxDate <- (__ \ "max_date").read[_root_.org.joda.time.DateTime]
        source <- (__ \ "source").read[io.flow.fulfillment.v0.models.DeliveryWindowComponentSource]
      } yield TransitEstimate(origin, destination, minDate, maxDate, source)
    }

    def jsObjectTransitEstimate(obj: io.flow.fulfillment.v0.models.TransitEstimate): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "origin" -> play.api.libs.json.JsString(obj.origin.toString),
        "destination" -> play.api.libs.json.JsString(obj.destination.toString),
        "min_date" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.minDate)),
        "max_date" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.maxDate)),
        "source" -> play.api.libs.json.JsString(obj.source.toString)
      )
    }

    implicit def jsonWritesFulfillmentTransitEstimate: play.api.libs.json.Writes[TransitEstimate] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.TransitEstimate] {
        def writes(obj: io.flow.fulfillment.v0.models.TransitEstimate) = {
          jsObjectTransitEstimate(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentDelivery: play.api.libs.json.Reads[Delivery] = new play.api.libs.json.Reads[Delivery] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[Delivery] = {
        (js \ "discriminator").asOpt[String].getOrElse("physical_delivery") match {
          case "digital_delivery" => js.validate[io.flow.fulfillment.v0.models.DigitalDelivery]
          case "physical_delivery" => js.validate[io.flow.fulfillment.v0.models.PhysicalDelivery]
          case other => play.api.libs.json.JsSuccess(io.flow.fulfillment.v0.models.DeliveryUndefinedType(other))
        }
      }
    }

    def jsObjectDelivery(obj: io.flow.fulfillment.v0.models.Delivery): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.fulfillment.v0.models.DigitalDelivery => jsObjectDigitalDelivery(x) ++ play.api.libs.json.Json.obj("discriminator" -> "digital_delivery")
        case x: io.flow.fulfillment.v0.models.PhysicalDelivery => jsObjectPhysicalDelivery(x) ++ play.api.libs.json.Json.obj("discriminator" -> "physical_delivery")
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesFulfillmentDelivery: play.api.libs.json.Writes[Delivery] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.Delivery] {
        def writes(obj: io.flow.fulfillment.v0.models.Delivery) = {
          jsObjectDelivery(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentExpandableCenter: play.api.libs.json.Reads[ExpandableCenter] = new play.api.libs.json.Reads[ExpandableCenter] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[ExpandableCenter] = {
        (js \ "discriminator").asOpt[String].getOrElse { sys.error("Union[ExpandableCenter] requires a discriminator named 'discriminator' - this field was not found in the Json Value") } match {
          case "center" => js.validate[io.flow.fulfillment.v0.models.Center]
          case "center_reference" => js.validate[io.flow.fulfillment.v0.models.CenterReference]
          case other => play.api.libs.json.JsSuccess(io.flow.fulfillment.v0.models.ExpandableCenterUndefinedType(other))
        }
      }
    }

    def jsObjectExpandableCenter(obj: io.flow.fulfillment.v0.models.ExpandableCenter): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.fulfillment.v0.models.Center => jsObjectCenter(x) ++ play.api.libs.json.Json.obj("discriminator" -> "center")
        case x: io.flow.fulfillment.v0.models.CenterReference => jsObjectCenterReference(x) ++ play.api.libs.json.Json.obj("discriminator" -> "center_reference")
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesFulfillmentExpandableCenter: play.api.libs.json.Writes[ExpandableCenter] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.ExpandableCenter] {
        def writes(obj: io.flow.fulfillment.v0.models.ExpandableCenter) = {
          jsObjectExpandableCenter(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentPartnerCenterFee: play.api.libs.json.Reads[PartnerCenterFee] = new play.api.libs.json.Reads[PartnerCenterFee] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[PartnerCenterFee] = {
        (js \ "discriminator").asOpt[String].getOrElse { sys.error("Union[PartnerCenterFee] requires a discriminator named 'discriminator' - this field was not found in the Json Value") } match {
          case "commercial_invoice_fee" => js.validate[io.flow.fulfillment.v0.models.CommercialInvoiceFee]
          case "inbound_carton_fee" => js.validate[io.flow.fulfillment.v0.models.InboundCartonFee]
          case "outbound_carton_fee" => js.validate[io.flow.fulfillment.v0.models.OutboundCartonFee]
          case other => play.api.libs.json.JsSuccess(io.flow.fulfillment.v0.models.PartnerCenterFeeUndefinedType(other))
        }
      }
    }

    def jsObjectPartnerCenterFee(obj: io.flow.fulfillment.v0.models.PartnerCenterFee): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.fulfillment.v0.models.CommercialInvoiceFee => jsObjectCommercialInvoiceFee(x) ++ play.api.libs.json.Json.obj("discriminator" -> "commercial_invoice_fee")
        case x: io.flow.fulfillment.v0.models.InboundCartonFee => jsObjectInboundCartonFee(x) ++ play.api.libs.json.Json.obj("discriminator" -> "inbound_carton_fee")
        case x: io.flow.fulfillment.v0.models.OutboundCartonFee => jsObjectOutboundCartonFee(x) ++ play.api.libs.json.Json.obj("discriminator" -> "outbound_carton_fee")
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesFulfillmentPartnerCenterFee: play.api.libs.json.Writes[PartnerCenterFee] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.PartnerCenterFee] {
        def writes(obj: io.flow.fulfillment.v0.models.PartnerCenterFee) = {
          jsObjectPartnerCenterFee(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentTierRuleOutcome: play.api.libs.json.Reads[TierRuleOutcome] = new play.api.libs.json.Reads[TierRuleOutcome] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[TierRuleOutcome] = {
        (js \ "discriminator").asOpt[String].getOrElse { sys.error("Union[TierRuleOutcome] requires a discriminator named 'discriminator' - this field was not found in the Json Value") } match {
          case "amount_margin" => js.validate[io.flow.fulfillment.v0.models.AmountMargin]
          case "at_cost" => js.validate[io.flow.fulfillment.v0.models.AtCost]
          case "flat_rate" => js.validate[io.flow.fulfillment.v0.models.FlatRate]
          case "percent_margin" => js.validate[io.flow.fulfillment.v0.models.PercentMargin]
          case other => play.api.libs.json.JsSuccess(io.flow.fulfillment.v0.models.TierRuleOutcomeUndefinedType(other))
        }
      }
    }

    def jsObjectTierRuleOutcome(obj: io.flow.fulfillment.v0.models.TierRuleOutcome): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.fulfillment.v0.models.AmountMargin => jsObjectAmountMargin(x) ++ play.api.libs.json.Json.obj("discriminator" -> "amount_margin")
        case x: io.flow.fulfillment.v0.models.AtCost => jsObjectAtCost(x) ++ play.api.libs.json.Json.obj("discriminator" -> "at_cost")
        case x: io.flow.fulfillment.v0.models.FlatRate => jsObjectFlatRate(x) ++ play.api.libs.json.Json.obj("discriminator" -> "flat_rate")
        case x: io.flow.fulfillment.v0.models.PercentMargin => jsObjectPercentMargin(x) ++ play.api.libs.json.Json.obj("discriminator" -> "percent_margin")
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesFulfillmentTierRuleOutcome: play.api.libs.json.Writes[TierRuleOutcome] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.TierRuleOutcome] {
        def writes(obj: io.flow.fulfillment.v0.models.TierRuleOutcome) = {
          jsObjectTierRuleOutcome(obj)
        }
      }
    }

    implicit def jsonReadsFulfillmentTierRuleOutcomeForm: play.api.libs.json.Reads[TierRuleOutcomeForm] = new play.api.libs.json.Reads[TierRuleOutcomeForm] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[TierRuleOutcomeForm] = {
        (js \ "discriminator").asOpt[String].getOrElse { sys.error("Union[TierRuleOutcomeForm] requires a discriminator named 'discriminator' - this field was not found in the Json Value") } match {
          case "amount_margin_form" => js.validate[io.flow.fulfillment.v0.models.AmountMarginForm]
          case "flat_rate_form" => js.validate[io.flow.fulfillment.v0.models.FlatRateForm]
          case "at_cost" => js.validate[io.flow.fulfillment.v0.models.AtCost]
          case "percent_margin" => js.validate[io.flow.fulfillment.v0.models.PercentMargin]
          case other => play.api.libs.json.JsSuccess(io.flow.fulfillment.v0.models.TierRuleOutcomeFormUndefinedType(other))
        }
      }
    }

    def jsObjectTierRuleOutcomeForm(obj: io.flow.fulfillment.v0.models.TierRuleOutcomeForm): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.fulfillment.v0.models.AmountMarginForm => jsObjectAmountMarginForm(x) ++ play.api.libs.json.Json.obj("discriminator" -> "amount_margin_form")
        case x: io.flow.fulfillment.v0.models.FlatRateForm => jsObjectFlatRateForm(x) ++ play.api.libs.json.Json.obj("discriminator" -> "flat_rate_form")
        case x: io.flow.fulfillment.v0.models.AtCost => jsObjectAtCost(x) ++ play.api.libs.json.Json.obj("discriminator" -> "at_cost")
        case x: io.flow.fulfillment.v0.models.PercentMargin => jsObjectPercentMargin(x) ++ play.api.libs.json.Json.obj("discriminator" -> "percent_margin")
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesFulfillmentTierRuleOutcomeForm: play.api.libs.json.Writes[TierRuleOutcomeForm] = {
      new play.api.libs.json.Writes[io.flow.fulfillment.v0.models.TierRuleOutcomeForm] {
        def writes(obj: io.flow.fulfillment.v0.models.TierRuleOutcomeForm) = {
          jsObjectTierRuleOutcomeForm(obj)
        }
      }
    }
  }
}

package io.flow.fulfillment.v0 {

  object Bindables {

    import play.api.mvc.{PathBindable, QueryStringBindable}

    // import models directly for backwards compatibility with prior versions of the generator
    import Core._
    import Models._

    object Core {
      implicit def pathBindableDateTimeIso8601(implicit stringBinder: QueryStringBindable[String]): PathBindable[_root_.org.joda.time.DateTime] = ApibuilderPathBindable(ApibuilderTypes.dateTimeIso8601)
      implicit def queryStringBindableDateTimeIso8601(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[_root_.org.joda.time.DateTime] = ApibuilderQueryStringBindable(ApibuilderTypes.dateTimeIso8601)

      implicit def pathBindableDateIso8601(implicit stringBinder: QueryStringBindable[String]): PathBindable[_root_.org.joda.time.LocalDate] = ApibuilderPathBindable(ApibuilderTypes.dateIso8601)
      implicit def queryStringBindableDateIso8601(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[_root_.org.joda.time.LocalDate] = ApibuilderQueryStringBindable(ApibuilderTypes.dateIso8601)
    }

    object Models {
      import io.flow.fulfillment.v0.models._

      val centerCapabilityConverter: ApibuilderTypeConverter[io.flow.fulfillment.v0.models.CenterCapability] = new ApibuilderTypeConverter[io.flow.fulfillment.v0.models.CenterCapability] {
        override def convert(value: String): io.flow.fulfillment.v0.models.CenterCapability = io.flow.fulfillment.v0.models.CenterCapability(value)
        override def convert(value: io.flow.fulfillment.v0.models.CenterCapability): String = value.toString
        override def example: io.flow.fulfillment.v0.models.CenterCapability = io.flow.fulfillment.v0.models.CenterCapability.International
        override def validValues: Seq[io.flow.fulfillment.v0.models.CenterCapability] = io.flow.fulfillment.v0.models.CenterCapability.all
      }
      implicit def pathBindableCenterCapability(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.fulfillment.v0.models.CenterCapability] = ApibuilderPathBindable(centerCapabilityConverter)
      implicit def queryStringBindableCenterCapability(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.fulfillment.v0.models.CenterCapability] = ApibuilderQueryStringBindable(centerCapabilityConverter)

      val deliveryOptionCostDetailComponentKeyConverter: ApibuilderTypeConverter[io.flow.fulfillment.v0.models.DeliveryOptionCostDetailComponentKey] = new ApibuilderTypeConverter[io.flow.fulfillment.v0.models.DeliveryOptionCostDetailComponentKey] {
        override def convert(value: String): io.flow.fulfillment.v0.models.DeliveryOptionCostDetailComponentKey = io.flow.fulfillment.v0.models.DeliveryOptionCostDetailComponentKey(value)
        override def convert(value: io.flow.fulfillment.v0.models.DeliveryOptionCostDetailComponentKey): String = value.toString
        override def example: io.flow.fulfillment.v0.models.DeliveryOptionCostDetailComponentKey = io.flow.fulfillment.v0.models.DeliveryOptionCostDetailComponentKey.RatecardBaseCost
        override def validValues: Seq[io.flow.fulfillment.v0.models.DeliveryOptionCostDetailComponentKey] = io.flow.fulfillment.v0.models.DeliveryOptionCostDetailComponentKey.all
      }
      implicit def pathBindableDeliveryOptionCostDetailComponentKey(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.fulfillment.v0.models.DeliveryOptionCostDetailComponentKey] = ApibuilderPathBindable(deliveryOptionCostDetailComponentKeyConverter)
      implicit def queryStringBindableDeliveryOptionCostDetailComponentKey(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.fulfillment.v0.models.DeliveryOptionCostDetailComponentKey] = ApibuilderQueryStringBindable(deliveryOptionCostDetailComponentKeyConverter)

      val deliveryOptionCostDetailSourceConverter: ApibuilderTypeConverter[io.flow.fulfillment.v0.models.DeliveryOptionCostDetailSource] = new ApibuilderTypeConverter[io.flow.fulfillment.v0.models.DeliveryOptionCostDetailSource] {
        override def convert(value: String): io.flow.fulfillment.v0.models.DeliveryOptionCostDetailSource = io.flow.fulfillment.v0.models.DeliveryOptionCostDetailSource(value)
        override def convert(value: io.flow.fulfillment.v0.models.DeliveryOptionCostDetailSource): String = value.toString
        override def example: io.flow.fulfillment.v0.models.DeliveryOptionCostDetailSource = io.flow.fulfillment.v0.models.DeliveryOptionCostDetailSource.Center
        override def validValues: Seq[io.flow.fulfillment.v0.models.DeliveryOptionCostDetailSource] = io.flow.fulfillment.v0.models.DeliveryOptionCostDetailSource.all
      }
      implicit def pathBindableDeliveryOptionCostDetailSource(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.fulfillment.v0.models.DeliveryOptionCostDetailSource] = ApibuilderPathBindable(deliveryOptionCostDetailSourceConverter)
      implicit def queryStringBindableDeliveryOptionCostDetailSource(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.fulfillment.v0.models.DeliveryOptionCostDetailSource] = ApibuilderQueryStringBindable(deliveryOptionCostDetailSourceConverter)

      val deliveryWindowComponentSourceConverter: ApibuilderTypeConverter[io.flow.fulfillment.v0.models.DeliveryWindowComponentSource] = new ApibuilderTypeConverter[io.flow.fulfillment.v0.models.DeliveryWindowComponentSource] {
        override def convert(value: String): io.flow.fulfillment.v0.models.DeliveryWindowComponentSource = io.flow.fulfillment.v0.models.DeliveryWindowComponentSource(value)
        override def convert(value: io.flow.fulfillment.v0.models.DeliveryWindowComponentSource): String = value.toString
        override def example: io.flow.fulfillment.v0.models.DeliveryWindowComponentSource = io.flow.fulfillment.v0.models.DeliveryWindowComponentSource.Flow
        override def validValues: Seq[io.flow.fulfillment.v0.models.DeliveryWindowComponentSource] = io.flow.fulfillment.v0.models.DeliveryWindowComponentSource.all
      }
      implicit def pathBindableDeliveryWindowComponentSource(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.fulfillment.v0.models.DeliveryWindowComponentSource] = ApibuilderPathBindable(deliveryWindowComponentSourceConverter)
      implicit def queryStringBindableDeliveryWindowComponentSource(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.fulfillment.v0.models.DeliveryWindowComponentSource] = ApibuilderQueryStringBindable(deliveryWindowComponentSourceConverter)

      val deliveryWindowLocationConverter: ApibuilderTypeConverter[io.flow.fulfillment.v0.models.DeliveryWindowLocation] = new ApibuilderTypeConverter[io.flow.fulfillment.v0.models.DeliveryWindowLocation] {
        override def convert(value: String): io.flow.fulfillment.v0.models.DeliveryWindowLocation = io.flow.fulfillment.v0.models.DeliveryWindowLocation(value)
        override def convert(value: io.flow.fulfillment.v0.models.DeliveryWindowLocation): String = value.toString
        override def example: io.flow.fulfillment.v0.models.DeliveryWindowLocation = io.flow.fulfillment.v0.models.DeliveryWindowLocation.Center
        override def validValues: Seq[io.flow.fulfillment.v0.models.DeliveryWindowLocation] = io.flow.fulfillment.v0.models.DeliveryWindowLocation.all
      }
      implicit def pathBindableDeliveryWindowLocation(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.fulfillment.v0.models.DeliveryWindowLocation] = ApibuilderPathBindable(deliveryWindowLocationConverter)
      implicit def queryStringBindableDeliveryWindowLocation(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.fulfillment.v0.models.DeliveryWindowLocation] = ApibuilderQueryStringBindable(deliveryWindowLocationConverter)

      val itemAvailabilityStatusConverter: ApibuilderTypeConverter[io.flow.fulfillment.v0.models.ItemAvailabilityStatus] = new ApibuilderTypeConverter[io.flow.fulfillment.v0.models.ItemAvailabilityStatus] {
        override def convert(value: String): io.flow.fulfillment.v0.models.ItemAvailabilityStatus = io.flow.fulfillment.v0.models.ItemAvailabilityStatus(value)
        override def convert(value: io.flow.fulfillment.v0.models.ItemAvailabilityStatus): String = value.toString
        override def example: io.flow.fulfillment.v0.models.ItemAvailabilityStatus = io.flow.fulfillment.v0.models.ItemAvailabilityStatus.Available
        override def validValues: Seq[io.flow.fulfillment.v0.models.ItemAvailabilityStatus] = io.flow.fulfillment.v0.models.ItemAvailabilityStatus.all
      }
      implicit def pathBindableItemAvailabilityStatus(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.fulfillment.v0.models.ItemAvailabilityStatus] = ApibuilderPathBindable(itemAvailabilityStatusConverter)
      implicit def queryStringBindableItemAvailabilityStatus(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.fulfillment.v0.models.ItemAvailabilityStatus] = ApibuilderQueryStringBindable(itemAvailabilityStatusConverter)

      val laneStrategyConverter: ApibuilderTypeConverter[io.flow.fulfillment.v0.models.LaneStrategy] = new ApibuilderTypeConverter[io.flow.fulfillment.v0.models.LaneStrategy] {
        override def convert(value: String): io.flow.fulfillment.v0.models.LaneStrategy = io.flow.fulfillment.v0.models.LaneStrategy(value)
        override def convert(value: io.flow.fulfillment.v0.models.LaneStrategy): String = value.toString
        override def example: io.flow.fulfillment.v0.models.LaneStrategy = io.flow.fulfillment.v0.models.LaneStrategy.Oldest
        override def validValues: Seq[io.flow.fulfillment.v0.models.LaneStrategy] = io.flow.fulfillment.v0.models.LaneStrategy.all
      }
      implicit def pathBindableLaneStrategy(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.fulfillment.v0.models.LaneStrategy] = ApibuilderPathBindable(laneStrategyConverter)
      implicit def queryStringBindableLaneStrategy(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.fulfillment.v0.models.LaneStrategy] = ApibuilderQueryStringBindable(laneStrategyConverter)

      val physicalDeliverySpecialSerivceConverter: ApibuilderTypeConverter[io.flow.fulfillment.v0.models.PhysicalDeliverySpecialSerivce] = new ApibuilderTypeConverter[io.flow.fulfillment.v0.models.PhysicalDeliverySpecialSerivce] {
        override def convert(value: String): io.flow.fulfillment.v0.models.PhysicalDeliverySpecialSerivce = io.flow.fulfillment.v0.models.PhysicalDeliverySpecialSerivce(value)
        override def convert(value: io.flow.fulfillment.v0.models.PhysicalDeliverySpecialSerivce): String = value.toString
        override def example: io.flow.fulfillment.v0.models.PhysicalDeliverySpecialSerivce = io.flow.fulfillment.v0.models.PhysicalDeliverySpecialSerivce.ColdStorage
        override def validValues: Seq[io.flow.fulfillment.v0.models.PhysicalDeliverySpecialSerivce] = io.flow.fulfillment.v0.models.PhysicalDeliverySpecialSerivce.all
      }
      implicit def pathBindablePhysicalDeliverySpecialSerivce(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.fulfillment.v0.models.PhysicalDeliverySpecialSerivce] = ApibuilderPathBindable(physicalDeliverySpecialSerivceConverter)
      implicit def queryStringBindablePhysicalDeliverySpecialSerivce(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.fulfillment.v0.models.PhysicalDeliverySpecialSerivce] = ApibuilderQueryStringBindable(physicalDeliverySpecialSerivceConverter)

      val quoteErrorCodeConverter: ApibuilderTypeConverter[io.flow.fulfillment.v0.models.QuoteErrorCode] = new ApibuilderTypeConverter[io.flow.fulfillment.v0.models.QuoteErrorCode] {
        override def convert(value: String): io.flow.fulfillment.v0.models.QuoteErrorCode = io.flow.fulfillment.v0.models.QuoteErrorCode(value)
        override def convert(value: io.flow.fulfillment.v0.models.QuoteErrorCode): String = value.toString
        override def example: io.flow.fulfillment.v0.models.QuoteErrorCode = io.flow.fulfillment.v0.models.QuoteErrorCode.GenericError
        override def validValues: Seq[io.flow.fulfillment.v0.models.QuoteErrorCode] = io.flow.fulfillment.v0.models.QuoteErrorCode.all
      }
      implicit def pathBindableQuoteErrorCode(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.fulfillment.v0.models.QuoteErrorCode] = ApibuilderPathBindable(quoteErrorCodeConverter)
      implicit def queryStringBindableQuoteErrorCode(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.fulfillment.v0.models.QuoteErrorCode] = ApibuilderQueryStringBindable(quoteErrorCodeConverter)

      val shipmentIntegrationTypeConverter: ApibuilderTypeConverter[io.flow.fulfillment.v0.models.ShipmentIntegrationType] = new ApibuilderTypeConverter[io.flow.fulfillment.v0.models.ShipmentIntegrationType] {
        override def convert(value: String): io.flow.fulfillment.v0.models.ShipmentIntegrationType = io.flow.fulfillment.v0.models.ShipmentIntegrationType(value)
        override def convert(value: io.flow.fulfillment.v0.models.ShipmentIntegrationType): String = value.toString
        override def example: io.flow.fulfillment.v0.models.ShipmentIntegrationType = io.flow.fulfillment.v0.models.ShipmentIntegrationType.Direct
        override def validValues: Seq[io.flow.fulfillment.v0.models.ShipmentIntegrationType] = io.flow.fulfillment.v0.models.ShipmentIntegrationType.all
      }
      implicit def pathBindableShipmentIntegrationType(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.fulfillment.v0.models.ShipmentIntegrationType] = ApibuilderPathBindable(shipmentIntegrationTypeConverter)
      implicit def queryStringBindableShipmentIntegrationType(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.fulfillment.v0.models.ShipmentIntegrationType] = ApibuilderQueryStringBindable(shipmentIntegrationTypeConverter)

      val shippingConfigurationTypeConverter: ApibuilderTypeConverter[io.flow.fulfillment.v0.models.ShippingConfigurationType] = new ApibuilderTypeConverter[io.flow.fulfillment.v0.models.ShippingConfigurationType] {
        override def convert(value: String): io.flow.fulfillment.v0.models.ShippingConfigurationType = io.flow.fulfillment.v0.models.ShippingConfigurationType(value)
        override def convert(value: io.flow.fulfillment.v0.models.ShippingConfigurationType): String = value.toString
        override def example: io.flow.fulfillment.v0.models.ShippingConfigurationType = io.flow.fulfillment.v0.models.ShippingConfigurationType.Default
        override def validValues: Seq[io.flow.fulfillment.v0.models.ShippingConfigurationType] = io.flow.fulfillment.v0.models.ShippingConfigurationType.all
      }
      implicit def pathBindableShippingConfigurationType(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.fulfillment.v0.models.ShippingConfigurationType] = ApibuilderPathBindable(shippingConfigurationTypeConverter)
      implicit def queryStringBindableShippingConfigurationType(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.fulfillment.v0.models.ShippingConfigurationType] = ApibuilderQueryStringBindable(shippingConfigurationTypeConverter)

      val strategyConverter: ApibuilderTypeConverter[io.flow.fulfillment.v0.models.Strategy] = new ApibuilderTypeConverter[io.flow.fulfillment.v0.models.Strategy] {
        override def convert(value: String): io.flow.fulfillment.v0.models.Strategy = io.flow.fulfillment.v0.models.Strategy(value)
        override def convert(value: io.flow.fulfillment.v0.models.Strategy): String = value.toString
        override def example: io.flow.fulfillment.v0.models.Strategy = io.flow.fulfillment.v0.models.Strategy.Range
        override def validValues: Seq[io.flow.fulfillment.v0.models.Strategy] = io.flow.fulfillment.v0.models.Strategy.all
      }
      implicit def pathBindableStrategy(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.fulfillment.v0.models.Strategy] = ApibuilderPathBindable(strategyConverter)
      implicit def queryStringBindableStrategy(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.fulfillment.v0.models.Strategy] = ApibuilderQueryStringBindable(strategyConverter)

      val surchargeResponsiblePartyConverter: ApibuilderTypeConverter[io.flow.fulfillment.v0.models.SurchargeResponsibleParty] = new ApibuilderTypeConverter[io.flow.fulfillment.v0.models.SurchargeResponsibleParty] {
        override def convert(value: String): io.flow.fulfillment.v0.models.SurchargeResponsibleParty = io.flow.fulfillment.v0.models.SurchargeResponsibleParty(value)
        override def convert(value: io.flow.fulfillment.v0.models.SurchargeResponsibleParty): String = value.toString
        override def example: io.flow.fulfillment.v0.models.SurchargeResponsibleParty = io.flow.fulfillment.v0.models.SurchargeResponsibleParty.Organization
        override def validValues: Seq[io.flow.fulfillment.v0.models.SurchargeResponsibleParty] = io.flow.fulfillment.v0.models.SurchargeResponsibleParty.all
      }
      implicit def pathBindableSurchargeResponsibleParty(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.fulfillment.v0.models.SurchargeResponsibleParty] = ApibuilderPathBindable(surchargeResponsiblePartyConverter)
      implicit def queryStringBindableSurchargeResponsibleParty(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.fulfillment.v0.models.SurchargeResponsibleParty] = ApibuilderQueryStringBindable(surchargeResponsiblePartyConverter)

      val tierDirectionConverter: ApibuilderTypeConverter[io.flow.fulfillment.v0.models.TierDirection] = new ApibuilderTypeConverter[io.flow.fulfillment.v0.models.TierDirection] {
        override def convert(value: String): io.flow.fulfillment.v0.models.TierDirection = io.flow.fulfillment.v0.models.TierDirection(value)
        override def convert(value: io.flow.fulfillment.v0.models.TierDirection): String = value.toString
        override def example: io.flow.fulfillment.v0.models.TierDirection = io.flow.fulfillment.v0.models.TierDirection.Outbound
        override def validValues: Seq[io.flow.fulfillment.v0.models.TierDirection] = io.flow.fulfillment.v0.models.TierDirection.all
      }
      implicit def pathBindableTierDirection(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.fulfillment.v0.models.TierDirection] = ApibuilderPathBindable(tierDirectionConverter)
      implicit def queryStringBindableTierDirection(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.fulfillment.v0.models.TierDirection] = ApibuilderQueryStringBindable(tierDirectionConverter)

      val tierEstimateTypeConverter: ApibuilderTypeConverter[io.flow.fulfillment.v0.models.TierEstimateType] = new ApibuilderTypeConverter[io.flow.fulfillment.v0.models.TierEstimateType] {
        override def convert(value: String): io.flow.fulfillment.v0.models.TierEstimateType = io.flow.fulfillment.v0.models.TierEstimateType(value)
        override def convert(value: io.flow.fulfillment.v0.models.TierEstimateType): String = value.toString
        override def example: io.flow.fulfillment.v0.models.TierEstimateType = io.flow.fulfillment.v0.models.TierEstimateType.Calculated
        override def validValues: Seq[io.flow.fulfillment.v0.models.TierEstimateType] = io.flow.fulfillment.v0.models.TierEstimateType.all
      }
      implicit def pathBindableTierEstimateType(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.fulfillment.v0.models.TierEstimateType] = ApibuilderPathBindable(tierEstimateTypeConverter)
      implicit def queryStringBindableTierEstimateType(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.fulfillment.v0.models.TierEstimateType] = ApibuilderQueryStringBindable(tierEstimateTypeConverter)

      val tierStrategyConverter: ApibuilderTypeConverter[io.flow.fulfillment.v0.models.TierStrategy] = new ApibuilderTypeConverter[io.flow.fulfillment.v0.models.TierStrategy] {
        override def convert(value: String): io.flow.fulfillment.v0.models.TierStrategy = io.flow.fulfillment.v0.models.TierStrategy(value)
        override def convert(value: io.flow.fulfillment.v0.models.TierStrategy): String = value.toString
        override def example: io.flow.fulfillment.v0.models.TierStrategy = io.flow.fulfillment.v0.models.TierStrategy.Fastest
        override def validValues: Seq[io.flow.fulfillment.v0.models.TierStrategy] = io.flow.fulfillment.v0.models.TierStrategy.all
      }
      implicit def pathBindableTierStrategy(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.fulfillment.v0.models.TierStrategy] = ApibuilderPathBindable(tierStrategyConverter)
      implicit def queryStringBindableTierStrategy(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.fulfillment.v0.models.TierStrategy] = ApibuilderQueryStringBindable(tierStrategyConverter)

      val zeroAmountIndicatorConverter: ApibuilderTypeConverter[io.flow.fulfillment.v0.models.ZeroAmountIndicator] = new ApibuilderTypeConverter[io.flow.fulfillment.v0.models.ZeroAmountIndicator] {
        override def convert(value: String): io.flow.fulfillment.v0.models.ZeroAmountIndicator = io.flow.fulfillment.v0.models.ZeroAmountIndicator(value)
        override def convert(value: io.flow.fulfillment.v0.models.ZeroAmountIndicator): String = value.toString
        override def example: io.flow.fulfillment.v0.models.ZeroAmountIndicator = io.flow.fulfillment.v0.models.ZeroAmountIndicator.Zero
        override def validValues: Seq[io.flow.fulfillment.v0.models.ZeroAmountIndicator] = io.flow.fulfillment.v0.models.ZeroAmountIndicator.all
      }
      implicit def pathBindableZeroAmountIndicator(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.fulfillment.v0.models.ZeroAmountIndicator] = ApibuilderPathBindable(zeroAmountIndicatorConverter)
      implicit def queryStringBindableZeroAmountIndicator(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.fulfillment.v0.models.ZeroAmountIndicator] = ApibuilderQueryStringBindable(zeroAmountIndicatorConverter)
    }

    trait ApibuilderTypeConverter[T] {

      def convert(value: String): T

      def convert(value: T): String

      def example: T

      def validValues: Seq[T] = Nil

      def errorMessage(key: String, value: String, ex: java.lang.Exception): String = {
        val base = s"Invalid value '$value' for parameter '$key'. "
        validValues.toList match {
          case Nil => base + "Ex: " + convert(example)
          case values => base + ". Valid values are: " + values.mkString("'", "', '", "'")
        }
      }
    }

    object ApibuilderTypes {
      val dateTimeIso8601: ApibuilderTypeConverter[_root_.org.joda.time.DateTime] = new ApibuilderTypeConverter[_root_.org.joda.time.DateTime] {
        override def convert(value: String): _root_.org.joda.time.DateTime = _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseDateTime(value)
        override def convert(value: _root_.org.joda.time.DateTime): String = _root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(value)
        override def example: _root_.org.joda.time.DateTime = _root_.org.joda.time.DateTime.now
      }

      val dateIso8601: ApibuilderTypeConverter[_root_.org.joda.time.LocalDate] = new ApibuilderTypeConverter[_root_.org.joda.time.LocalDate] {
        override def convert(value: String): _root_.org.joda.time.LocalDate = _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseLocalDate(value)
        override def convert(value: _root_.org.joda.time.LocalDate): String = _root_.org.joda.time.format.ISODateTimeFormat.date.print(value)
        override def example: _root_.org.joda.time.LocalDate = _root_.org.joda.time.LocalDate.now
      }
    }

    final case class ApibuilderQueryStringBindable[T](
      converters: ApibuilderTypeConverter[T]
    ) extends QueryStringBindable[T] {

      override def bind(key: String, params: Map[String, Seq[String]]): _root_.scala.Option[_root_.scala.Either[String, T]] = {
        params.getOrElse(key, Nil).headOption.map { v =>
          try {
            Right(
              converters.convert(v)
            )
          } catch {
            case ex: java.lang.Exception => Left(
              converters.errorMessage(key, v, ex)
            )
          }
        }
      }

      override def unbind(key: String, value: T): String = {
        s"$key=${converters.convert(value)}"
      }
    }

    final case class ApibuilderPathBindable[T](
      converters: ApibuilderTypeConverter[T]
    ) extends PathBindable[T] {

      override def bind(key: String, value: String): _root_.scala.Either[String, T] = {
        try {
          Right(
            converters.convert(value)
          )
        } catch {
          case ex: java.lang.Exception => Left(
            converters.errorMessage(key, value, ex)
          )
        }
      }

      override def unbind(key: String, value: T): String = {
        converters.convert(value)
      }
    }

  }

}
